Directory structure:
â””â”€â”€ didiercito-microservicio--kitchen/
    â”œâ”€â”€ package.json
    â””â”€â”€ src/
        â”œâ”€â”€ app.js
        â”œâ”€â”€ server.js
        â”œâ”€â”€ application/
        â”‚   â””â”€â”€ use-cases/
        â”‚       â”œâ”€â”€ ApproveKitchenUseCase.js
        â”‚       â”œâ”€â”€ CreateKitchenScheduleUseCase.js
        â”‚       â”œâ”€â”€ GetApprovedKitchensUseCase.js
        â”‚       â”œâ”€â”€ GetKitchenDetailsUseCase.js
        â”‚       â”œâ”€â”€ GetKitchenScheduleUseCase.js
        â”‚       â”œâ”€â”€ GetNearbyKitchensUseCase.js
        â”‚       â”œâ”€â”€ GetPendingKitchensUseCase.js
        â”‚       â”œâ”€â”€ GetRejectedKitchensUseCase.js
        â”‚       â”œâ”€â”€ RejectKitchenUseCase.js
        â”‚       â”œâ”€â”€ RequestKitchenUseCase.js
        â”‚       â”œâ”€â”€ RequestLocationUseCase.js
        â”‚       â”œâ”€â”€ UpdateKitchenInfoUseCase.js
        â”‚       â””â”€â”€ UpdateKitchenScheduleUseCase.js
        â”œâ”€â”€ domain/
        â”‚   â”œâ”€â”€ entities/
        â”‚   â”‚   â”œâ”€â”€ Kitchen.js
        â”‚   â”‚   â”œâ”€â”€ KitchenResponsible.js
        â”‚   â”‚   â”œâ”€â”€ KitchenSchedule.js
        â”‚   â”‚   â””â”€â”€ Location.js
        â”‚   â””â”€â”€ repositories/
        â”‚       â”œâ”€â”€ IEventPublisher.js
        â”‚       â”œâ”€â”€ IKitchenRepository.js
        â”‚       â”œâ”€â”€ IKitchenScheduleRepository.js
        â”‚       â””â”€â”€ ILocationRepository.js
        â”œâ”€â”€ infrastructure/
        â”‚   â”œâ”€â”€ adapters/
        â”‚   â”‚   â””â”€â”€ RabbitMQPublisher.js
        â”‚   â”œâ”€â”€ api/
        â”‚   â”‚   â”œâ”€â”€ controllers/
        â”‚   â”‚   â”‚   â”œâ”€â”€ KitchenController.js
        â”‚   â”‚   â”‚   â””â”€â”€ KitchenScheduleController.js
        â”‚   â”‚   â”œâ”€â”€ dependencies/
        â”‚   â”‚   â”‚   â””â”€â”€ dependencies.js
        â”‚   â”‚   â””â”€â”€ routes/
        â”‚   â”‚       â”œâ”€â”€ KitchenRoutes.js
        â”‚   â”‚       â””â”€â”€ KitchenScheduleRoutes.js
        â”‚   â”œâ”€â”€ database/
        â”‚   â”‚   â”œâ”€â”€ config/
        â”‚   â”‚   â”‚   â””â”€â”€ database.js
        â”‚   â”‚   â”œâ”€â”€ models/
        â”‚   â”‚   â”‚   â”œâ”€â”€ KitchenModel.js
        â”‚   â”‚   â”‚   â”œâ”€â”€ KitchenResponsibleModel.js
        â”‚   â”‚   â”‚   â”œâ”€â”€ KitchenScheduleModel.js
        â”‚   â”‚   â”‚   â””â”€â”€ LocationModel.js
        â”‚   â”‚   â””â”€â”€ repositories/
        â”‚   â”‚       â”œâ”€â”€ SequelizeKitchenRepository.js
        â”‚   â”‚       â”œâ”€â”€ SequelizeKitchenResponsibleRepository.js
        â”‚   â”‚       â”œâ”€â”€ SequelizeKitchenScheduleRepository.js
        â”‚   â”‚       â””â”€â”€ SequelizeLocationRepository.js
        â”‚   â””â”€â”€ store/
        â”‚       â””â”€â”€ temp-password.store.js
        â””â”€â”€ middleware/
            â”œâ”€â”€ require-auth.js
            â”œâ”€â”€ require-kitchen-owner.js
            â””â”€â”€ require-role.js

================================================
FILE: package.json
================================================
{
  "name": "kitchens-service",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "amqplib": "^0.10.9",
    "axios": "^1.13.2",
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.1",
    "pg": "^8.16.3",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.37.7"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}



================================================
FILE: src/app.js
================================================
const express = require('express');
const cors = require('cors');
const kitchenRoutes = require('./infrastructure/api/routes/KitchenRoutes');

const app = express();
app.use(cors({ origin: '*' }));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use('/api/v1/kitchens', kitchenRoutes);

app.get('/', (_req, res) => {
  res.send('API de Cocinas Comunitarias funcionando');
});

module.exports = app;



================================================
FILE: src/server.js
================================================
require('dotenv').config();
const app = require('./app');
const sequelize = require('./infrastructure/database/config/database');
const publisher = require('./infrastructure/adapters/RabbitMQPublisher');
require('./infrastructure/database/models/LocationModel');
require('./infrastructure/database/models/KitchenModel');


const PORT = process.env.PORT;

async function startServer() {
  try {
    console.log('ðŸš€ Iniciando Kitchen Service...');

    await sequelize.authenticate();
    console.log('âœ… ConexiÃ³n a la base de datos (PostgreSQL) establecida.');

    if (process.env.NODE_ENV === 'development') {
      await sequelize.sync({ alter: true });
      console.log('ðŸ”„ Tablas sincronizadas automÃ¡ticamente con { alter: true }');
    } else {
      await sequelize.sync();
      console.log('âœ… Tablas verificadas (sin alteraciones)');
    }

    await publisher.connect();
    console.log('ðŸ‡ RabbitMQ conectado correctamente (Publisher listo).');

    app.listen(PORT, () => {
      console.log(`ðŸŒ Servidor corriendo en el puerto ${PORT}`);
    });

  } catch (error) {
    console.error('âŒ Error al iniciar el servidor:', error);
    process.exit(1);
  }
}

startServer();



================================================
FILE: src/application/use-cases/ApproveKitchenUseCase.js
================================================
const { getTemporaryPassword, clearTemporaryPassword } = require("../../infrastructure/store/temp-password.store");

class ApproveKitchenUseCase {
  constructor(kitchenRepository, responsibleRepository, eventPublisher) {
    this.kitchenRepository = kitchenRepository;
    this.responsibleRepository = responsibleRepository;
    this.eventPublisher = eventPublisher;
  }

  async execute(kitchenId) {
    const kitchen = await this.kitchenRepository.findById(kitchenId);
    if (!kitchen) throw { http_status: 404, message: "Kitchen not found" };

    const responsible = await this.responsibleRepository.findByKitchenId(kitchenId);
    if (!responsible) throw { http_status: 500, message: "Kitchen responsible not found" };

    const password = getTemporaryPassword(kitchenId);
    if (!password) throw { http_status: 500, message: "Temporary password missing" };

    kitchen.approvalStatus = "approved";
    kitchen.isActive = true;

    const updatedKitchen = await this.kitchenRepository.update(kitchenId, kitchen);

    await this.eventPublisher.publish("kitchen.admin.registered", {
      names: responsible.names,
      firstLastName: responsible.firstLast_name,
      secondLastName: responsible.secondLast_name,
      email: responsible.email,
      phoneNumber: responsible.phone_number,
      password
    });

    clearTemporaryPassword(kitchenId);

    return updatedKitchen;
  }
}

module.exports = ApproveKitchenUseCase;


================================================
FILE: src/application/use-cases/CreateKitchenScheduleUseCase.js
================================================
const KitchenSchedule = require('../../domain/entities/KitchenSchedule');

class CreateKitchenScheduleUseCase {
  constructor(scheduleRepository) {
    this.scheduleRepository = scheduleRepository;
  }

  async execute(kitchenId, payload) {
    await this.scheduleRepository.deleteByKitchenId(kitchenId);

    const schedules = KitchenSchedule.fromSimplified(kitchenId, payload);

    for (const schedule of schedules) {
      await this.scheduleRepository.create(schedule);
    }

    return schedules;
  }
}

module.exports = CreateKitchenScheduleUseCase;



================================================
FILE: src/application/use-cases/GetApprovedKitchensUseCase.js
================================================
class GetApprovedKitchensUseCase {
  constructor(kitchenRepository) {
    this.kitchenRepository = kitchenRepository;
  }

  async execute() {
    const approvedKitchens = await this.kitchenRepository.findByStatus('approved');
    return approvedKitchens;
  }
}

module.exports = GetApprovedKitchensUseCase;


================================================
FILE: src/application/use-cases/GetKitchenDetailsUseCase.js
================================================
class GetKitchenDetailsUseCase {
  constructor(kitchenRepository, locationRepository) {
    this.kitchenRepository = kitchenRepository;
    this.locationRepository = locationRepository;
  }

  async execute(kitchenId) {
    const kitchen = await this.kitchenRepository.findById(kitchenId);
    if (!kitchen) throw new Error("Cocina no encontrada");

    const location = kitchen.location_id
      ? await this.locationRepository.findById(kitchen.location_id)
      : null;

    return { kitchen, location };
  }
}

module.exports = GetKitchenDetailsUseCase;  


================================================
FILE: src/application/use-cases/GetKitchenScheduleUseCase.js
================================================
class GetKitchenScheduleUseCase {
  constructor(scheduleRepository) {
    this.scheduleRepository = scheduleRepository;
  }

  async execute(kitchenId) {
    return this.scheduleRepository.findByKitchenId(kitchenId);
  }
}

module.exports = GetKitchenScheduleUseCase;



================================================
FILE: src/application/use-cases/GetNearbyKitchensUseCase.js
================================================
class GetNearbyKitchensUseCase {

  constructor(kitchenRepository, locationRepository) {
    this.kitchenRepository = kitchenRepository;
    this.locationRepository = locationRepository;
  }

  async execute({ stateId, municipalityId }) {
    const locations = await this.locationRepository.findByStateAndMunicipality(
      stateId,
      municipalityId
    );

    const ids = locations.map(l => l.id);

    const kitchens = await this.kitchenRepository.findByLocationIds(ids);

    return kitchens;
  }
}

module.exports = GetNearbyKitchensUseCase;


================================================
FILE: src/application/use-cases/GetPendingKitchensUseCase.js
================================================
class GetPendingKitchensUseCase {
  constructor(kitchenRepository) {
    this.kitchenRepository = kitchenRepository;
  }

  async execute() {
    const kitchens = await this.kitchenRepository.findPending();
    return kitchens.map(k => k.toJSON());
  }
}

module.exports = GetPendingKitchensUseCase;


================================================
FILE: src/application/use-cases/GetRejectedKitchensUseCase.js
================================================
// src/application/use-cases/GetRejectedKitchensUseCase.js

class GetRejectedKitchensUseCase {
  constructor(kitchenRepository) {
    this.kitchenRepository = kitchenRepository;
  }

  async execute() {
    const rejectedKitchens = await this.kitchenRepository.findByStatus('rejected');
    return rejectedKitchens;
  }
}

module.exports = GetRejectedKitchensUseCase;


================================================
FILE: src/application/use-cases/RejectKitchenUseCase.js
================================================
class RejectKitchenUseCase {
  constructor(kitchenRepository, eventPublisher) {
    this.kitchenRepository = kitchenRepository;
    this.eventPublisher = eventPublisher;
  }

  async execute(kitchenId, reason, adminUserId) {

    const kitchen = await this.kitchenRepository.findById(kitchenId);
    if (!kitchen) throw new Error("Cocina no encontrada");

    const updatedKitchen = await this.kitchenRepository.update(kitchenId, {
      approval_status: "rejected",
      rejection_reason: reason,
      is_active: false,
      approved_by: null,
      approval_date: null
    });

    await this.eventPublisher.publish("kitchen.rejected", {
      kitchenId: updatedKitchen.id,
      ownerId: updatedKitchen.owner_id,
      kitchenName: updatedKitchen.name,
      rejectionReason: reason,
      rejectedBy: adminUserId,
      timestamp: new Date().toISOString()
    });

    return updatedKitchen;
  }
}

module.exports = RejectKitchenUseCase;


================================================
FILE: src/application/use-cases/RequestKitchenUseCase.js
================================================
const { saveTemporaryPassword } = require("../../infrastructure/store/temp-password.store");

class RequestKitchenUseCase {
  constructor(kitchenRepository, locationRepository, responsibleRepository) {
    this.kitchenRepository = kitchenRepository;
    this.locationRepository = locationRepository;
    this.responsibleRepository = responsibleRepository;
  }

  async execute(data) {
    const { responsible, kitchen, location } = data;

    if (!responsible.password) {
      throw new Error("Password is required for the responsible user.");
    }

    const locationCreated = await this.locationRepository.create(location);

    const kitchenCreated = await this.kitchenRepository.create({
      ...kitchen,
      location_id: locationCreated.id
    });

    await this.responsibleRepository.create({
      kitchen_id: kitchenCreated.id,
      names: responsible.names,
      first_last_name: responsible.firstLastName,
      second_last_name: responsible.secondLastName,
      email: responsible.email,
      phone_number: responsible.phoneNumber
    });

    saveTemporaryPassword(kitchenCreated.id, responsible.password);

    return kitchenCreated;
  }
}

module.exports = RequestKitchenUseCase;


================================================
FILE: src/application/use-cases/RequestLocationUseCase.js
================================================
const Location = require('../../domain/entities/Location');

class RequestLocationUseCase {
  constructor(locationRepository) {
    this.locationRepository = locationRepository;
  }

  async execute(data) {
    const location = new Location({
      name: data.neighborhood || data.name || 'UbicaciÃ³n',
      streetAddress: data.streetAddress,
      neighborhood: data.neighborhood,
      stateId: data.stateId,
      municipalityId: data.municipalityId,
      postalCode: data.postalCode,
      is_active: true
    });

    const newLocation = await this.locationRepository.create(location);
    return newLocation;
  }
}

module.exports = RequestLocationUseCase;


================================================
FILE: src/application/use-cases/UpdateKitchenInfoUseCase.js
================================================
class UpdateKitchenInfoUseCase {
  constructor(kitchenRepository, locationRepository) {
    this.kitchenRepository = kitchenRepository;
    this.locationRepository = locationRepository;
  }

  async execute(adminUserId, kitchenId, data) {
    const {
      name,
      description,
      contactPhone,
      contactEmail,
      imageUrl,
      location: {
        streetAddress,
        neighborhood,
        postalCode,
        stateId,
        municipalityId
      }
    } = data;

    const kitchen = await this.kitchenRepository.findById(kitchenId);
    if (!kitchen) throw { http_status: 404, message: "Cocina no encontrada" };

    const ownerId = await this.kitchenRepository.findOwnerIdByKitchenId(kitchenId);
    if (ownerId !== adminUserId) {
      throw { http_status: 403, message: "No puedes editar una cocina que no te pertenece" };
    }

    await this.locationRepository.update(kitchen.locationId, {
      street_address: streetAddress,
      neighborhood,
      postal_code: postalCode,
      state_id: stateId,
      municipality_id: municipalityId
    });

    const updatedKitchen = await this.kitchenRepository.update(kitchenId, {
      name,
      description,
      contact_phone: contactPhone,
      contact_email: contactEmail,
      image_url: imageUrl ?? null
    });

    return updatedKitchen;
  }
}

module.exports = UpdateKitchenInfoUseCase;



================================================
FILE: src/application/use-cases/UpdateKitchenScheduleUseCase.js
================================================
const KitchenSchedule = require('../../domain/entities/KitchenSchedule');

class UpdateKitchenScheduleUseCase {
  constructor(scheduleRepository) {
    this.scheduleRepository = scheduleRepository;
  }

  async execute(kitchenId, payload) {
    await this.scheduleRepository.deleteByKitchenId(kitchenId);

    const schedules = KitchenSchedule.fromSimplified(kitchenId, payload);

    for (const schedule of schedules) {
      await this.scheduleRepository.create(schedule);
    }

    return schedules;
  }
}

module.exports = UpdateKitchenScheduleUseCase;



================================================
FILE: src/domain/entities/Kitchen.js
================================================
class Kitchen {
  constructor({
    id,
    name,
    description,
    ownerId,
    owner_id,
    locationId,
    location_id,
    contactPhone,
    contact_phone,
    contactEmail,
    contact_email,
    imageUrl,
    image_url,
    registrationDate,
    registration_date,
    approvalStatus,
    approval_status,
    approvedBy,
    approved_by,
    approvalDate,
    approval_date,
    rejectionReason,
    rejection_reason,
    isActive,
    is_active,
    responsible = null,
    location = null
  }) {
    this.id = id;
    this.name = name;
    this.description = description;

    this.ownerId = ownerId ?? owner_id ?? 0;
    this.locationId = locationId ?? location_id ?? null;
    this.contactPhone = contactPhone ?? contact_phone ?? null;
    this.contactEmail = contactEmail ?? contact_email ?? null;
    this.imageUrl = imageUrl ?? image_url ?? null;

    this.registrationDate = registrationDate ?? registration_date ?? new Date();
    this.approvalStatus = approvalStatus ?? approval_status ?? 'pending';
    this.approvedBy = approvedBy ?? approved_by ?? null;
    this.approvalDate = approvalDate ?? approval_date ?? null;
    this.rejectionReason = rejectionReason ?? rejection_reason ?? null;
    this.isActive = isActive ?? is_active ?? false;

    this.responsible = responsible;
    this.location = location;
  }

  toJSON() {
    return {
      id: this.id,
      name: this.name,
      description: this.description,
      ownerId: this.ownerId,
      locationId: this.locationId,
      contactPhone: this.contactPhone,
      contactEmail: this.contactEmail,
      imageUrl: this.imageUrl,
      registrationDate: this.registrationDate,
      approvalStatus: this.approvalStatus,
      approvedBy: this.approvedBy,
      approvalDate: this.approvalDate,
      rejectionReason: this.rejectionReason,
      isActive: this.isActive,
      responsible: this.responsible,
      location: this.location
    };
  }
}

module.exports = Kitchen;



================================================
FILE: src/domain/entities/KitchenResponsible.js
================================================
class KitchenResponsible {
  constructor(data) {
    this.id = data.id;
    this.kitchenId = data.kitchenId ?? data.kitchen_id;
    this.names = data.names;
    this.firstLastName = data.firstLastName ?? data.first_last_name;
    this.secondLastName = data.secondLastName ?? data.second_last_name;
    this.email = data.email;
    this.phoneNumber = data.phoneNumber ?? data.phone_number;
    this.password = data.password ?? null;

    this.createdAt = data.createdAt ?? data.created_at ?? null;
  }

  toJSON() {
    return {
      id: this.id,
      kitchenId: this.kitchenId,
      names: this.names,
      firstLastName: this.firstLastName,
      secondLastName: this.secondLastName,
      email: this.email,
      phoneNumber: this.phoneNumber,
      password: this.password,
      createdAt: this.createdAt
    };
  }
}

module.exports = KitchenResponsible;


================================================
FILE: src/domain/entities/KitchenSchedule.js
================================================
class KitchenSchedule {
  constructor({
    id,
    kitchenId,
    day,
    startTime,
    endTime
  }) {
    this.id = id;
    this.kitchenId = kitchenId;
    this.day = day;
    this.startTime = startTime;
    this.endTime = endTime;

    this._validateDay();
    this._validateTime();
  }

  static fromSimplified(kitchenId, payload) {
    const result = [];

    const weekdays = ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY"];
    const weekend = ["SATURDAY", "SUNDAY"];

    if (!payload.weekdays || !payload.weekend) {
      throw new Error("Payload must include 'weekdays' and 'weekend'");
    }

    // Weekdays (same schedule)
    for (const day of weekdays) {
      result.push(
        new KitchenSchedule({
          kitchenId,
          day,
          startTime: payload.weekdays.startTime,
          endTime: payload.weekdays.endTime
        })
      );
    }

    // Weekend (same schedule)
    for (const day of weekend) {
      result.push(
        new KitchenSchedule({
          kitchenId,
          day,
          startTime: payload.weekend.startTime,
          endTime: payload.weekend.endTime
        })
      );
    }

    return result;
  }

  _validateDay() {
    const validDays = [
      "MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY",
      "SATURDAY", "SUNDAY"
    ];

    if (!validDays.includes(this.day)) {
      throw new Error(`Invalid day '${this.day}'. Must be full uppercase name.`);
    }
  }

  _validateTime() {
    const regex = /^([01]\d|2[0-3]):[0-5]\d$/;

    if (!regex.test(this.startTime) || !regex.test(this.endTime)) {
      throw new Error(`Invalid time format for day ${this.day}. Use HH:MM in 24h format.`);
    }

    if (this.startTime >= this.endTime) {
      throw new Error(`Start time must be earlier than end time for ${this.day}.`);
    }
  }
}

module.exports = KitchenSchedule;



================================================
FILE: src/domain/entities/Location.js
================================================
class Location {
  constructor({ 
    id, 
    name, 
    streetAddress, 
    neighborhood, 
    stateId, 
    municipalityId, 
    postalCode, 
    is_active 
  }) {
    this.id = id; 
    this.name = name;
    this.streetAddress = streetAddress;
    this.neighborhood = neighborhood;
    this.stateId = stateId;
    this.municipalityId = municipalityId;
    this.postalCode = postalCode;
    this.is_active = is_active ?? true;
  }

  toJSON() {
    return {
      id: this.id, 
      name: this.name,
      streetAddress: this.streetAddress,
      neighborhood: this.neighborhood,
      stateId: this.stateId,
      municipalityId: this.municipalityId,
      postalCode: this.postalCode,
      is_active: this.is_active
    };
  }
}

module.exports = Location;



================================================
FILE: src/domain/repositories/IEventPublisher.js
================================================
class IEventPublisher {
  async publish(eventName, data) {
    throw new Error('MÃ©todo "publish" no implementado');
  }
}

module.exports = IEventPublisher;



================================================
FILE: src/domain/repositories/IKitchenRepository.js
================================================
class IKitchenRepository {
  async create(kitchenData) {
    throw new Error('MÃ©todo "create" no implementado');
  }

  async update(id, kitchenData) {
    throw new Error('MÃ©todo "update" no implementado');
  }

  async findById(id) {
    throw new Error('MÃ©todo "findById" no implementado');
  }

  async findOwnerIdByKitchenId(id) {
    throw new Error('MÃ©todo "findOwnerIdByKitchenId" no implementado');
  }

  async findPending() {
    throw new Error('MÃ©todo "findPending" no implementado');
  }

  async findApproved() {
    throw new Error('MÃ©todo "findApproved" no implementado');
  }

  async findRejected() {
    throw new Error('MÃ©todo "findRejected" no implementado');
  }

  async findByLocationIds(locationIds) {
    throw new Error('MÃ©todo "findByLocationIds" no implementado');
  }
}

module.exports = IKitchenRepository;


================================================
FILE: src/domain/repositories/IKitchenScheduleRepository.js
================================================
class IKitchenScheduleRepository {
  

  async create(scheduleData) {
    throw new Error('Method "create" not implemented');
  }

  async findByKitchenId(kitchenId) {
    throw new Error('Method "findByKitchenId" not implemented');
  }

  async update(id, scheduleData) {
    throw new Error('Method "update" not implemented');
  }

  async deleteByKitchenId(kitchenId) {
    throw new Error('Method "deleteByKitchenId" not implemented');
  }
}

module.exports = IKitchenScheduleRepository;



================================================
FILE: src/domain/repositories/ILocationRepository.js
================================================
class ILocationRepository {

  async create(location) {
    throw new Error('Method not implemented');
  }

  async update(id, locationData) {
    throw new Error("Method 'update' not implemented");
  }

  async findById(id) {
    throw new Error('Method not implemented');
  }

  async findByStateAndMunicipality(stateId, municipalityId) {
    throw new Error('Method not implemented');
  }
}

module.exports = ILocationRepository;



================================================
FILE: src/infrastructure/adapters/RabbitMQPublisher.js
================================================
const amqp = require('amqplib');

class RabbitMQPublisher {
  constructor() {
    this.connection = null;
    this.channel = null;
    this.exchange = process.env.RABBITMQ_EXCHANGE || 'bim_exchange';
  }

  async connect() {
    if (this.connection) return;
    try {
      const url = process.env.RABBITMQ_URL;
      if (!url) throw new Error('âŒ RABBITMQ_URL no estÃ¡ definida en .env');

      console.log('ðŸ‡ [KITCHEN] Conectando a RabbitMQ...');
      this.connection = await amqp.connect(url);
      this.channel = await this.connection.createChannel();
      await this.channel.assertExchange(this.exchange, 'topic', { durable: true });
      console.log('âœ… [KITCHEN] Conectado a RabbitMQ correctamente');
    } catch (error) {
      console.error('âŒ [KITCHEN] Error conectando a RabbitMQ:', error);
    }
  }

  async publish(routingKey, payload) {
    try {
      if (!this.channel) await this.connect();

      const message = Buffer.from(JSON.stringify(payload));
      this.channel.publish(this.exchange, routingKey, message, { persistent: true });

      console.log(`ðŸ“¤ [KITCHEN] Evento publicado â†’ ${routingKey}`, payload);
    } catch (error) {
      console.error(`âŒ [KITCHEN] Error al publicar evento ${routingKey}:`, error);
    }
  }
}

module.exports = new RabbitMQPublisher();


================================================
FILE: src/infrastructure/api/controllers/KitchenController.js
================================================
const {
  requestKitchenUseCase,
  approveKitchenUseCase,
  rejectKitchenUseCase,
  getPendingKitchensUseCase,
  getApprovedKitchensUseCase,
  getRejectedKitchensUseCase,
  getNearbyKitchensUseCase,
  getKitchenDetailsUseCase,
  updateKitchenInfoUseCase
} = require('../dependencies/dependencies');

class KitchenController {

  async requestKitchen(req, res) {
    try {
      const result = await requestKitchenUseCase.execute(req.body);
      res.status(201).json({ success: true, data: result });
    } catch (err) {
      res.status(500).json({
        success: false,
        message: "Error al registrar cocina",
        error: err.message
      });
    }
  }

  async getPendingKitchens(_req, res) {
    try {
      const data = await getPendingKitchensUseCase.execute();
      res.status(200).json({ success: true, data });
    } catch (err) {
      res.status(500).json({ success: false, error: err.message });
    }
  }

  async getNearbyKitchens(req, res) {
    try {
      const { stateId, municipalityId } = req.user;

      const kitchens = await getNearbyKitchensUseCase.execute({
        stateId,
        municipalityId
      });

      res.status(200).json({ success: true, data: kitchens });
    } catch (err) {
      res.status(500).json({ success: false, error: err.message });
    }
  }

  async getApprovedKitchens(_req, res) {
    try {
      const data = await getApprovedKitchensUseCase.execute();
      res.status(200).json({ success: true, data });
    } catch (err) {
      res.status(500).json({ success: false, error: err.message });
    }
  }

  async getRejectedKitchens(_req, res) {
    try {
      const data = await getRejectedKitchensUseCase.execute();
      res.status(200).json({ success: true, data });
    } catch (err) {
      res.status(500).json({ success: false, error: err.message });
    }
  }

  async approveKitchen(req, res) {
    try {
      const kitchenId = req.params.id;
      const result = await approveKitchenUseCase.execute(kitchenId);

      res.status(200).json({ success: true, data: result });
    } catch (err) {
      res.status(err.http_status || 500).json({
        success: false,
        message: "Error al aprobar cocina",
        error: err.message
      });
    }
  }

  async rejectKitchen(req, res) {
    try {
      const kitchenId = req.params.id;
      const reason = req.body.reason;

      const result = await rejectKitchenUseCase.execute(kitchenId, reason);

      res.status(200).json({ success: true, data: result });
    } catch (err) {
      res.status(err.http_status || 500).json({
        success: false,
        message: "Error al rechazar cocina",
        error: err.message
      });
    }
  }

  async updateKitchen(req, res) {
    try {
      const adminUserId = req.user.id;
      const kitchenId = req.params.id;
      const updates = req.body;

      const updatedKitchen = await updateKitchenInfoUseCase.execute(
        adminUserId,
        kitchenId,
        updates
      );

      res.status(200).json({
        success: true,
        message: "Cocina actualizada correctamente",
        data: updatedKitchen
      });
    } catch (err) {
      res.status(err.http_status || 500).json({
        success: false,
        message: err.message || "Error al actualizar la cocina"
      });
    }
  }

  async getKitchenDetails(req, res) {
    try {
      const kitchenId = req.params.id;
      const data = await getKitchenDetailsUseCase.execute(kitchenId);

      res.status(200).json({ success: true, data });
    } catch (err) {
      res.status(err.http_status || 500).json({
        success: false,
        message: "Error al obtener detalles de la cocina",
        error: err.message
      });
    }
  }
}

module.exports = new KitchenController();



================================================
FILE: src/infrastructure/api/controllers/KitchenScheduleController.js
================================================
const {
  createKitchenScheduleUseCase,
  updateKitchenScheduleUseCase,
  getKitchenScheduleUseCase
} = require('../dependencies/dependencies');

class KitchenScheduleController {
  async create(req, res) {
    try {
      const kitchenId = req.params.kitchenId;

      const schedules = await createKitchenScheduleUseCase.execute(
        kitchenId,
        req.body
      );

      res.status(201).json({
        success: true,
        message: "Horarios creados correctamente",
        data: schedules
      });
    } catch (err) {
      res.status(400).json({
        success: false,
        message: err.message
      });
    }
  }

  async update(req, res) {
    try {
      const kitchenId = req.params.kitchenId;

      const schedules = await updateKitchenScheduleUseCase.execute(
        kitchenId,
        req.body
      );

      res.status(200).json({
        success: true,
        message: "Horarios actualizados correctamente",
        data: schedules
      });
    } catch (err) {
      res.status(400).json({
        success: false,
        message: err.message
      });
    }
  }

  async get(req, res) {
    try {
      const kitchenId = req.params.kitchenId;
      const schedules = await getKitchenScheduleUseCase.execute(kitchenId);

      res.status(200).json({ success: true, data: schedules });

    } catch (err) {
      res.status(400).json({ success: false, message: err.message });
    }
  }
}

module.exports = new KitchenScheduleController();


================================================
FILE: src/infrastructure/api/dependencies/dependencies.js
================================================
const SequelizeKitchenRepository = require('../../database/repositories/SequelizeKitchenRepository');
const SequelizeLocationRepository = require('../../database/repositories/SequelizeLocationRepository');
const SequelizeKitchenResponsibleRepository = require('../../database/repositories/SequelizeKitchenResponsibleRepository');
const SequelizeKitchenScheduleRepository = require('../../database/repositories/SequelizeKitchenScheduleRepository');

const RequestKitchenUseCase = require('../../../application/use-cases/RequestKitchenUseCase');
const ApproveKitchenUseCase = require('../../../application/use-cases/ApproveKitchenUseCase');
const RejectKitchenUseCase = require('../../../application/use-cases/RejectKitchenUseCase');

const GetPendingKitchensUseCase = require('../../../application/use-cases/GetPendingKitchensUseCase');
const GetApprovedKitchensUseCase = require('../../../application/use-cases/GetApprovedKitchensUseCase');
const GetRejectedKitchensUseCase = require('../../../application/use-cases/GetRejectedKitchensUseCase');

const GetNearbyKitchensUseCase = require('../../../application/use-cases/GetNearbyKitchensUseCase');
const GetKitchenDetailsUseCase = require('../../../application/use-cases/GetKitchenDetailsUseCase');

const CreateKitchenScheduleUseCase = require('../../../application/use-cases/CreateKitchenScheduleUseCase');
const UpdateKitchenScheduleUseCase = require('../../../application/use-cases/UpdateKitchenScheduleUseCase');
const GetKitchenScheduleUseCase = require('../../../application/use-cases/GetKitchenScheduleUseCase');

const RabbitMQPublisher = require('../../adapters/RabbitMQPublisher');

const kitchenRepository = new SequelizeKitchenRepository();
const locationRepository = new SequelizeLocationRepository();
const responsibleRepository = new SequelizeKitchenResponsibleRepository();
const scheduleRepository = new SequelizeKitchenScheduleRepository();

module.exports = {
  requestKitchenUseCase: new RequestKitchenUseCase(
    kitchenRepository,
    locationRepository,
    responsibleRepository,
    RabbitMQPublisher
  ),

  approveKitchenUseCase: new ApproveKitchenUseCase(
    kitchenRepository,
    responsibleRepository,
    RabbitMQPublisher
  ),

  rejectKitchenUseCase: new RejectKitchenUseCase(
    kitchenRepository,
    RabbitMQPublisher
  ),

  getPendingKitchensUseCase: new GetPendingKitchensUseCase(kitchenRepository),
  getApprovedKitchensUseCase: new GetApprovedKitchensUseCase(kitchenRepository),
  getRejectedKitchensUseCase: new GetRejectedKitchensUseCase(kitchenRepository),

  getNearbyKitchensUseCase: new GetNearbyKitchensUseCase(
    kitchenRepository,
    locationRepository
  ),

  getKitchenDetailsUseCase: new GetKitchenDetailsUseCase(
    kitchenRepository,
    locationRepository,
    responsibleRepository
  ),

  createKitchenScheduleUseCase: new CreateKitchenScheduleUseCase(scheduleRepository),
  updateKitchenScheduleUseCase: new UpdateKitchenScheduleUseCase(scheduleRepository),
  getKitchenScheduleUseCase: new GetKitchenScheduleUseCase(scheduleRepository)
};


================================================
FILE: src/infrastructure/api/routes/KitchenRoutes.js
================================================
const express = require('express');
const router = express.Router();

const requireAuth = require("../../../middleware/require-auth");
const requireRole = require("../../../middleware/require-role");
const requireKitchenOwner = require("../../../middleware/require-kitchen-owner");

const controller = require('../controllers/KitchenController');


router.post('/request', controller.requestKitchen);

router.get('/pending', requireRole("Super_admin"), controller.getPendingKitchens);
router.get('/approved', requireRole("Super_admin"), controller.getApprovedKitchens);
router.get('/rejected', requireRole("Super_admin"), controller.getRejectedKitchens);

router.get('/nearby', requireAuth, controller.getNearbyKitchens);

router.post('/:id/approve', requireRole("Super_admin"), controller.approveKitchen);
router.post('/:id/reject', requireRole("Super_admin"), controller.rejectKitchen);

router.put('/:id',requireAuth,requireRole("Admin_cocina"),requireKitchenOwner,controller.updateKitchen);

router.get('/:id', requireAuth, controller.getKitchenDetails);

module.exports = router;



================================================
FILE: src/infrastructure/api/routes/KitchenScheduleRoutes.js
================================================
const express = require('express');
const router = express.Router();

const requireAuth = require("../../../middleware/require-auth");
const requireRole = require("../../../middleware/require-role");
const requireKitchenOwner = require("../../../middleware/require-kitchen-owner");

const controller = require('../controllers/KitchenScheduleController');

router.post(
  '/:kitchenId/schedules',
  requireAuth,
  requireRole('Admin_cocina'),
  requireKitchenOwner,
  controller.create
);

router.put(
  '/:kitchenId/schedules',
  requireAuth,
  requireRole('Admin_cocina'),
  requireKitchenOwner,
  controller.update
);

router.get(
  '/:kitchenId/schedules',
  requireAuth,
  controller.get
);

module.exports = router;


================================================
FILE: src/infrastructure/database/config/database.js
================================================
require('dotenv').config();
const { Sequelize } = require('sequelize');

const sequelize = new Sequelize(
  process.env.DB_DATABASE,      
  process.env.DB_USERNAME,
  process.env.DB_PASSWORD,
  {
    host: process.env.DB_HOST,  
    port: process.env.DB_PORT,
    dialect: 'postgres',
    logging: false,
    dialectOptions: {
      ssl: {
        require: true,
        rejectUnauthorized: false 
      }
    }
  }
);

module.exports = sequelize;



================================================
FILE: src/infrastructure/database/models/KitchenModel.js
================================================
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database'); 

const Location = require('./LocationModel');
const KitchenSchedule = require('./KitchenScheduleModel'); // â† NUEVO

const Kitchen = sequelize.define(
  'Kitchen',
  {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    name: { type: DataTypes.STRING, allowNull: false },
    description: { type: DataTypes.TEXT, allowNull: false },
    owner_id: { type: DataTypes.INTEGER, allowNull: false },

    location_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: { model: 'locations', key: 'id' },
    },

    contact_phone: { type: DataTypes.STRING, allowNull: false },
    contact_email: { type: DataTypes.STRING, allowNull: false },
    image_url: { type: DataTypes.STRING },
    registration_date: { type: DataTypes.DATE, defaultValue: DataTypes.NOW },

    approval_status: {
      type: DataTypes.ENUM('pending', 'approved', 'rejected'),
      defaultValue: 'pending'
    },

    approved_by: { type: DataTypes.INTEGER },
    approval_date: { type: DataTypes.DATE },
    rejection_reason: { type: DataTypes.TEXT },
    is_active: { type: DataTypes.BOOLEAN, defaultValue: false }
  },
  {
    tableName: 'kitchens',
    timestamps: false,
  }
);

Kitchen.belongsTo(Location, { foreignKey: 'location_id', as: 'location' });
Location.hasMany(Kitchen, { foreignKey: 'location_id', as: 'kitchens' });

Kitchen.hasOne(KitchenSchedule, {
  foreignKey: 'kitchen_id',
  as: 'schedule'
});

KitchenSchedule.belongsTo(Kitchen, {
  foreignKey: 'kitchen_id',
  as: 'kitchen'
});

module.exports = Kitchen;



================================================
FILE: src/infrastructure/database/models/KitchenResponsibleModel.js
================================================
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');
const Kitchen = require('./KitchenModel');

const KitchenResponsible = sequelize.define(
  'KitchenResponsible',
  {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },

    kitchen_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: { model: 'kitchens', key: 'id' }
    },
    names: { type: DataTypes.STRING, allowNull: false },
    first_last_name: { type: DataTypes.STRING, allowNull: false },
    second_last_name: { type: DataTypes.STRING },
    email: { type: DataTypes.STRING, allowNull: false },
    phone_number: { type: DataTypes.STRING, allowNull: false },
    created_at: { type: DataTypes.DATE, defaultValue: DataTypes.NOW }
  },
  { tableName: "kitchen_responsibles", timestamps: false }
);

Kitchen.hasOne(KitchenResponsible, { foreignKey: 'kitchen_id', as: 'responsible' });
KitchenResponsible.belongsTo(Kitchen, { foreignKey: 'kitchen_id', as: 'kitchen' });

module.exports = KitchenResponsible;



================================================
FILE: src/infrastructure/database/models/KitchenScheduleModel.js
================================================
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const KitchenScheduleModel = sequelize.define(
  'KitchenSchedule',
  {
    id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },

    kitchen_id: {
      type: DataTypes.INTEGER,
      allowNull: false,
    },

    open_time_weekdays: {
      type: DataTypes.TIME,
      allowNull: false,
    },
    close_time_weekdays: {
      type: DataTypes.TIME,
      allowNull: false,
    },

    open_time_weekends: {
      type: DataTypes.TIME,
      allowNull: false,
    },
    close_time_weekends: {
      type: DataTypes.TIME,
      allowNull: false,
    },

    is_active: {
      type: DataTypes.BOOLEAN,
      defaultValue: true,
    }
  },
  { tableName: 'kitchen_schedules', timestamps: false }
);

module.exports = KitchenScheduleModel;



================================================
FILE: src/infrastructure/database/models/LocationModel.js
================================================
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const Location = sequelize.define(
  'Location',
  {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },
    name: { type: DataTypes.STRING, allowNull: false },
    street_address: { type: DataTypes.STRING, allowNull: false },
    neighborhood: { type: DataTypes.STRING, allowNull: false },
    state_id: { type: DataTypes.INTEGER, allowNull: false },
    municipality_id: { type: DataTypes.INTEGER, allowNull: false },
    postal_code: { type: DataTypes.STRING, allowNull: false },
    is_active: { type: DataTypes.BOOLEAN, defaultValue: true }
  },
  {
    tableName: 'locations',
    timestamps: false,
  }
);


module.exports = Location;



================================================
FILE: src/infrastructure/database/repositories/SequelizeKitchenRepository.js
================================================
const KitchenModel = require('../models/KitchenModel');
const KitchenResponsibleModel = require('../models/KitchenResponsibleModel');
const LocationModel = require('../models/LocationModel');

const Kitchen = require('../../../domain/entities/Kitchen');

class SequelizeKitchenRepository {

  _toDomain(model) {
    if (!model) return null;

    const json = model.toJSON();

    return new Kitchen({
      ...json,
      responsible: json.responsible || null,
      location: json.location || null
    });
  }

  async create(data) {
    const newKitchen = await KitchenModel.create({
      name: data.name,
      description: data.description,
      owner_id: data.owner_id ?? 0,
      location_id: data.location_id,

      // ðŸ‘‡ CORRECCIÃ“N CRÃTICA (mapeo correcto)
      contact_phone: data.contactPhone ?? data.contact_phone,
      contact_email: data.contactEmail ?? data.contact_email,

      image_url: data.imageUrl ?? data.image_url ?? null,
      approval_status: 'pending',
      is_active: false
    });

    return this._toDomain(newKitchen);
  }

  async findById(id) {
    const result = await KitchenModel.findOne({
      where: { id },
      include: [
        { model: KitchenResponsibleModel, as: 'responsible' },
        { model: LocationModel, as: 'location' }
      ]
    });

    return this._toDomain(result);
  }

  async update(id, data) {
    await KitchenModel.update(data, { where: { id } });
    return this.findById(id);
  }

  async findPending() {
    const result = await KitchenModel.findAll({
      where: { approval_status: 'pending' },
      include: [
        { model: KitchenResponsibleModel, as: 'responsible' },
        { model: LocationModel, as: 'location' }
      ]
    });

    return result.map(r => this._toDomain(r));
  }

  async findApproved() {
    const result = await KitchenModel.findAll({
      where: { approval_status: 'approved' },
      include: [
        { model: KitchenResponsibleModel, as: 'responsible' },
        { model: LocationModel, as: 'location' }
      ]
    });

    return result.map(r => this._toDomain(r));
  }

  async findRejected() {
    const result = await KitchenModel.findAll({
      where: { approval_status: 'rejected' },
      include: [
        { model: KitchenResponsibleModel, as: 'responsible' },
        { model: LocationModel, as: 'location' }
      ]
    });

    return result.map(r => this._toDomain(r));
  }
}

module.exports = SequelizeKitchenRepository;



================================================
FILE: src/infrastructure/database/repositories/SequelizeKitchenResponsibleRepository.js
================================================
const KitchenResponsibleModel = require('../models/KitchenResponsibleModel');
const KitchenResponsible = require('../../../domain/entities/KitchenResponsible');

class SequelizeKitchenResponsibleRepository {
  _toDomain(model) {
    if (!model) return null;
    return new KitchenResponsible(model.toJSON());
  }

  async create(data) {
    const created = await KitchenResponsibleModel.create({
      kitchen_id: data.kitchen_id,
      names: data.names,
      first_last_name: data.first_last_name,
      second_last_name: data.second_last_name || null,
      email: data.email,
      phone_number: data.phone_number
    });

    return new KitchenResponsible({
      ...created.toJSON(),
      password: data.password
    });
  }

  async findByKitchenId(kitchenId) {
    const model = await KitchenResponsibleModel.findOne({
      where: { kitchen_id: kitchenId }
    });
    return this._toDomain(model);
  }
}

module.exports = SequelizeKitchenResponsibleRepository;


================================================
FILE: src/infrastructure/database/repositories/SequelizeKitchenScheduleRepository.js
================================================
const KitchenScheduleModel = require('../models/KitchenScheduleModel');
const KitchenSchedule = require('../../../domain/entities/KitchenSchedule');

class SequelizeKitchenScheduleRepository {
  _toDomain(model) {
    if (!model) return null;
    return new KitchenSchedule(model.toJSON());
  }

  async create(schedule) {
    const newRow = await KitchenScheduleModel.create({
      kitchen_id: schedule.kitchenId,
      day: schedule.day,
      start_time: schedule.startTime,
      end_time: schedule.endTime
    });

    return this._toDomain(newRow);
  }

  async findByKitchenId(kitchenId) {
    const rows = await KitchenScheduleModel.findAll({
      where: { kitchen_id: kitchenId }
    });

    return rows.map(r => this._toDomain(r));
  }

  async deleteByKitchenId(kitchenId) {
    await KitchenScheduleModel.destroy({
      where: { kitchen_id: kitchenId }
    });
  }
}

module.exports = SequelizeKitchenScheduleRepository;



================================================
FILE: src/infrastructure/database/repositories/SequelizeLocationRepository.js
================================================
const LocationModel = require('../models/LocationModel');
const Location = require('../../../domain/entities/Location');

class SequelizeLocationRepository {

  _toDomain(model) {
    if (!model) return null;
    return new Location(model.toJSON());
  }

  async create(locationData) {
    console.log("ðŸ“ Datos recibidos en create(Location):", locationData);

    const newLocation = await LocationModel.create({
      name: locationData.name || locationData.neighborhood || 'UbicaciÃ³n sin nombre',
      street_address: locationData.streetAddress,
      neighborhood: locationData.neighborhood,
      state_id: locationData.stateId,
      municipality_id: locationData.municipalityId,
      postal_code: locationData.postalCode,
      is_active: true
    });

    return this._toDomain(newLocation);
  }

  async findById(id) {
    const record = await LocationModel.findByPk(id);
    return this._toDomain(record);
  }

  async findByStateAndMunicipality(stateId, municipalityId) {
    const results = await LocationModel.findAll({
      where: {
        state_id: stateId,
        municipality_id: municipalityId,
        is_active: true
      }
    });

    return results.map(r => this._toDomain(r));
  }
}

module.exports = SequelizeLocationRepository;


================================================
FILE: src/infrastructure/store/temp-password.store.js
================================================
const tempPasswords = {};

module.exports = {
  saveTemporaryPassword(kitchenId, password) {
    tempPasswords[kitchenId] = password;
  },

  getTemporaryPassword(kitchenId) {
    return tempPasswords[kitchenId];
  },

  clearTemporaryPassword(kitchenId) {
    delete tempPasswords[kitchenId];
  }
};



================================================
FILE: src/middleware/require-auth.js
================================================
const jwt = require("jsonwebtoken");

module.exports = function requireAuth(req, res, next) {
  const header = req.headers.authorization;

  if (!header) {
    return res.status(401).json({
      success: false,
      message: "Missing Authorization header"
    });
  }

  const token = header.replace("Bearer ", "");

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    req.user = {
      id: decoded.userId,
      email: decoded.email,
      roles: decoded.roles || [],
      stateId: decoded.stateId ?? null,
      municipalityId: decoded.municipalityId ?? null
    };

    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      message: "Invalid token",
      error: error.message
    });
  }
};



================================================
FILE: src/middleware/require-kitchen-owner.js
================================================
const SequelizeKitchenRepository = require("../infrastructure/database/repositories/SequelizeKitchenRepository");
const kitchenRepository = new SequelizeKitchenRepository();

module.exports = async function requireKitchenOwner(req, res, next) {
  try {
    const userId = req.user.id;
    const kitchenId = req.params.id;

    const kitchen = await kitchenRepository.findById(kitchenId);

    if (!kitchen) {
      return res.status(404).json({
        success: false,
        message: "Kitchen not found"
      });
    }

    if (kitchen.ownerId !== userId) {
      return res.status(403).json({
        success: false,
        message: "Forbidden: This kitchen does not belong to you"
      });
    }

    next();
  } catch (error) {
    console.error("Error in requireKitchenOwner:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error"
    });
  }
};



================================================
FILE: src/middleware/require-role.js
================================================
const jwt = require("jsonwebtoken");

module.exports = function requireRole(requiredRole) {
  return (req, res, next) => {
    const header = req.headers.authorization;

    if (!header) {
      return res.status(401).json({
        success: false,
        message: "Missing Authorization header"
      });
    }

    const token = header.replace("Bearer ", "");

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      const roles = decoded.roles || [];

      if (!roles.includes(requiredRole)) {
        return res.status(403).json({
          success: false,
          message: "Forbidden: You don't have permission",
          requiredRole,
          userRoles: roles
        });
      }

      req.user = {
        id: decoded.userId,
        email: decoded.email,
        roles,
        stateId: decoded.stateId ?? null,
        municipalityId: decoded.municipalityId ?? null
      };

      next();

    } catch (error) {
      return res.status(401).json({
        success: false,
        message: "Invalid token",
        error: error.message
      });
    }
  };
};