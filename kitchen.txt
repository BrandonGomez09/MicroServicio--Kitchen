Directory structure:
â””â”€â”€ didiercito-microservicio--kitchen/
    â”œâ”€â”€ package.json
    â””â”€â”€ src/
        â”œâ”€â”€ app.js
        â”œâ”€â”€ server.js
        â”œâ”€â”€ application/
        â”‚   â””â”€â”€ use-cases/
        â”‚       â”œâ”€â”€ ApproveKitchenUseCase.js
        â”‚       â”œâ”€â”€ CreateKitchenScheduleUseCase.js
        â”‚       â”œâ”€â”€ GetApprovedKitchensUseCase.js
        â”‚       â”œâ”€â”€ GetKitchenDetailsUseCase.js
        â”‚       â”œâ”€â”€ GetKitchenScheduleUseCase.js
        â”‚       â”œâ”€â”€ GetNearbyKitchensUseCase.js
        â”‚       â”œâ”€â”€ GetPendingKitchensUseCase.js
        â”‚       â”œâ”€â”€ GetRejectedKitchensUseCase.js
        â”‚       â”œâ”€â”€ RejectKitchenUseCase.js
        â”‚       â”œâ”€â”€ RequestKitchenUseCase.js
        â”‚       â”œâ”€â”€ RequestLocationUseCase.js
        â”‚       â”œâ”€â”€ UpdateKitchenInfoUseCase.js
        â”‚       â””â”€â”€ UpdateKitchenScheduleUseCase.js
        â”œâ”€â”€ domain/
        â”‚   â”œâ”€â”€ entities/
        â”‚   â”‚   â”œâ”€â”€ Kitchen.js
        â”‚   â”‚   â”œâ”€â”€ KitchenResponsible.js
        â”‚   â”‚   â”œâ”€â”€ KitchenSchedule.js
        â”‚   â”‚   â””â”€â”€ Location.js
        â”‚   â””â”€â”€ repositories/
        â”‚       â”œâ”€â”€ IEventPublisher.js
        â”‚       â”œâ”€â”€ IKitchenRepository.js
        â”‚       â”œâ”€â”€ IKitchenScheduleRepository.js
        â”‚       â””â”€â”€ ILocationRepository.js
        â”œâ”€â”€ infrastructure/
        â”‚   â”œâ”€â”€ adapters/
        â”‚   â”‚   â””â”€â”€ RabbitMQPublisher.js
        â”‚   â”œâ”€â”€ api/
        â”‚   â”‚   â”œâ”€â”€ controllers/
        â”‚   â”‚   â”‚   â”œâ”€â”€ KitchenController.js
        â”‚   â”‚   â”‚   â””â”€â”€ KitchenScheduleController.js
        â”‚   â”‚   â”œâ”€â”€ dependencies/
        â”‚   â”‚   â”‚   â””â”€â”€ dependencies.js
        â”‚   â”‚   â””â”€â”€ routes/
        â”‚   â”‚       â”œâ”€â”€ KitchenRoutes.js
        â”‚   â”‚       â””â”€â”€ KitchenScheduleRoutes.js
        â”‚   â”œâ”€â”€ database/
        â”‚   â”‚   â”œâ”€â”€ config/
        â”‚   â”‚   â”‚   â””â”€â”€ database.js
        â”‚   â”‚   â”œâ”€â”€ models/
        â”‚   â”‚   â”‚   â”œâ”€â”€ KitchenModel.js
        â”‚   â”‚   â”‚   â”œâ”€â”€ KitchenResponsibleModel.js
        â”‚   â”‚   â”‚   â”œâ”€â”€ KitchenScheduleModel.js
        â”‚   â”‚   â”‚   â””â”€â”€ LocationModel.js
        â”‚   â”‚   â””â”€â”€ repositories/
        â”‚   â”‚       â”œâ”€â”€ SequelizeKitchenRepository.js
        â”‚   â”‚       â”œâ”€â”€ SequelizeKitchenResponsibleRepository.js
        â”‚   â”‚       â”œâ”€â”€ SequelizeKitchenScheduleRepository.js
        â”‚   â”‚       â””â”€â”€ SequelizeLocationRepository.js
        â”‚   â””â”€â”€ store/
        â”‚       â””â”€â”€ temp-password.store.js
        â””â”€â”€ middleware/
            â”œâ”€â”€ require-auth.js
            â”œâ”€â”€ require-kitchen-owner.js
            â””â”€â”€ require-role.js
================================================
FILE: package.json
================================================
{
  "name": "kitchens-service",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "start": "node src/server.js",
    "dev": "nodemon src/server.js"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "amqplib": "^0.10.9",
    "axios": "^1.13.2",
    "bcrypt": "^6.0.0",
    "cors": "^2.8.5",
    "dotenv": "^17.2.3",
    "express": "^5.1.0",
    "helmet": "^8.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.1",
    "pg": "^8.16.3",
    "pg-hstore": "^2.3.4",
    "sequelize": "^6.37.7"
  },
  "devDependencies": {
    "nodemon": "^3.1.10"
  }
}



================================================
FILE: src/app.js
================================================
const express = require('express');
const cors = require('cors');
const kitchenRoutes = require('./infrastructure/api/routes/KitchenRoutes');

const app = express();
app.use(cors({ origin: '*' }));

app.use(express.json());
app.use(express.urlencoded({ extended: true }));

app.use('/api/v1/kitchens', kitchenRoutes);

app.get('/', (_req, res) => {
  res.send('API de Cocinas Comunitarias funcionando');
});

module.exports = app;



================================================
FILE: src/server.js
================================================
require('dotenv').config();
const app = require('./app');
const sequelize = require('./infrastructure/database/config/database');
const publisher = require('./infrastructure/adapters/RabbitMQPublisher');
require('./infrastructure/database/models/LocationModel');
require('./infrastructure/database/models/KitchenModel');


const PORT = process.env.PORT;

async function startServer() {
  try {
    console.log('ðŸš€ Iniciando Kitchen Service...');

    await sequelize.authenticate();
    console.log('âœ… ConexiÃ³n a la base de datos (PostgreSQL) establecida.');

    if (process.env.NODE_ENV === 'development') {
      await sequelize.sync({ alter: true });
      console.log('ðŸ”„ Tablas sincronizadas automÃ¡ticamente con { alter: true }');
    } else {
      await sequelize.sync();
      console.log('âœ… Tablas verificadas (sin alteraciones)');
    }

    await publisher.connect();
    console.log('ðŸ‡ RabbitMQ conectado correctamente (Publisher listo).');

    app.listen(PORT, () => {
      console.log(`ðŸŒ Servidor corriendo en el puerto ${PORT}`);
    });

  } catch (error) {
    console.error('âŒ Error al iniciar el servidor:', error);
    process.exit(1);
  }
}

startServer();



================================================
FILE: src/application/use-cases/ApproveKitchenUseCase.js
================================================
const {
  getTemporaryPassword,
  clearTemporaryPassword
} = require("../../infrastructure/store/temp-password.store");

class ApproveKitchenUseCase {
  constructor(kitchenRepository, responsibleRepository, eventPublisher) {
    this.kitchenRepository = kitchenRepository;
    this.responsibleRepository = responsibleRepository;
    this.eventPublisher = eventPublisher;
  }

  async execute(kitchenId) {
    const kitchen = await this.kitchenRepository.findById(kitchenId);
    if (!kitchen) throw { http_status: 404, message: "Kitchen not found" };

    const responsible = await this.responsibleRepository.findByKitchenId(kitchenId);

    const password = getTemporaryPassword(kitchenId);
    if (!password) {
      throw { http_status: 500, message: "Missing password for responsible user" };
    }

    await this.kitchenRepository.update(kitchenId, {
      approvalStatus: "approved",
      isActive: true
    });

    await this.eventPublisher.publish("kitchen.admin.registered", {
      kitchenId,
      names: responsible.names,
      firstLastName: responsible.firstLastName,
      secondLastName: responsible.secondLastName,
      email: responsible.email,
      phoneNumber: responsible.phoneNumber,
      password
    });

    clearTemporaryPassword(kitchenId);

    return kitchen;
  }
}

module.exports = ApproveKitchenUseCase;


================================================
FILE: src/application/use-cases/CreateKitchenScheduleUseCase.js
================================================
const KitchenSchedule = require('../../domain/entities/KitchenSchedule');

class CreateKitchenScheduleUseCase {
  constructor(scheduleRepository) {
    this.scheduleRepository = scheduleRepository;
  }

  async execute(kitchenId, payload) {
    await this.scheduleRepository.deleteByKitchenId(kitchenId);

    const schedules = KitchenSchedule.fromSimplified(kitchenId, payload);

    for (const schedule of schedules) {
      await this.scheduleRepository.create(schedule);
    }

    return schedules;
  }
}

module.exports = CreateKitchenScheduleUseCase;



================================================
FILE: src/application/use-cases/GetApprovedKitchensUseCase.js
================================================
class GetApprovedKitchensUseCase {
  constructor(kitchenRepository) {
    this.kitchenRepository = kitchenRepository;
  }

  async execute() {
    return await this.kitchenRepository.findByStatus("approved");
  }
}

module.exports = GetApprovedKitchensUseCase;


================================================
FILE: src/application/use-cases/GetKitchenDetailsUseCase.js
================================================
class GetKitchenDetailsUseCase {
  constructor(kitchenRepository, locationRepository) {
    this.kitchenRepository = kitchenRepository;
    this.locationRepository = locationRepository;
  }

  async execute(kitchenId) {
    const kitchen = await this.kitchenRepository.findById(kitchenId);
    if (!kitchen) throw new Error("Kitchen not found");

    const location = kitchen.locationId
      ? await this.locationRepository.findById(kitchen.locationId)
      : null;

    return { kitchen, location };
  }
}

module.exports = GetKitchenDetailsUseCase;


================================================
FILE: src/application/use-cases/GetKitchenScheduleUseCase.js
================================================
class GetKitchenScheduleUseCase {
  constructor(scheduleRepository) {
    this.scheduleRepository = scheduleRepository;
  }

  async execute(kitchenId) {
    return this.scheduleRepository.findByKitchenId(kitchenId);
  }
}

module.exports = GetKitchenScheduleUseCase;



================================================
FILE: src/application/use-cases/GetNearbyKitchensUseCase.js
================================================
class GetNearbyKitchensUseCase {
  constructor(kitchenRepository, locationRepository) {
    this.kitchenRepository = kitchenRepository;
    this.locationRepository = locationRepository;
  }

  async execute({ stateId, municipalityId }) {
    const locations = await this.locationRepository.findByStateAndMunicipality(
      stateId,
      municipalityId
    );

    const ids = locations.map(l => l.id);

    return await this.kitchenRepository.findByLocationIds(ids);
  }
}

module.exports = GetNearbyKitchensUseCase;


================================================
FILE: src/application/use-cases/GetPendingKitchensUseCase.js
================================================
class GetPendingKitchensUseCase {
  constructor(kitchenRepository) {
    this.kitchenRepository = kitchenRepository;
  }

  async execute() {
    const kitchens = await this.kitchenRepository.findPending();
    return kitchens;
  }
}

module.exports = GetPendingKitchensUseCase;


================================================
FILE: src/application/use-cases/GetRejectedKitchensUseCase.js
================================================
class GetRejectedKitchensUseCase {
  constructor(kitchenRepository) {
    this.kitchenRepository = kitchenRepository;
  }

  async execute() {
    return await this.kitchenRepository.findByStatus("rejected");
  }
}

module.exports = GetRejectedKitchensUseCase;


================================================
FILE: src/application/use-cases/RejectKitchenUseCase.js
================================================
class RejectKitchenUseCase {
  constructor(kitchenRepository, eventPublisher) {
    this.kitchenRepository = kitchenRepository;
    this.eventPublisher = eventPublisher;
  }

  async execute(kitchenId, reason, adminUserId) {
    const kitchen = await this.kitchenRepository.findById(kitchenId);
    if (!kitchen) throw new Error("Kitchen not found");

    const updatedKitchen = await this.kitchenRepository.update(kitchenId, {
      approvalStatus: "rejected",
      rejectionReason: reason,
      isActive: false,
      approvedBy: null,
      approvalDate: null
    });

    await this.eventPublisher.publish("kitchen.rejected", {
      kitchenId: updatedKitchen.id,
      ownerId: updatedKitchen.ownerId,
      kitchenName: updatedKitchen.name,
      rejectionReason: reason,
      rejectedBy: adminUserId,
      timestamp: new Date().toISOString()
    });

    return updatedKitchen;
  }
}

module.exports = RejectKitchenUseCase;


================================================
FILE: src/application/use-cases/RequestKitchenUseCase.js
================================================
const { saveTemporaryPassword } = require("../../infrastructure/store/temp-password.store");

class RequestKitchenUseCase {
  constructor(kitchenRepository, locationRepository, responsibleRepository) {
    this.kitchenRepository = kitchenRepository;
    this.locationRepository = locationRepository;
    this.responsibleRepository = responsibleRepository;
  }

  async execute(dto) {
    const { responsible, kitchen, location } = dto;

    if (!responsible.password) {
      throw { http_status: 400, message: "Password is required" };
    }

    const createdLocation = await this.locationRepository.create(location);

    const createdKitchen = await this.kitchenRepository.create({
      ...kitchen,
      ownerId: 0,
      locationId: createdLocation.id
    });

    await this.responsibleRepository.create({
      kitchenId: createdKitchen.id,
      names: responsible.names,
      firstLastName: responsible.firstLastName,
      secondLastName: responsible.secondLastName,
      email: responsible.email,
      phoneNumber: responsible.phoneNumber
    });

    saveTemporaryPassword(createdKitchen.id, responsible.password);

    return createdKitchen;
  }
}

module.exports = RequestKitchenUseCase;


================================================
FILE: src/application/use-cases/RequestLocationUseCase.js
================================================
const Location = require('../../domain/entities/Location');

class RequestLocationUseCase {
  constructor(locationRepository) {
    this.locationRepository = locationRepository;
  }

  async execute(data) {
    const location = new Location({
      name: data.neighborhood || data.name || 'UbicaciÃ³n',
      streetAddress: data.streetAddress,
      neighborhood: data.neighborhood,
      stateId: data.stateId,
      municipalityId: data.municipalityId,
      postalCode: data.postalCode,
      is_active: true
    });

    const newLocation = await this.locationRepository.create(location);
    return newLocation;
  }
}

module.exports = RequestLocationUseCase;


================================================
FILE: src/application/use-cases/UpdateKitchenInfoUseCase.js
================================================
class UpdateKitchenInfoUseCase {
  constructor(kitchenRepository, locationRepository) {
    this.kitchenRepository = kitchenRepository;
    this.locationRepository = locationRepository;
  }

  async execute(adminUserId, kitchenId, data) {
    const {
      name,
      description,
      contactPhone,
      contactEmail,
      imageUrl,
      location: {
        streetAddress,
        neighborhood,
        postalCode,
        stateId,
        municipalityId
      }
    } = data;

    const kitchen = await this.kitchenRepository.findById(kitchenId);
    if (!kitchen) throw { http_status: 404, message: "Kitchen not found" };

    const ownerId = await this.kitchenRepository.findOwnerIdByKitchenId(kitchenId);
    if (ownerId !== adminUserId) {
      throw { http_status: 403, message: "Not your kitchen" };
    }

    await this.locationRepository.update(kitchen.locationId, {
      streetAddress,
      neighborhood,
      postalCode,
      stateId,
      municipalityId
    });

    const updatedKitchen = await this.kitchenRepository.update(kitchenId, {
      name,
      description,
      contactPhone,
      contactEmail,
      imageUrl
    });

    return updatedKitchen;
  }
}

module.exports = UpdateKitchenInfoUseCase;


================================================
FILE: src/application/use-cases/UpdateKitchenScheduleUseCase.js
================================================
const KitchenSchedule = require('../../domain/entities/KitchenSchedule');

class UpdateKitchenScheduleUseCase {
  constructor(scheduleRepository) {
    this.scheduleRepository = scheduleRepository;
  }

  async execute(kitchenId, payload) {
    await this.scheduleRepository.deleteByKitchenId(kitchenId);

    const schedules = KitchenSchedule.fromSimplified(kitchenId, payload);

    for (const schedule of schedules) {
      await this.scheduleRepository.create(schedule);
    }

    return schedules;
  }
}

module.exports = UpdateKitchenScheduleUseCase;



================================================
FILE: src/domain/entities/Kitchen.js
================================================
class Kitchen {
  constructor({
    id,
    name,
    description,
    ownerId,
    locationId,
    contactPhone,
    contactEmail,
    imageUrl,
    registrationDate,
    approvalStatus,
    approvedBy,
    approvalDate,
    rejectionReason,
    isActive,
    responsible = null,
    location = null
  }) {
    this.id = id;
    this.name = name;
    this.description = description;
    this.ownerId = ownerId ?? 0;
    this.locationId = locationId ?? null;
    this.contactPhone = contactPhone ?? null;
    this.contactEmail = contactEmail ?? null;
    this.imageUrl = imageUrl ?? null;
    this.registrationDate = registrationDate ?? new Date();
    this.approvalStatus = approvalStatus ?? "pending";
    this.approvedBy = approvedBy ?? null;
    this.approvalDate = approvalDate ?? null;
    this.rejectionReason = rejectionReason ?? null;
    this.isActive = isActive ?? false;

    this.responsible = responsible;
    this.location = location;
  }

  toJSON() {
    return {
      id: this.id,
      name: this.name,
      description: this.description,
      ownerId: this.ownerId,
      locationId: this.locationId,
      contactPhone: this.contactPhone,
      contactEmail: this.contactEmail,
      imageUrl: this.imageUrl,
      registrationDate: this.registrationDate,
      approvalStatus: this.approvalStatus,
      approvedBy: this.approvedBy,
      approvalDate: this.approvalDate,
      rejectionReason: this.rejectionReason,
      isActive: this.isActive,
      responsible: this.responsible,
      location: this.location
    };
  }
}

module.exports = Kitchen;


================================================
FILE: src/domain/entities/KitchenResponsible.js
================================================
class KitchenResponsible {
  constructor({
    id,
    kitchenId,
    names,
    firstLastName,
    secondLastName,
    email,
    phoneNumber,
    createdAt,
    password 
  }) {
    this.id = id;
    this.kitchenId = kitchenId;
    this.names = names;
    this.firstLastName = firstLastName;
    this.secondLastName = secondLastName;
    this.email = email;
    this.phoneNumber = phoneNumber;
    this.createdAt = createdAt ?? new Date();
    this.password = password ?? null;
  }

  toJSON() {
    return {
      id: this.id,
      kitchenId: this.kitchenId,
      names: this.names,
      firstLastName: this.firstLastName,
      secondLastName: this.secondLastName,
      email: this.email,
      phoneNumber: this.phoneNumber,
      createdAt: this.createdAt,
      password: this.password 
    };
  }
}

module.exports = KitchenResponsible;



================================================
FILE: src/domain/entities/KitchenSchedule.js
================================================
class KitchenSchedule {
  constructor({
    id,
    kitchenId,
    day,
    startTime,
    endTime
  }) {
    this.id = id;
    this.kitchenId = kitchenId;
    this.day = day;
    this.startTime = startTime;
    this.endTime = endTime;

    this._validateDay();
    this._validateTime();
  }

  static fromSimplified(kitchenId, payload) {
    const result = [];

    const weekdays = ["MONDAY", "TUESDAY", "WEDNESDAY", "THURSDAY", "FRIDAY"];
    const weekend = ["SATURDAY", "SUNDAY"];

    if (!payload.weekdays || !payload.weekend) {
      throw new Error("Payload must include 'weekdays' and 'weekend'");
    }

    for (const day of weekdays) {
      result.push(
        new KitchenSchedule({
          kitchenId,
          day,
          startTime: payload.weekdays.startTime,
          endTime: payload.weekdays.endTime
        })
      );
    }

    for (const day of weekend) {
      result.push(
        new KitchenSchedule({
          kitchenId,
          day,
          startTime: payload.weekend.startTime,
          endTime: payload.weekend.endTime
        })
      );
    }

    return result;
  }

  _validateDay() {
    const validDays = [
      "MONDAY", "TUESDAY", "WEDNESDAY",
      "THURSDAY", "FRIDAY", "SATURDAY", "SUNDAY"
    ];

    if (!validDays.includes(this.day)) {
      throw new Error(`Invalid day '${this.day}'. Must be uppercase FULL name.`);
    }
  }

  _validateTime() {
    const regex = /^([01]\d|2[0-3]):[0-5]\d$/;

    if (!regex.test(this.startTime) || !regex.test(this.endTime)) {
      throw new Error(`Invalid time format for day ${this.day}. Use HH:MM 24h format.`);
    }

    if (this.startTime >= this.endTime) {
      throw new Error(`Start time must be earlier than end time for ${this.day}.`);
    }
  }
}

module.exports = KitchenSchedule;


================================================
FILE: src/domain/entities/Location.js
================================================
class Location {
  constructor({
    id,
    name,
    streetAddress,
    neighborhood,
    stateId,
    municipalityId,
    postalCode,
    isActive
  }) {
    this.id = id;
    this.name = name || neighborhood || "UbicaciÃ³n sin nombre";
    this.streetAddress = streetAddress;
    this.neighborhood = neighborhood;
    this.stateId = stateId;
    this.municipalityId = municipalityId;
    this.postalCode = postalCode;
    this.isActive = isActive ?? true;
  }

  toJSON() {
    return {
      id: this.id,
      name: this.name,
      streetAddress: this.streetAddress,
      neighborhood: this.neighborhood,
      stateId: this.stateId,
      municipalityId: this.municipalityId,
      postalCode: this.postalCode,
      isActive: this.isActive
    };
  }
}

module.exports = Location;


================================================
FILE: src/domain/repositories/IEventPublisher.js
================================================
class IEventPublisher {
  async publish(eventName, data) {
    throw new Error('MÃ©todo "publish" no implementado');
  }
}

module.exports = IEventPublisher;



================================================
FILE: src/domain/repositories/IKitchenRepository.js
================================================
class IKitchenRepository {
  async create(kitchenData) {
    throw new Error('MÃ©todo "create" no implementado');
  }

  async update(id, kitchenData) {
    throw new Error('MÃ©todo "update" no implementado');
  }

  async findById(id) {
    throw new Error('MÃ©todo "findById" no implementado');
  }

  async findOwnerIdByKitchenId(id) {
    throw new Error('MÃ©todo "findOwnerIdByKitchenId" no implementado');
  }

  async findPending() {
    throw new Error('MÃ©todo "findPending" no implementado');
  }

  async findApproved() {
    throw new Error('MÃ©todo "findApproved" no implementado');
  }

  async findRejected() {
    throw new Error('MÃ©todo "findRejected" no implementado');
  }

  async findByLocationIds(locationIds) {
    throw new Error('MÃ©todo "findByLocationIds" no implementado');
  }
}

module.exports = IKitchenRepository;


================================================
FILE: src/domain/repositories/IKitchenScheduleRepository.js
================================================
class IKitchenScheduleRepository {
  

  async create(scheduleData) {
    throw new Error('Method "create" not implemented');
  }

  async findByKitchenId(kitchenId) {
    throw new Error('Method "findByKitchenId" not implemented');
  }

  async update(id, scheduleData) {
    throw new Error('Method "update" not implemented');
  }

  async deleteByKitchenId(kitchenId) {
    throw new Error('Method "deleteByKitchenId" not implemented');
  }
}

module.exports = IKitchenScheduleRepository;



================================================
FILE: src/domain/repositories/ILocationRepository.js
================================================
class ILocationRepository {

  async create(location) {
    throw new Error('Method not implemented');
  }

  async update(id, locationData) {
    throw new Error("Method 'update' not implemented");
  }

  async findById(id) {
    throw new Error('Method not implemented');
  }

  async findByStateAndMunicipality(stateId, municipalityId) {
    throw new Error('Method not implemented');
  }
}

module.exports = ILocationRepository;



================================================
FILE: src/infrastructure/adapters/RabbitMQPublisher.js
================================================
const amqp = require("amqplib");

class RabbitMQPublisher {
  constructor() {
    this.exchange = process.env.RABBITMQ_EXCHANGE;
    this.url = process.env.RABBITMQ_URL;

    this.connection = null;
    this.channel = null;
  }

  async connect() {
    if (this.channel) return;

    this.connection = await amqp.connect(this.url);
    this.channel = await this.connection.createChannel();

    await this.channel.assertExchange(this.exchange, "topic", { durable: true });
  }

  async publish(routingKey, data) {
    if (!this.channel) await this.connect();

    this.channel.publish(
      this.exchange,
      routingKey,
      Buffer.from(JSON.stringify(data)),
      { persistent: true }
    );

    console.log("ðŸ“¤ Published:", routingKey, data);
  }
}

module.exports = new RabbitMQPublisher();


================================================
FILE: src/infrastructure/api/controllers/KitchenController.js
================================================
const {
  requestKitchenUseCase,
  approveKitchenUseCase,
  rejectKitchenUseCase,
  getPendingKitchensUseCase,
  getApprovedKitchensUseCase,
  getRejectedKitchensUseCase,
  getNearbyKitchensUseCase,
  getKitchenDetailsUseCase,
  updateKitchenInfoUseCase
} = require('../dependencies/dependencies');

class KitchenController {
  async requestKitchen(req, res) {
    try {
      const result = await requestKitchenUseCase.execute(req.body);

      res.status(201).json({
        success: true,
        data: result
      });
    } catch (err) {
      console.error('âŒ Error en requestKitchen:', err);

      res.status(500).json({
        success: false,
        message: 'Error al registrar cocina',
        error: err.message || String(err)
      });
    }
  }

  async getPendingKitchens(_req, res) {
    try {
      const data = await getPendingKitchensUseCase.execute();
      res.status(200).json({ success: true, data });
    } catch (err) {
      console.error('âŒ Error en getPendingKitchens:', err);
      res.status(500).json({ success: false, error: err.message || String(err) });
    }
  }

  async getApprovedKitchens(_req, res) {
    try {
      const data = await getApprovedKitchensUseCase.execute();
      res.status(200).json({ success: true, data });
    } catch (err) {
      console.error('âŒ Error en getApprovedKitchens:', err);
      res.status(500).json({ success: false, error: err.message || String(err) });
    }
  }

  async getRejectedKitchens(_req, res) {
    try {
      const data = await getRejectedKitchensUseCase.execute();
      res.status(200).json({ success: true, data });
    } catch (err) {
      console.error('âŒ Error en getRejectedKitchens:', err);
      res.status(500).json({ success: false, error: err.message || String(err) });
    }
  }

  async getNearbyKitchens(req, res) {
    try {
      const { stateId, municipalityId } = req.user;

      const kitchens = await getNearbyKitchensUseCase.execute({
        stateId,
        municipalityId
      });

      res.status(200).json({ success: true, data: kitchens });
    } catch (err) {
      console.error('âŒ Error en getNearbyKitchens:', err);
      res.status(500).json({ success: false, error: err.message || String(err) });
    }
  }

  async approveKitchen(req, res) {
    try {
      const kitchenId = req.params.id;
      const result = await approveKitchenUseCase.execute(kitchenId);

      res.status(200).json({ success: true, data: result });
    } catch (err) {
      console.error('âŒ Error en approveKitchen:', err);

      res.status(err.http_status || 500).json({
        success: false,
        message: 'Error al aprobar cocina',
        error: err.message || String(err)
      });
    }
  }

  async rejectKitchen(req, res) {
    try {
      const kitchenId = req.params.id;
      const reason = req.body.reason;
      const adminUserId = req.user?.id || null;

      const result = await rejectKitchenUseCase.execute(
        kitchenId,
        reason,
        adminUserId
      );

      res.status(200).json({ success: true, data: result });
    } catch (err) {
      console.error('âŒ Error en rejectKitchen:', err);

      res.status(err.http_status || 500).json({
        success: false,
        message: 'Error al rechazar cocina',
        error: err.message || String(err)
      });
    }
  }

  async updateKitchen(req, res) {
    try {
      const adminUserId = req.user.id;
      const kitchenId = req.params.id;
      const updates = req.body;

      const updatedKitchen = await updateKitchenInfoUseCase.execute(
        adminUserId,
        kitchenId,
        updates
      );

      res.status(200).json({
        success: true,
        message: 'Cocina actualizada correctamente',
        data: updatedKitchen
      });
    } catch (err) {
      console.error('âŒ Error en updateKitchen:', err);

      res.status(err.http_status || 500).json({
        success: false,
        message: err.message || 'Error al actualizar la cocina'
      });
    }
  }

  async getKitchenDetails(req, res) {
    try {
      const kitchenId = req.params.id;
      const data = await getKitchenDetailsUseCase.execute(kitchenId);

      res.status(200).json({ success: true, data });
    } catch (err) {
      console.error('âŒ Error en getKitchenDetails:', err);

      res.status(err.http_status || 500).json({
        success: false,
        message: 'Error al obtener detalles de la cocina',
        error: err.message || String(err)
      });
    }
  }
}

module.exports = new KitchenController();


================================================
FILE: src/infrastructure/api/controllers/KitchenScheduleController.js
================================================
const {
  createKitchenScheduleUseCase,
  updateKitchenScheduleUseCase,
  getKitchenScheduleUseCase
} = require('../dependencies/dependencies');

class KitchenScheduleController {
  async create(req, res) {
    try {
      const kitchenId = req.params.kitchenId;

      const schedules = await createKitchenScheduleUseCase.execute(
        kitchenId,
        req.body
      );

      res.status(201).json({
        success: true,
        message: 'Horarios creados correctamente',
        data: schedules
      });
    } catch (err) {
      console.error('âŒ Error en create schedule:', err);

      res.status(400).json({
        success: false,
        message: err.message || String(err)
      });
    }
  }

  async update(req, res) {
    try {
      const kitchenId = req.params.kitchenId;

      const schedules = await updateKitchenScheduleUseCase.execute(
        kitchenId,
        req.body
      );

      res.status(200).json({
        success: true,
        message: 'Horarios actualizados correctamente',
        data: schedules
      });
    } catch (err) {
      console.error('âŒ Error en update schedule:', err);

      res.status(400).json({
        success: false,
        message: err.message || String(err)
      });
    }
  }

  async get(req, res) {
    try {
      const kitchenId = req.params.kitchenId;
      const schedules = await getKitchenScheduleUseCase.execute(kitchenId);

      res.status(200).json({ success: true, data: schedules });
    } catch (err) {
      console.error('âŒ Error en get schedule:', err);

      res.status(400).json({
        success: false,
        message: err.message || String(err)
      });
    }
  }
}

module.exports = new KitchenScheduleController();


================================================
FILE: src/infrastructure/api/dependencies/dependencies.js
================================================
const SequelizeKitchenRepository = require('../../database/repositories/SequelizeKitchenRepository');
const SequelizeLocationRepository = require('../../database/repositories/SequelizeLocationRepository');
const SequelizeKitchenResponsibleRepository = require('../../database/repositories/SequelizeKitchenResponsibleRepository');
const SequelizeKitchenScheduleRepository = require('../../database/repositories/SequelizeKitchenScheduleRepository');

const RequestKitchenUseCase = require('../../../application/use-cases/RequestKitchenUseCase');
const ApproveKitchenUseCase = require('../../../application/use-cases/ApproveKitchenUseCase');
const RejectKitchenUseCase = require('../../../application/use-cases/RejectKitchenUseCase');

const GetPendingKitchensUseCase = require('../../../application/use-cases/GetPendingKitchensUseCase');
const GetApprovedKitchensUseCase = require('../../../application/use-cases/GetApprovedKitchensUseCase');
const GetRejectedKitchensUseCase = require('../../../application/use-cases/GetRejectedKitchensUseCase');

const GetNearbyKitchensUseCase = require('../../../application/use-cases/GetNearbyKitchensUseCase');
const GetKitchenDetailsUseCase = require('../../../application/use-cases/GetKitchenDetailsUseCase');

const CreateKitchenScheduleUseCase = require('../../../application/use-cases/CreateKitchenScheduleUseCase');
const UpdateKitchenScheduleUseCase = require('../../../application/use-cases/UpdateKitchenScheduleUseCase');
const GetKitchenScheduleUseCase = require('../../../application/use-cases/GetKitchenScheduleUseCase');

const rabbitMQPublisher = require('../../adapters/RabbitMQPublisher');

const kitchenRepository = new SequelizeKitchenRepository();
const locationRepository = new SequelizeLocationRepository();
const responsibleRepository = new SequelizeKitchenResponsibleRepository();
const scheduleRepository = new SequelizeKitchenScheduleRepository();

module.exports = {
  requestKitchenUseCase: new RequestKitchenUseCase(
    kitchenRepository,
    locationRepository,
    responsibleRepository
  ),

  approveKitchenUseCase: new ApproveKitchenUseCase(
    kitchenRepository,
    responsibleRepository,
    rabbitMQPublisher
  ),

  rejectKitchenUseCase: new RejectKitchenUseCase(
    kitchenRepository,
    rabbitMQPublisher
  ),

  getPendingKitchensUseCase: new GetPendingKitchensUseCase(kitchenRepository),
  getApprovedKitchensUseCase: new GetApprovedKitchensUseCase(kitchenRepository),
  getRejectedKitchensUseCase: new GetRejectedKitchensUseCase(kitchenRepository),

  getNearbyKitchensUseCase: new GetNearbyKitchensUseCase(
    kitchenRepository,
    locationRepository
  ),

  getKitchenDetailsUseCase: new GetKitchenDetailsUseCase(
    kitchenRepository,
    locationRepository
  ),

  createKitchenScheduleUseCase: new CreateKitchenScheduleUseCase(
    scheduleRepository
  ),
  updateKitchenScheduleUseCase: new UpdateKitchenScheduleUseCase(
    scheduleRepository
  ),
  getKitchenScheduleUseCase: new GetKitchenScheduleUseCase(
    scheduleRepository
  )
};


================================================
FILE: src/infrastructure/api/routes/KitchenRoutes.js
================================================
const express = require('express');
const router = express.Router();

const requireAuth = require('../../../middleware/require-auth');
const requireRole = require('../../../middleware/require-role');
const requireKitchenOwner = require('../../../middleware/require-kitchen-owner');

const controller = require('../controllers/KitchenController');

router.post('/request', controller.requestKitchen);

router.get('/pending', requireRole('Super_admin'), controller.getPendingKitchens);
router.get('/approved', requireRole('Super_admin'), controller.getApprovedKitchens);
router.get('/rejected', requireRole('Super_admin'), controller.getRejectedKitchens);

router.get('/nearby', requireRole('Voluntario'), controller.getNearbyKitchens);

router.post('/:id/approve', requireRole('Super_admin'), controller.approveKitchen);
router.post('/:id/reject', requireRole('Super_admin'), controller.rejectKitchen);

router.put(
  '/:id',
  requireAuth,
  requireRole('Admin_cocina'),
  requireKitchenOwner,
  controller.updateKitchen
);

router.get('/:id', requireAuth, controller.getKitchenDetails);

module.exports = router;


================================================
FILE: src/infrastructure/api/routes/KitchenScheduleRoutes.js
================================================
const express = require('express');
const router = express.Router();

const requireAuth = require('../../../middleware/require-auth');
const requireRole = require('../../../middleware/require-role');
const requireKitchenOwner = require('../../../middleware/require-kitchen-owner');

const controller = require('../controllers/KitchenScheduleController');

router.post(
  '/:kitchenId/schedules',
  requireAuth,
  requireRole('Admin_cocina'),
  requireKitchenOwner,
  controller.create
);

router.put(
  '/:kitchenId/schedules',
  requireAuth,
  requireRole('Admin_cocina'),
  requireKitchenOwner,
  controller.update
);

router.get(
  '/:kitchenId/schedules',
  requireAuth,
  controller.get
);

module.exports = router;


================================================
FILE: src/infrastructure/database/config/database.js
================================================
require('dotenv').config();
const { Sequelize } = require('sequelize');

const sequelize = new Sequelize(
  process.env.DB_DATABASE,      
  process.env.DB_USERNAME,
  process.env.DB_PASSWORD,
  {
    host: process.env.DB_HOST,  
    port: process.env.DB_PORT,
    dialect: 'postgres',
    logging: false,
    dialectOptions: {
      ssl: {
        require: true,
        rejectUnauthorized: false 
      }
    }
  }
);

module.exports = sequelize;



================================================
FILE: src/infrastructure/database/models/KitchenModel.js
================================================
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const Location = require('./LocationModel');
const KitchenSchedule = require('./KitchenScheduleModel');
const KitchenResponsible = require('./KitchenResponsibleModel');

const Kitchen = sequelize.define(
  'Kitchen',
  {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },

    name: { type: DataTypes.STRING, allowNull: false },
    description: { type: DataTypes.TEXT, allowNull: false },

    ownerId: { type: DataTypes.INTEGER, allowNull: false },

    locationId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: { model: 'locations', key: 'id' }
    },

    contactPhone: { type: DataTypes.STRING, allowNull: false },
    contactEmail: { type: DataTypes.STRING, allowNull: false },
    imageUrl: { type: DataTypes.STRING },

    registrationDate: { type: DataTypes.DATE, defaultValue: DataTypes.NOW },

    approvalStatus: {
      type: DataTypes.ENUM('pending', 'approved', 'rejected'),
      defaultValue: 'pending'
    },

    approvedBy: { type: DataTypes.INTEGER },
    approvalDate: { type: DataTypes.DATE },
    rejectionReason: { type: DataTypes.TEXT },

    isActive: { type: DataTypes.BOOLEAN, defaultValue: false }
  },
  {
    tableName: 'kitchens',
    timestamps: false
  }
);

Kitchen.belongsTo(Location, {
  foreignKey: 'locationId',
  as: 'location'
});

Location.hasMany(Kitchen, {
  foreignKey: 'locationId',
  as: 'kitchens'
});

Kitchen.hasOne(KitchenResponsible, {
  foreignKey: 'kitchenId',
  as: 'responsible'
});

KitchenResponsible.belongsTo(Kitchen, {
  foreignKey: 'kitchenId',
  as: 'kitchen'
});

Kitchen.hasOne(KitchenSchedule, {
  foreignKey: 'kitchenId',
  as: 'schedule'
});

KitchenSchedule.belongsTo(Kitchen, {
  foreignKey: 'kitchenId',
  as: 'kitchen'
});

module.exports = Kitchen;



================================================
FILE: src/infrastructure/database/models/KitchenResponsibleModel.js
================================================
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const KitchenResponsible = sequelize.define(
  'KitchenResponsible',
  {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },

    kitchenId: {
      type: DataTypes.INTEGER,
      allowNull: false,
      references: { model: 'kitchens', key: 'id' }
    },

    names: { type: DataTypes.STRING, allowNull: false },
    firstLastName: { type: DataTypes.STRING, allowNull: false },
    secondLastName: { type: DataTypes.STRING, allowNull: true },

    email: { type: DataTypes.STRING, allowNull: false },
    phoneNumber: { type: DataTypes.STRING, allowNull: false },

    createdAt: { type: DataTypes.DATE, defaultValue: DataTypes.NOW }
  },
  {
    tableName: 'kitchenResponsibles',
    timestamps: false
  }
);

module.exports = KitchenResponsible;



================================================
FILE: src/infrastructure/database/models/KitchenScheduleModel.js
================================================
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const KitchenSchedule = sequelize.define(
  'KitchenSchedule',
  {
    id: { type: DataTypes.INTEGER, autoIncrement: true, primaryKey: true },

    kitchenId: { type: DataTypes.INTEGER, allowNull: false },

    openTimeWeekdays: { type: DataTypes.TIME, allowNull: false },
    closeTimeWeekdays: { type: DataTypes.TIME, allowNull: false },

    openTimeWeekends: { type: DataTypes.TIME, allowNull: false },
    closeTimeWeekends: { type: DataTypes.TIME, allowNull: false },

    isActive: { type: DataTypes.BOOLEAN, defaultValue: true }
  },
  {
    tableName: 'kitchenSchedules',
    timestamps: false
  }
);

module.exports = KitchenSchedule;



================================================
FILE: src/infrastructure/database/models/LocationModel.js
================================================
const { DataTypes } = require('sequelize');
const sequelize = require('../config/database');

const Location = sequelize.define(
  'Location',
  {
    id: { type: DataTypes.INTEGER, primaryKey: true, autoIncrement: true },

    name: { type: DataTypes.STRING, allowNull: false },

    streetAddress: { type: DataTypes.STRING, allowNull: false },
    neighborhood: { type: DataTypes.STRING, allowNull: false },

    stateId: { type: DataTypes.INTEGER, allowNull: false },
    municipalityId: { type: DataTypes.INTEGER, allowNull: false },

    postalCode: { type: DataTypes.STRING, allowNull: false },

    isActive: { type: DataTypes.BOOLEAN, defaultValue: true }
  },
  {
    tableName: 'locations',
    timestamps: false
  }
);

module.exports = Location;



================================================
FILE: src/infrastructure/database/repositories/SequelizeKitchenRepository.js
================================================
const KitchenModel = require("../models/KitchenModel");
const KitchenResponsibleModel = require("../models/KitchenResponsibleModel");
const LocationModel = require("../models/LocationModel");

const Kitchen = require("../../../domain/entities/Kitchen");

class SequelizeKitchenRepository {
  _toDomain(model) {
    if (!model) return null;
    const json = model.toJSON();
    return new Kitchen({
      ...json,
      responsible: json.responsible || null,
      location: json.location || null
    });
  }

  async create(data) {
    const newKitchen = await KitchenModel.create({
      name: data.name,
      description: data.description,

      ownerId: data.ownerId,

      locationId: data.locationId,

      contactPhone: data.contactPhone,
      contactEmail: data.contactEmail,
      imageUrl: data.imageUrl ?? null
    });

    return this._toDomain(newKitchen);
  }

  async findById(id) {
    const result = await KitchenModel.findOne({
      where: { id },
      include: [
        { model: KitchenResponsibleModel, as: "responsible" },
        { model: LocationModel, as: "location" }
      ]
    });

    return this._toDomain(result);
  }

  async update(id, data) {
    await KitchenModel.update(data, { where: { id } });
    return this.findById(id);
  }

  async findPending() {
    return (
      await KitchenModel.findAll({
        where: { approvalStatus: "pending" },
        include: [
          { model: KitchenResponsibleModel, as: "responsible" },
          { model: LocationModel, as: "location" }
        ]
      })
    ).map(m => this._toDomain(m));
  }

  async findApproved() {
    return (
      await KitchenModel.findAll({
        where: { approvalStatus: "approved" },
        include: [
          { model: KitchenResponsibleModel, as: "responsible" },
          { model: LocationModel, as: "location" }
        ]
      })
    ).map(m => this._toDomain(m));
  }

  async findRejected() {
    return (
      await KitchenModel.findAll({
        where: { approvalStatus: "rejected" },
        include: [
          { model: KitchenResponsibleModel, as: "responsible" },
          { model: LocationModel, as: "location" }
        ]
      })
    ).map(m => this._toDomain(m));
  }

  async findByLocationIds(ids) {
    return (
      await KitchenModel.findAll({
        where: { locationId: ids },
        include: [{ model: LocationModel, as: "location" }]
      })
    ).map(m => this._toDomain(m));
  }
}

module.exports = SequelizeKitchenRepository;



================================================
FILE: src/infrastructure/database/repositories/SequelizeKitchenResponsibleRepository.js
================================================
const KitchenResponsibleModel = require("../models/KitchenResponsibleModel");
const KitchenResponsible = require("../../../domain/entities/KitchenResponsible");

class SequelizeKitchenResponsibleRepository {
  _toDomain(model) {
    if (!model) return null;
    return new KitchenResponsible(model.toJSON());
  }

  async create(data) {
    const created = await KitchenResponsibleModel.create({
      kitchenId: data.kitchenId,
      names: data.names,
      firstLastName: data.firstLastName,
      secondLastName: data.secondLastName,
      email: data.email,
      phoneNumber: data.phoneNumber
    });

    return this._toDomain(created);
  }

  async findByKitchenId(kitchenId) {
    const model = await KitchenResponsibleModel.findOne({
      where: { kitchenId }
    });

    return this._toDomain(model);
  }
}

module.exports = SequelizeKitchenResponsibleRepository;


================================================
FILE: src/infrastructure/database/repositories/SequelizeKitchenScheduleRepository.js
================================================
const KitchenScheduleModel = require("../models/KitchenScheduleModel");
const KitchenSchedule = require("../../../domain/entities/KitchenSchedule");

class SequelizeKitchenScheduleRepository {
  _toDomain(model) {
    if (!model) return null;
    return new KitchenSchedule(model.toJSON());
  }

  async create(schedule) {
    const created = await KitchenScheduleModel.create({
      kitchenId: schedule.kitchenId,
      day: schedule.day,
      startTime: schedule.startTime,
      endTime: schedule.endTime
    });

    return this._toDomain(created);
  }

  async findByKitchenId(kitchenId) {
    const rows = await KitchenScheduleModel.findAll({ where: { kitchenId } });
    return rows.map(r => this._toDomain(r));
  }

  async deleteByKitchenId(kitchenId) {
    await KitchenScheduleModel.destroy({ where: { kitchenId } });
  }
}

module.exports = SequelizeKitchenScheduleRepository;


================================================
FILE: src/infrastructure/database/repositories/SequelizeLocationRepository.js
================================================
const LocationModel = require("../models/LocationModel");
const Location = require("../../../domain/entities/Location");

class SequelizeLocationRepository {
  _toDomain(model) {
    if (!model) return null;
    return new Location(model.toJSON());
  }

  async create(data) {
    const newLocation = await LocationModel.create({
      streetAddress: data.streetAddress,
      neighborhood: data.neighborhood,
      stateId: data.stateId,
      municipalityId: data.municipalityId,
      postalCode: data.postalCode
    });

    return this._toDomain(newLocation);
  }

  async findById(id) {
    const model = await LocationModel.findByPk(id);
    return this._toDomain(model);
  }

  async findByStateAndMunicipality(stateId, municipalityId) {
    const models = await LocationModel.findAll({
      where: { stateId, municipalityId, isActive: true }
    });

    return models.map(m => this._toDomain(m));
  }
}

module.exports = SequelizeLocationRepository;


================================================
FILE: src/infrastructure/store/temp-password.store.js
================================================
const tempPasswords = new Map();

function saveTemporaryPassword(kitchenId, password) {
  tempPasswords.set(kitchenId, password);
}

function getTemporaryPassword(kitchenId) {
  return tempPasswords.get(kitchenId);
}

function clearTemporaryPassword(kitchenId) {
  tempPasswords.delete(kitchenId);
}

module.exports = {
  saveTemporaryPassword,
  getTemporaryPassword,
  clearTemporaryPassword
};


================================================
FILE: src/middleware/require-auth.js
================================================
const jwt = require("jsonwebtoken");

module.exports = function requireAuth(req, res, next) {
  const header = req.headers.authorization;

  if (!header) {
    return res.status(401).json({
      success: false,
      message: "Missing Authorization header"
    });
  }

  const token = header.replace("Bearer ", "");

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    req.user = {
      id: decoded.userId,
      email: decoded.email,
      roles: decoded.roles || [],
      stateId: decoded.stateId ?? null,
      municipalityId: decoded.municipalityId ?? null
    };

    next();
  } catch (error) {
    return res.status(401).json({
      success: false,
      message: "Invalid token",
      error: error.message
    });
  }
};



================================================
FILE: src/middleware/require-kitchen-owner.js
================================================
const SequelizeKitchenRepository = require("../infrastructure/database/repositories/SequelizeKitchenRepository");
const kitchenRepository = new SequelizeKitchenRepository();

module.exports = async function requireKitchenOwner(req, res, next) {
  try {
    const userId = req.user.id;
    const kitchenId = req.params.id;

    const kitchen = await kitchenRepository.findById(kitchenId);

    if (!kitchen) {
      return res.status(404).json({
        success: false,
        message: "Kitchen not found"
      });
    }

    if (kitchen.ownerId !== userId) {
      return res.status(403).json({
        success: false,
        message: "Forbidden: This kitchen does not belong to you"
      });
    }

    next();
  } catch (error) {
    console.error("Error in requireKitchenOwner:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error"
    });
  }
};



================================================
FILE: src/middleware/require-role.js
================================================
const jwt = require("jsonwebtoken");

module.exports = function requireRole(requiredRole) {
  return (req, res, next) => {
    const header = req.headers.authorization;

    if (!header) {
      return res.status(401).json({
        success: false,
        message: "Missing Authorization header"
      });
    }

    const token = header.replace("Bearer ", "");

    try {
      const decoded = jwt.verify(token, process.env.JWT_SECRET);

      const roles = decoded.roles || [];

      if (!roles.includes(requiredRole)) {
        return res.status(403).json({
          success: false,
          message: "Forbidden: You don't have permission",
          requiredRole,
          userRoles: roles
        });
      }

      req.user = {
        id: decoded.userId,
        email: decoded.email,
        roles,
        stateId: decoded.stateId ?? null,
        municipalityId: decoded.municipalityId ?? null
      };

      next();

    } catch (error) {
      return res.status(401).json({
        success: false,
        message: "Invalid token",
        error: error.message
      });
    }
  };
};