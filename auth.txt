Directory structure:
‚îî‚îÄ‚îÄ didiercito-auth_service/
    ‚îú‚îÄ‚îÄ package.json
    ‚îú‚îÄ‚îÄ tsconfig.json
    ‚îî‚îÄ‚îÄ src/
        ‚îú‚îÄ‚îÄ app.ts
        ‚îú‚îÄ‚îÄ server.ts
        ‚îú‚îÄ‚îÄ application/
        ‚îÇ   ‚îî‚îÄ‚îÄ use-cases/
        ‚îÇ       ‚îú‚îÄ‚îÄ add-user-skill.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ assign-role.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ assign-volunteer-role.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ check-user-availability.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ check-user-permission.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ complete-profile.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ create-user-schedule.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ delete-user-schedule.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ delete-user.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-my-profile.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-nearby-kitchens.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-skills.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-user-availability.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-user-by-email.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-user-by-id.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-user-permissions.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-user-reputation-history.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-user-schedules.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-user-skills.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ get-users-paginated.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ index.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ login-user.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ refresh-token.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ register-admin-kitchen.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ register-user.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ remove-role.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ remove-user-skill.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ request-password-reset.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ resend-email-verification.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ resend-phone-verification.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ reset-password.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ set-user-availability.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ update-profile.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ update-user-availability.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ update-user-reputation.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ update-user-schedule.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ update-user.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ validate-token.use-case.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ verify-email.use-case.ts
        ‚îÇ       ‚îî‚îÄ‚îÄ verify-phone.use-case.ts
        ‚îú‚îÄ‚îÄ config/
        ‚îÇ   ‚îú‚îÄ‚îÄ data-source.ts
        ‚îÇ   ‚îú‚îÄ‚îÄ database.config.ts
        ‚îÇ   ‚îú‚îÄ‚îÄ rabbitmq.config.ts
        ‚îÇ   ‚îî‚îÄ‚îÄ seed/
        ‚îÇ       ‚îî‚îÄ‚îÄ seed.ts
        ‚îú‚îÄ‚îÄ consumers/
        ‚îÇ   ‚îî‚îÄ‚îÄ index.ts
        ‚îú‚îÄ‚îÄ database/
        ‚îÇ   ‚îî‚îÄ‚îÄ schemas/
        ‚îÇ       ‚îú‚îÄ‚îÄ email-verification.schema.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ index.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ password-reset-token.schema.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ permission.schema.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ phone-verification.schema.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ role.schema.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ skill.schema.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ user-availability.schema.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ user-reputation-history.schema.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ user-role.schema.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ user-schedule.schema.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ user-skill.schema.ts
        ‚îÇ       ‚îî‚îÄ‚îÄ user.schema.ts
        ‚îú‚îÄ‚îÄ domain/
        ‚îÇ   ‚îú‚îÄ‚îÄ entities/
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email-verification.entity.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ password-reset-token.entity.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ permission.entity.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phone-verification.entity.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ role.entity.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ skill.entity.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-availability.entity.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-reputation-history.entity.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-schedule.entity.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-skill.entity.ts
        ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.entity.ts
        ‚îÇ   ‚îú‚îÄ‚îÄ interfaces/
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email-verification.repository.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ event-publisher.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ password-hasher.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ password-reset-token.repository.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ permission.repository.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phone-verification.repository.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ role.repository.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ skill.repository.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ token-generator.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-availability.repository.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-reputation-history.repository.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-schedule.repository.interface.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-skill.repository.interface.ts
        ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.repository.interface.ts
        ‚îÇ   ‚îî‚îÄ‚îÄ validators/
        ‚îÇ       ‚îú‚îÄ‚îÄ email-verification.validator.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ password-reset-token.validator.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ password-strength.validator.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ phone-verification.validator.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ skill.validator.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ user-availability.validator.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ user-reputation-history.validator.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ user-schedule.validator.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ user-skill.validator.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ user.validator.ts
        ‚îÇ       ‚îî‚îÄ‚îÄ validator.ts
        ‚îú‚îÄ‚îÄ infrastructure/
        ‚îÇ   ‚îú‚îÄ‚îÄ adapters/
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ email-verification.adapter.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ password-reset-token.adapter.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ permission.adapter.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ phone-verification.adapter.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ role.adapter.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ skill.adapter.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-availability.adapter.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-reputation-history.adapter.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-schedule.adapter.ts
        ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user-skill.adapter.ts
        ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ user.adapter.ts
        ‚îÇ   ‚îî‚îÄ‚îÄ api/
        ‚îÇ       ‚îú‚îÄ‚îÄ controllers/
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ add-user-skill.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ assign-role.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ check-user-availability.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ check-user-permission.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ complete-profile.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ create-user-schedule.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ delete-user-availability.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ delete-user-schedule.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ delete-user.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-my-availability.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-my-profile.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-skills.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-user-availability.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-user-by-email.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-user-by-id.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-user-permissions.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-user-reputation-history.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-user-schedules.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-user-skills.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ get-users-paginated.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ index.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ login-user.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ refresh-token.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ register-kitchen-admin.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ register-user.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ remove-role.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ remove-user-skill.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ request-password-reset.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ resend-email-verification.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ resend-phone-verification.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ reset-password.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ set-user-availability.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ update-profile.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ update-user-availability.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ update-user-reputation.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ update-user-schedule.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ update-user.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ validate-token.controller.ts
        ‚îÇ       ‚îÇ   ‚îú‚îÄ‚îÄ verify-email.controller.ts
        ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ verify-phone.controller.ts
        ‚îÇ       ‚îú‚îÄ‚îÄ dependencies/
        ‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ dependencies.ts
        ‚îÇ       ‚îî‚îÄ‚îÄ routes/
        ‚îÇ           ‚îú‚îÄ‚îÄ auth.routes.ts
        ‚îÇ           ‚îú‚îÄ‚îÄ availability.routes.ts
        ‚îÇ           ‚îú‚îÄ‚îÄ password.routes.ts
        ‚îÇ           ‚îú‚îÄ‚îÄ permission.routes.ts
        ‚îÇ           ‚îú‚îÄ‚îÄ reputation.routes.ts
        ‚îÇ           ‚îú‚îÄ‚îÄ role.routes.ts
        ‚îÇ           ‚îú‚îÄ‚îÄ schedule.routes.ts
        ‚îÇ           ‚îú‚îÄ‚îÄ skill.routes.ts
        ‚îÇ           ‚îú‚îÄ‚îÄ user.routes.ts
        ‚îÇ           ‚îî‚îÄ‚îÄ verification.routes.ts
        ‚îú‚îÄ‚îÄ middleware/
        ‚îÇ   ‚îî‚îÄ‚îÄ auth.middleware.ts
        ‚îú‚îÄ‚îÄ services/
        ‚îÇ   ‚îú‚îÄ‚îÄ bcrypt-password-hasher.service.ts
        ‚îÇ   ‚îú‚îÄ‚îÄ jwt-token-generator.service.ts
        ‚îÇ   ‚îú‚îÄ‚îÄ kitchen-approved.consumer.service.ts
        ‚îÇ   ‚îî‚îÄ‚îÄ rabbitmq-event-publisher.service.ts
        ‚îî‚îÄ‚îÄ types/
            ‚îî‚îÄ‚îÄ amqplib.d.ts

================================================
FILE: package.json
================================================
{
  "name": "auth-service",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only --ignore-watch node_modules --exit-child src/server.ts",
    "tsc": "tsc",
    "build": "tsc",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "amqplib": "^0.10.3",
    "axios": "^1.13.2",
    "bcrypt": "^5.1.1",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.2",
    "pg": "^8.11.3",
    "reflect-metadata": "^0.2.1",
    "typeorm": "^0.3.19",
    "uuid": "^9.0.1"
  },
  "devDependencies": {
    "@types/bcrypt": "^5.0.2",
    "@types/cors": "^2.8.17",
    "@types/express": "^4.17.21",
    "@types/jsonwebtoken": "^9.0.5",
    "@types/node": "^20.10.6",
    "@types/uuid": "^9.0.7",
    "nodemon": "^3.0.2",
    "ts-node": "^10.9.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.3.3"
  }
}



================================================
FILE: tsconfig.json
================================================
{
  "compilerOptions": {
    "target": "ES2020",
    "lib": ["ES2020"],
    "experimentalDecorators": true,
    "emitDecoratorMetadata": true,
    "module": "commonjs",
    "rootDir": "./src",
    "moduleResolution": "node",
    "resolveJsonModule": true,
    "outDir": "./dist",
    "removeComments": true,
    "sourceMap": true,
    "esModuleInterop": true,
    "allowSyntheticDefaultImports": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": false,
    "noImplicitThis": true,
    "alwaysStrict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "skipLibCheck": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.spec.ts", "**/*.test.ts"]
}


================================================
FILE: src/app.ts
================================================
import express, { Request, Response } from 'express'; 
import cors from 'cors';
import Authroutes from './infrastructure/api/routes/auth.routes';
import PasswordRoutes from './infrastructure/api/routes/password.routes';
import permissonRoutes from './infrastructure/api/routes/permission.routes';
import RoleRoutes from './infrastructure/api/routes/role.routes';
import VerificationRoutes from './infrastructure/api/routes/verification.routes';
import userRoutes from './infrastructure/api/routes/user.routes';
import skillRoutes from './infrastructure/api/routes/skill.routes';
import availabilityRoutes from './infrastructure/api/routes/availability.routes';
import scheduleRoutes from './infrastructure/api/routes/schedule.routes';
import reputationRoutes from './infrastructure/api/routes/reputation.routes';

const app = express();
app.use(cors({ origin: '*' }));

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

app.get('/health', (_req: Request, res: Response) => { 
  res.json({
    success: true,
    service: 'Auth-User Service',
    version: '1.0.0',
    timestamp: new Date().toISOString(),
    uptime: process.uptime()
  });
});

app.use('/api/v1/auth', Authroutes);
app.use('/api/v1/password', PasswordRoutes);
app.use('/api/v1/permission', permissonRoutes);
app.use('/api/v1/role', RoleRoutes);
app.use('/api/v1/verification', VerificationRoutes);
app.use('/api/v1/users', userRoutes);
app.use('/api/v1/skills', skillRoutes);
app.use('/api/v1/availability', availabilityRoutes);
app.use('/api/v1/schedules', scheduleRoutes);
app.use('/api/v1/reputation', reputationRoutes);


export default app;


================================================
FILE: src/server.ts
================================================
import { config } from 'dotenv';
config();

import app from './app';
import { initializeDatabase, closeDatabase } from './config/data-source';
import { eventPublisher } from './infrastructure/api/dependencies/dependencies';
import { startConsumers } from './consumers';
import { runSeeds } from './config/seed/seed';

const PORT = process.env.PORT;

const startServer = async () => {
  try {
    console.log('üöÄ Starting Auth-User Service...');
    
    console.log('üì¶ Connecting to database...');
    await initializeDatabase();
    console.log('‚úÖ Database connected successfully');

    console.log('üå± Running database seeds...');
    await runSeeds();
    console.log('‚úÖ Seeds executed successfully');

    console.log('üì• Starting RabbitMQ Consumers...');
    await startConsumers();
    console.log('‚úÖ Consumers started');

    console.log('üì® Connecting publisher to RabbitMQ...');
    await eventPublisher.connect();
    console.log('‚úÖ Publisher connected');

    app.listen(PORT, () => {
      console.log(`Server running in port: http://localhost:${PORT}`);
    });

  } catch (error) {
    console.error('‚ùå Failed to start server:', error);
    process.exit(1);
  }
};

const gracefulShutdown = async (signal: string) => {
  console.log(`\n${signal} received. Closing server gracefully...`);

  try {
    await closeDatabase();
    console.log('‚úÖ Database connection closed');

    await eventPublisher.close();
    console.log('‚úÖ RabbitMQ connection closed');

    console.log('‚úÖ Server closed gracefully');
    process.exit(0);

  } catch (error) {
    console.error('‚ùå Error during graceful shutdown:', error);
    process.exit(1);
  }
};

process.on('SIGTERM', () => gracefulShutdown('SIGTERM'));
process.on('SIGINT', () => gracefulShutdown('SIGINT'));

process.on('unhandledRejection', (reason, promise) => {
  console.error('‚ùå Unhandled Rejection at:', promise, 'reason:', reason);
  gracefulShutdown('Unhandled Rejection');
});

process.on('uncaughtException', (error) => {
  console.error('‚ùå Uncaught Exception:', error);
  gracefulShutdown('Uncaught Exception');
});

startServer();



================================================
FILE: src/application/use-cases/add-user-skill.use-case.ts
================================================
import { IUserSkillRepository } from '../../domain/interfaces/user-skill.repository.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { ISkillRepository } from '../../domain/interfaces/skill.repository.interface';
import { UserSkill } from '../../domain/entities/user-skill.entity';

export class AddUserSkillUseCase {
  constructor(
    private readonly userSkillRepository: IUserSkillRepository,
    private readonly userRepository: IUserRepository,
    private readonly skillRepository: ISkillRepository
  ) {}

  async execute(dto: any): Promise<UserSkill> {
    if (!dto.userId || !dto.skillId) {
      throw new Error('User ID and Skill ID are required');
    }

    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    const skill = await this.skillRepository.findById(dto.skillId);
    if (!skill) {
      throw new Error('Skill not found');
    }

    if (!skill.isActive) {
      throw new Error('Skill is not active');
    }

    const existingUserSkill = await this.userSkillRepository.findByUserIdAndSkillId(
      dto.userId,
      dto.skillId
    );
    if (existingUserSkill) {
      throw new Error('User already has this skill');
    }

    const userSkill = new UserSkill(
      0,
      dto.userId,
      dto.skillId,
      dto.proficiencyLevel || null,
      dto.yearsOfExperience || null,
      new Date(),
      new Date()
    );
    return await this.userSkillRepository.create(userSkill);
  }
}


================================================
FILE: src/application/use-cases/assign-role.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IRoleRepository } from '../../domain/interfaces/role.repository.interface';
import { IEventPublisher } from '../../domain/interfaces/event-publisher.interface';

export class AssignRoleUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly roleRepository: IRoleRepository,
    private readonly eventPublisher: IEventPublisher
  ) {}

  async execute(dto: any): Promise<{ message: string }> {
    if (!dto.userId || !dto.roleId) {
      throw {
        http_status: 400,
        message: 'User ID and Role ID are required'
      };
    }

    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw {
        http_status: 404,
        message: 'User not found'
      };
    }

    const role = await this.roleRepository.findById(dto.roleId);
    if (!role) {
      throw {
        http_status: 404,
        message: 'Role not found'
      };
    }

    const userRoles = await this.roleRepository.getUserRoles(dto.userId);
    const hasRole = userRoles.some(r => r.id === dto.roleId);
    if (hasRole) {
      throw {
        http_status: 400,
        message: 'User already has this role'
      };
    }

    await this.roleRepository.assignRoleToUser(
      dto.userId,
      dto.roleId,
      dto.assignedBy
    );
    await this.eventPublisher.publish('user.role.assigned', {
      userId: dto.userId,
      roleId: dto.roleId,
      roleName: role.name,
      assignedBy: dto.assignedBy,
      timestamp: new Date().toISOString()
    });
    return {
      message: `Role '${role.name}' assigned successfully to user`
    };
  }
}


================================================
FILE: src/application/use-cases/assign-volunteer-role.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IRoleRepository } from '../../domain/interfaces/role.repository.interface';
import { UserStatus } from '../../domain/entities/user.entity';

export class AssignVolunteerRoleUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly roleRepository: IRoleRepository
  ) {}

  async execute(userId: number): Promise<void> {
    if (!userId) {
       throw {
        http_status: 400,
        message: 'User ID is required'
      };
    }

    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw {
        http_status: 404,
        message: 'User not found'
      };
    }

    if (!user.verifiedEmail) {
      throw {
        http_status: 400,
        message: 'User must verify email before assigning role'
      };
    }

    const volunteerRole = await this.roleRepository.findByName('Voluntario');
    if (!volunteerRole) {
      throw {
        http_status: 500,
        message: 'Volunteer role not found in system'
      };
    }

    await this.roleRepository.assignRoleToUser(user.id, volunteerRole.id);

    user.status = UserStatus.ACTIVE;
    await this.userRepository.update(user);
  }
}


================================================
FILE: src/application/use-cases/check-user-availability.use-case.ts
================================================
import { IUserAvailabilityRepository } from '../../domain/interfaces/user-availability.repository.interface';
import { IUserScheduleRepository } from '../../domain/interfaces/user-schedule.repository.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { DayOfWeek } from '../../domain/entities/user-availability.entity';

export interface AvailabilityCheckResult {
  isAvailable: boolean;
  reason?: string;
  conflictingSchedules?: any[];
}

export class CheckUserAvailabilityUseCase {
  constructor(
    private readonly userAvailabilityRepository: IUserAvailabilityRepository,
    private readonly userScheduleRepository: IUserScheduleRepository,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(dto: any): Promise<AvailabilityCheckResult> {
    if (!dto.userId || !dto.startDateTime || !dto.endDateTime) {
      throw new Error('User ID, startDateTime, and endDateTime are required');
    }

    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    const startDateTime = new Date(dto.startDateTime);
    const endDateTime = new Date(dto.endDateTime);

    if (startDateTime >= endDateTime) {
      return {
        isAvailable: false,
        reason: 'Invalid time range: start time must be before end time'
      };
    }

    const dayOfWeek = this.getDayOfWeek(startDateTime);

    const availabilities = await this.userAvailabilityRepository.findByUserIdAndDay(
      dto.userId,
      dayOfWeek
    );
    if (availabilities.length === 0) {
      return {
        isAvailable: false,
        reason: `User has no availability configured for ${dayOfWeek}`
      };
    }

    const requestedStartTime = this.getTimeString(startDateTime);
    const requestedEndTime = this.getTimeString(endDateTime);
    const isWithinAvailability = availabilities.some(availability => {
      return this.isTimeInRange(
        requestedStartTime,
        requestedEndTime,
        availability.startTime,
        availability.endTime
      );
    });
    if (!isWithinAvailability) {
      return {
        isAvailable: false,
        reason: 'Requested time is outside user availability hours'
      };
    }

    const conflictingSchedules = await this.userScheduleRepository.findConflicts(
      dto.userId,
      startDateTime,
      endDateTime
    );
    if (conflictingSchedules.length > 0) {
      return {
        isAvailable: false,
        reason: 'User has conflicting schedules',
        conflictingSchedules
      };
    }

    return {
      isAvailable: true
    };
  }

  private getDayOfWeek(date: Date): DayOfWeek {
    const days = [
      DayOfWeek.SUNDAY,
      DayOfWeek.MONDAY,
      DayOfWeek.TUESDAY,
      DayOfWeek.WEDNESDAY,
      DayOfWeek.THURSDAY,
      DayOfWeek.FRIDAY,
      DayOfWeek.SATURDAY
    ];
    return days[date.getDay()];
  }

  private getTimeString(date: Date): string {
    const hours = date.getHours().toString().padStart(2, '0');
    const minutes = date.getMinutes().toString().padStart(2, '0');
    return `${hours}:${minutes}`;
  }

  private isTimeInRange(
    startTime: string,
    endTime: string,
    availabilityStart: string,
    availabilityEnd: string
  ): boolean {
    const start = this.timeToMinutes(startTime);
    const end = this.timeToMinutes(endTime);
    const availStart = this.timeToMinutes(availabilityStart);
    const availEnd = this.timeToMinutes(availabilityEnd);

    return start >= availStart && end <= availEnd;
  }

  private timeToMinutes(time: string): number {
    const [hours, minutes] = time.split(':').map(Number);
    return hours * 60 + minutes;
  }
}


================================================
FILE: src/application/use-cases/check-user-permission.use-case.ts
================================================
import { IPermissionRepository } from '../../domain/interfaces/permission.repository.interface';

export interface CheckUserPermissionResponse {
  hasPermission: boolean;
  userId: number;
  permission: string;
}

export class CheckUserPermissionUseCase {
  constructor(
    private readonly permissionRepository: IPermissionRepository
  ) {}

  async execute(dto: any): Promise<CheckUserPermissionResponse> {
    if (!dto.userId || !dto.module || !dto.action || !dto.resource) {
      throw {
        http_status: 400,
        message: 'User ID, module, action, and resource are required'
      };
    }
    
    const hasPermission = await this.permissionRepository.userHasPermission(
      dto.userId,
      dto.module,
      dto.action,
      dto.resource
    );
    return {
      hasPermission,
      userId: dto.userId,
      permission: `${dto.module}:${dto.action}:${dto.resource}`
    };
  }
}


================================================
FILE: src/application/use-cases/complete-profile.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IUserSkillRepository } from '../../domain/interfaces/user-skill.repository.interface';
import { ISkillRepository } from '../../domain/interfaces/skill.repository.interface';
import { AssignVolunteerRoleUseCase } from './assign-volunteer-role.use-case';
import { UserSkill } from '../../domain/entities/user-skill.entity';

export class CompleteProfileUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly userSkillRepository: IUserSkillRepository,
    private readonly skillRepository: ISkillRepository,
    private readonly assignVolunteerRoleUseCase: AssignVolunteerRoleUseCase
  ) {}

  async execute(dto: any): Promise<{
    message: string;
  }> {
    if (!dto.userId) {
       throw { http_status: 400, message: 'User ID is required' };
    }

    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw {
        http_status: 404,
        message: 'User not found'
      };
    }
    if (dto.skillIds && dto.skillIds.length > 0) {
      for (const skillId of dto.skillIds) {
        const skill = await this.skillRepository.findById(skillId);
        if (!skill) {
          throw {
            http_status: 404,
            message: `Skill with ID ${skillId} not found`
          };
        }

        const userSkill = new UserSkill(
          0,
          dto.userId,
          skillId,
          null,
          null,
          new Date(),
          new Date()
        );
        await this.userSkillRepository.create(userSkill);
      }
    }

    await this.assignVolunteerRoleUseCase.execute(dto.userId);
    return {
      message: 'Profile completed successfully. You can now login.'
    };
  }
}


================================================
FILE: src/application/use-cases/create-user-schedule.use-case.ts
================================================
import { IUserScheduleRepository } from '../../domain/interfaces/user-schedule.repository.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { UserSchedule } from '../../domain/entities/user-schedule.entity';

export class CreateUserScheduleUseCase {
  constructor(
    private readonly userScheduleRepository: IUserScheduleRepository,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(dto: any): Promise<UserSchedule> {
    if (!dto.userId || !dto.startDateTime || !dto.endDateTime) {
      throw new Error('User ID, startDateTime, and endDateTime are required');
    }
    
    const startDateTime = new Date(dto.startDateTime);
    const endDateTime = new Date(dto.endDateTime);
    
    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    if (startDateTime >= endDateTime) {
      throw new Error('Invalid time range: start time must be before end time');
    }

    const conflictingSchedules = await this.userScheduleRepository.findConflicts(
      dto.userId,
      startDateTime,
      endDateTime
    );

    if (conflictingSchedules.length > 0) {
      throw new Error('Schedule conflicts with existing schedules');
    }

    const schedule = new UserSchedule(
      0,
      dto.userId,
      startDateTime,
      endDateTime,
      dto.notes || null,
      dto.eventId || null,
      new Date(),
      new Date(),
      dto.createdBy || null
    );

    return await this.userScheduleRepository.create(schedule);
  }
}


================================================
FILE: src/application/use-cases/delete-user-schedule.use-case.ts
================================================
import { IUserScheduleRepository } from '../../domain/interfaces/user-schedule.repository.interface';

export class DeleteUserScheduleUseCase {
  constructor(
    private readonly userScheduleRepository: IUserScheduleRepository
  ) {}

  async execute(dto: any): Promise<void> {
    if (!dto.scheduleId) {
      throw new Error('Schedule ID is required');
    }
    
    const schedule = await this.userScheduleRepository.findById(dto.scheduleId);
    if (!schedule) {
      throw new Error('Schedule not found');
    }

    await this.userScheduleRepository.delete(dto.scheduleId);
  }
}


================================================
FILE: src/application/use-cases/delete-user.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';

export class DeleteUserUseCase {
  constructor(private readonly userRepository: IUserRepository) {}

  async execute(dto: any): Promise<void> {
    if (!dto.userId) {
      throw new Error('User ID is required');
    }

    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    await this.userRepository.delete(dto.userId);
  }
}


================================================
FILE: src/application/use-cases/get-my-profile.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IUserSkillRepository } from '../../domain/interfaces/user-skill.repository.interface';
import { IUserAvailabilityRepository } from '../../domain/interfaces/user-availability.repository.interface';
import { User } from '../../domain/entities/user.entity';
import { UserSkill } from '../../domain/entities/user-skill.entity';
import { UserAvailability } from '../../domain/entities/user-availability.entity';

export interface FullProfileResponse {
  user: User;
  skills: UserSkill[];
  availability: UserAvailability[];
}

export class GetMyProfileUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly userSkillRepository: IUserSkillRepository,
    private readonly userAvailabilityRepository: IUserAvailabilityRepository
  ) {}

  async execute(userId: number): Promise<FullProfileResponse> {
    if (!userId) {
      throw { http_status: 401, message: 'Unauthorized: User ID missing from token' };
    }

    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw { http_status: 404, message: 'User profile not found' };
    }

    const skills = await this.userSkillRepository.findByUserId(userId);
    const availability = await this.userAvailabilityRepository.findByUserId(userId);

    return {
      user,
      skills,
      availability
    };
  }
}


================================================
FILE: src/application/use-cases/get-nearby-kitchens.use-case.ts
================================================
import axios from 'axios';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';

export class GetNearbyKitchensUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly kitchenServiceUrl: string
  ) {}

  async execute(userId: number): Promise<any> {
    const user = await this.userRepository.findById(userId);
    if (!user || !user.stateId || !user.municipalityId) {
      throw new Error('El usuario no tiene ubicaci√≥n registrada');
    }

    const response = await axios.get(
      `${this.kitchenServiceUrl}/api/kitchens/nearby`,
      {
        params: {
          stateId: user.stateId,
          municipalityId: user.municipalityId
        }
      }
    );

    return response.data;
  }
}



================================================
FILE: src/application/use-cases/get-skills.use-case.ts
================================================
import { ISkillRepository } from '../../domain/interfaces/skill.repository.interface';
import { Skill } from '../../domain/entities/skill.entity';

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export class GetSkillsUseCase {
  constructor(private readonly skillRepository: ISkillRepository) {}

  async execute(dto: any): Promise<PaginatedResult<Skill>> {
    const page = parseInt(dto.page) || 1;
    const limit = parseInt(dto.limit) || 50;
    const search = dto.search;
    const isActive = dto.isActive !== undefined ? (dto.isActive === 'true' || dto.isActive === true) : true;
    
    const result = await this.skillRepository.findPaginated({
      page,
      limit,
      search,
      isActive
    });
    const totalPages = Math.ceil(result.total / limit);

    return {
      data: result.data,
      total: result.total,
      page,
      limit,
      totalPages
    };
  }
}


================================================
FILE: src/application/use-cases/get-user-availability.use-case.ts
================================================
import { IUserAvailabilityRepository } from '../../domain/interfaces/user-availability.repository.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { UserAvailability, DayOfWeek } from '../../domain/entities/user-availability.entity';

export class GetUserAvailabilityUseCase {
  constructor(
    private readonly userAvailabilityRepository: IUserAvailabilityRepository,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(dto: any): Promise<UserAvailability[]> {
    if (!dto.userId) {
      throw new Error('User ID is required');
    }
    
    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    if (dto.dayOfWeek) {
      const validDays = Object.values(DayOfWeek);
      if (!validDays.includes(dto.dayOfWeek)) {
        throw new Error('Invalid dayOfWeek specified');
      }
      return await this.userAvailabilityRepository.findByUserIdAndDay(
        dto.userId,
        dto.dayOfWeek
      );
    }

    return await this.userAvailabilityRepository.findByUserId(dto.userId);
  }
}


================================================
FILE: src/application/use-cases/get-user-by-email.use-case.ts
================================================
import { IUserRepository } from "../../domain/interfaces/user.repository.interface";

export class GetUserByEmailUseCase {
  constructor(private readonly userRepository: IUserRepository) {}

  async execute(email: string) {
    if (!email) {
      throw { http_status: 400, message: "Email is required" };
    }

    const user = await this.userRepository.findByEmail(email);

    if (!user) {
      throw { http_status: 404, message: "User not found" };
    }

    return {
      success: true,
      data: user
    };
  }
}



================================================
FILE: src/application/use-cases/get-user-by-id.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { User } from '../../domain/entities/user.entity';

export class GetUserByIdUseCase {
  constructor(private readonly userRepository: IUserRepository) {}

  async execute(dto: any): Promise<User> {
    if (!dto.userId) {
      throw new Error('User ID is required');
    }
    
    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    return user;
  }
}


================================================
FILE: src/application/use-cases/get-user-permissions.use-case.ts
================================================
import { IPermissionRepository } from '../../domain/interfaces/permission.repository.interface';

export interface UserPermissionsResponse {
  userId: number;
  permissions: {
    id: number;
    module: string;
    action: string;
    resource: string;
    permissionString: string;
  }[];
  totalPermissions: number;
}

export class GetUserPermissionsUseCase {
  constructor(
    private readonly permissionRepository: IPermissionRepository
  ) {}

  async execute(dto: any): Promise<UserPermissionsResponse> {
    if (!dto.userId) {
      throw { http_status: 400, message: 'User ID is required' };
    }

    const permissions = await this.permissionRepository.getUserPermissions(dto.userId);
    const formattedPermissions = permissions.map(permission => ({
      id: permission.id,
      module: permission.module,
      action: permission.action,
      resource: permission.resource,
      permissionString: `${permission.module}:${permission.action}:${permission.resource}`
    }));
    return {
      userId: dto.userId,
      permissions: formattedPermissions,
      totalPermissions: formattedPermissions.length
    };
  }
}


================================================
FILE: src/application/use-cases/get-user-reputation-history.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IUserReputationHistoryRepository } from '../../domain/interfaces/user-reputation-history.repository.interface';
import { UserReputationHistory } from '../../domain/entities/user-reputation-history.entity';

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export class GetUserReputationHistoryUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly reputationHistoryRepository: IUserReputationHistoryRepository
  ) {}

  async execute(dto: any): Promise<PaginatedResult<UserReputationHistory>> {
    if (!dto.userId) {
      throw new Error('User ID is required');
    }
    
    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    const page = parseInt(dto.page) || 1;
    const limit = parseInt(dto.limit) || 20;
    const startDate = dto.startDate ? new Date(dto.startDate) : undefined;
    const endDate = dto.endDate ? new Date(dto.endDate) : undefined;
    
    const result = await this.reputationHistoryRepository.findByUserIdPaginated({
      userId: dto.userId,
      page,
      limit,
      startDate,
      endDate
    });
    const totalPages = Math.ceil(result.total / limit);

    return {
      data: result.data,
      total: result.total,
      page,
      limit,
      totalPages
    };
  }
}


================================================
FILE: src/application/use-cases/get-user-schedules.use-case.ts
================================================
import { IUserScheduleRepository } from '../../domain/interfaces/user-schedule.repository.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { UserSchedule } from '../../domain/entities/user-schedule.entity';

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export class GetUserSchedulesUseCase {
  constructor(
    private readonly userScheduleRepository: IUserScheduleRepository,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(dto: any): Promise<PaginatedResult<UserSchedule>> {
    if (!dto.userId) {
      throw new Error('User ID is required');
    }

    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    const page = parseInt(dto.page) || 1;
    const limit = parseInt(dto.limit) || 20;
    const startDate = dto.startDate ? new Date(dto.startDate) : undefined;
    const endDate = dto.endDate ? new Date(dto.endDate) : undefined;
    const eventId = parseInt(dto.eventId) || undefined;
    
    const result = await this.userScheduleRepository.findByUserIdPaginated({
      userId: dto.userId,
      page,
      limit,
      startDate,
      endDate,
      eventId
    });
    const totalPages = Math.ceil(result.total / limit);

    return {
      data: result.data,
      total: result.total,
      page,
      limit,
      totalPages
    };
  }
}


================================================
FILE: src/application/use-cases/get-user-skills.use-case.ts
================================================
import { IUserSkillRepository } from '../../domain/interfaces/user-skill.repository.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { UserSkill } from '../../domain/entities/user-skill.entity';

export class GetUserSkillsUseCase {
  constructor(
    private readonly userSkillRepository: IUserSkillRepository,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(dto: any): Promise<UserSkill[]> {
    if (!dto.userId) {
      throw new Error('User ID is required');
    }
    
    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    return await this.userSkillRepository.findByUserId(dto.userId);
  }
}


================================================
FILE: src/application/use-cases/get-users-paginated.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { User } from '../../domain/entities/user.entity';

export interface PaginatedResult<T> {
  data: T[];
  total: number;
  page: number;
  limit: number;
  totalPages: number;
}

export class GetUsersPaginatedUseCase {
  constructor(private readonly userRepository: IUserRepository) {}

  async execute(dto: any): Promise<PaginatedResult<User>> {
    const page = parseInt(dto.page) || 1;
    const limit = parseInt(dto.limit) || 10;
    const search = dto.search;
    const status = dto.status;
    const stateId = parseInt(dto.stateId) || undefined;
    const municipalityId = parseInt(dto.municipalityId) || undefined;
    
    const result = await this.userRepository.findPaginated({
      page,
      limit,
      search,
      status,
      stateId,
      municipalityId
    });
    const totalPages = Math.ceil(result.total / limit);

    return {
      data: result.data,
      total: result.total,
      page,
      limit,
      totalPages
    };
  }
}


================================================
FILE: src/application/use-cases/index.ts
================================================
export * from './register-user.use-case';
export * from './login-user.use-case';
export * from './validate-token.use-case';
export * from './refresh-token.use-case';
export * from './verify-email.use-case';
export * from './resend-email-verification.use-case';
export * from './verify-phone.use-case';
export * from './resend-phone-verification.use-case';
export * from './request-password-reset.use-case';
export * from './reset-password.use-case';
export * from './assign-role.use-case';
export * from './remove-role.use-case';
export * from './get-user-permissions.use-case';
export * from './check-user-permission.use-case';
export * from './get-user-by-id.use-case';
export * from './get-users-paginated.use-case';
export { PaginatedResult } from './get-users-paginated.use-case';
export * from './update-user.use-case';
export * from './update-profile.use-case';
export * from './delete-user.use-case';
export * from './get-skills.use-case';
export * from './get-user-skills.use-case';
export * from './add-user-skill.use-case';
export * from './remove-user-skill.use-case';
export * from './set-user-availability.use-case';
export * from './get-user-availability.use-case';
export * from './check-user-availability.use-case';
export * from './create-user-schedule.use-case';
export * from './update-user-schedule.use-case';
export * from './delete-user-schedule.use-case';
export * from './get-user-schedules.use-case';
export * from './update-user-reputation.use-case';
export * from './get-user-reputation-history.use-case';
export * from './assign-volunteer-role.use-case';
export * from './complete-profile.use-case';
export * from './register-admin-kitchen.use-case';
export * from './get-user-by-email.use-case'



================================================
FILE: src/application/use-cases/login-user.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IPasswordHasher } from '../../domain/interfaces/password-hasher.interface';
import { ITokenGenerator } from '../../domain/interfaces/token-generator.interface';
import { IRoleRepository } from '../../domain/interfaces/role.repository.interface';
import { UserStatus } from '../../domain/entities/user.entity';

export interface LoginUserResponse {
  user: {
    id: number;
    email: string;
    names: string;
    fullName: string;
    status: UserStatus;
    verifiedEmail: boolean;
    verifiedPhone: boolean;
    stateId: number | null;
    municipalityId: number | null;
  };
  accessToken: string;
  refreshToken: string;
  roles: string[];
}

export class LoginUserUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly roleRepository: IRoleRepository,
    private readonly passwordHasher: IPasswordHasher,
    private readonly tokenGenerator: ITokenGenerator
  ) {}

  async execute(dto: any): Promise<LoginUserResponse> {
    const user = await this.userRepository.findByEmail(dto.email.toLowerCase());
    if (!user) {
      throw { http_status: 401, message: 'Invalid credentials' };
    }

    const isPasswordValid = await this.passwordHasher.compare(dto.password, user.passwordHash);
    if (!isPasswordValid) {
      throw { http_status: 401, message: 'Invalid credentials' };
    }

    if (user.status === UserStatus.SUSPENDED) {
      throw { http_status: 403, message: 'Account suspended. Please contact support.' };
    }

    if (user.status === UserStatus.INACTIVE) {
      throw { http_status: 403, message: 'Account inactive. Please contact support.' };
    }

    const roles = await this.roleRepository.getUserRoles(user.id);
    const roleNames = roles.map((role) => role.name);

    const stateId = user.stateId ?? null;
    const municipalityId = user.municipalityId ?? null;

    const accessToken = this.tokenGenerator.generateAccessToken(
      user.id,
      user.email,
      roleNames,
      stateId,
      municipalityId
    );

    const refreshToken = this.tokenGenerator.generateRefreshToken(user.id);

    return {
      user: {
        id: user.id,
        email: user.email,
        names: user.names,
        fullName: `${user.names} ${user.firstLastName} ${user.secondLastName}`,
        status: user.status,
        verifiedEmail: user.verifiedEmail,
        verifiedPhone: user.verifiedPhone,
        stateId,
        municipalityId
      },
      accessToken,
      refreshToken,
      roles: roleNames
    };
  }
}



================================================
FILE: src/application/use-cases/refresh-token.use-case.ts
================================================
import { ITokenGenerator } from '../../domain/interfaces/token-generator.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IRoleRepository } from '../../domain/interfaces/role.repository.interface';

export interface RefreshTokenResponse {
  accessToken: string;
  refreshToken: string;
}

export class RefreshTokenUseCase {
  constructor(
    private readonly tokenGenerator: ITokenGenerator,
    private readonly userRepository: IUserRepository,
    private readonly roleRepository: IRoleRepository
  ) {}

  async execute(dto: any): Promise<RefreshTokenResponse> {
    if (!dto.refreshToken) {
      throw { http_status: 400, message: 'Refresh token is required' };
    }

    try {
      const payload = this.tokenGenerator.verifyRefreshToken(dto.refreshToken);
      const user = await this.userRepository.findById(payload.userId);

      if (!user) {
        throw {
          http_status: 401,
          message: 'Invalid refresh token'
        };
      }

      if (user.status !== 'active') {
        throw {
          http_status: 403,
          message: 'User account is not active'
        };
      }

      const roles = await this.roleRepository.getUserRoles(user.id);
      const roleNames = roles.map(role => role.name);
      const accessToken = this.tokenGenerator.generateAccessToken(
        user.id,
        user.email,
        roleNames
      );
      const refreshToken = this.tokenGenerator.generateRefreshToken(user.id);

      return {
        accessToken,
        refreshToken
      };
    } catch (error) {
      throw {
        http_status: 401,
        message: 'Invalid or expired refresh token'
      };
    }
  }
}


================================================
FILE: src/application/use-cases/register-admin-kitchen.use-case.ts
================================================
import { IUserRepository } from "../../domain/interfaces/user.repository.interface";
import { IRoleRepository } from "../../domain/interfaces/role.repository.interface";
import { User, UserStatus } from "../../domain/entities/user.entity";
import { BcryptPasswordHasherService } from "../../services/bcrypt-password-hasher.service";

export class RegisterAdminKitchenUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly roleRepository: IRoleRepository,
    private readonly hasher: BcryptPasswordHasherService
  ) {}

  async execute(data: any) {
    const { names, firstLastName, secondLastName, email, phoneNumber, password } = data;

    if (!names || !firstLastName || !email || !phoneNumber || !password) {
      throw { http_status: 400, message: "Missing required fields" };
    }

    const exists = await this.userRepository.findByEmail(email);
    if (exists) throw { http_status: 409, message: "Email already registered" };

    const passwordHash = await this.hasher.hash(password);

    const user = new User(
      0,
      names,
      firstLastName,
      secondLastName ?? "",
      email,
      passwordHash,
      null,
      phoneNumber,
      0,
      null,
      UserStatus.ACTIVE,
      true,
      true,
      new Date(),
      new Date(),
      null,
      null,
      new Date(),
      new Date(),
      null
    );

    const newUser = await this.userRepository.save(user);

    const role = await this.roleRepository.findByName("Admin_cocina");
    if (!role) {
      throw { http_status: 404, message: "Role 'Admin_cocina' not found" };
    }
    await this.roleRepository.assignRoleToUser(newUser.id, role.id);

    return { success: true };
  }
}


================================================
FILE: src/application/use-cases/register-user.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IPasswordHasher } from '../../domain/interfaces/password-hasher.interface';
import { IEventPublisher } from '../../domain/interfaces/event-publisher.interface';
import { User, UserStatus } from '../../domain/entities/user.entity';
import { UserValidator } from '../../domain/validators/user.validator';
import { PasswordStrengthValidator } from '../../domain/validators/password-strength.validator';
import { IRoleRepository } from '../../domain/interfaces/role.repository.interface';
import { IUserSkillRepository } from '../../domain/interfaces/user-skill.repository.interface';
import { ISkillRepository } from '../../domain/interfaces/skill.repository.interface';
import { IUserAvailabilityRepository } from '../../domain/interfaces/user-availability.repository.interface';
import { UserSkill } from '../../domain/entities/user-skill.entity';
import { UserAvailability } from '../../domain/entities/user-availability.entity';

export class RegisterUserUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly passwordHasher: IPasswordHasher,
    private readonly eventPublisher: IEventPublisher,
    private readonly roleRepository: IRoleRepository,
    private readonly userSkillRepository: IUserSkillRepository,
    private readonly skillRepository: ISkillRepository,
    private readonly userAvailabilityRepository: IUserAvailabilityRepository
  ) {}

  async execute(dto: any): Promise<{
    message: string;
    user: User;
  }> {
    const existingUser = await this.userRepository.findByEmail(dto.email);
    if (existingUser) {
      throw {
        http_status: 409,
        message: 'Email already registered'
      };
    }

    const passwordValidator = new PasswordStrengthValidator(dto.password);
    await passwordValidator.validate();

    const hashedPassword = await this.passwordHasher.hash(dto.password);
    const newUser = new User(
      0,
      dto.names,
      dto.firstLastName,
      dto.secondLastName,
      dto.email,
      hashedPassword,
      null,
      dto.phoneNumber || null,
      0,
      null,
      UserStatus.ACTIVE,
      false, 
      false,
      null,
      null,
      dto.stateId,
      dto.municipalityId,
      new Date(),
      new Date(),
      null
    );
    const userValidator = new UserValidator(newUser);
    await userValidator.validateWithCustomRules();

    const savedUser = await this.userRepository.save(newUser);

    const volunteerRole = await this.roleRepository.findByName('Voluntario');
    if (!volunteerRole) {
       throw {
        http_status: 500,
        message: 'Volunteer role not found in system. Please contact administrator.'
      };
    }
    await this.roleRepository.assignRoleToUser(savedUser.id, volunteerRole.id!);

    if (dto.skillIds && dto.skillIds.length > 0) {
      for (const skillId of dto.skillIds) {
        const skill = await this.skillRepository.findById(skillId);
        if (!skill || !skill.isActive) {
          throw { http_status: 400, message: `Skill with ID ${skillId} not found or is inactive` };
        }

        const userSkill = new UserSkill(
          0, savedUser.id, skillId, null, null, new Date(), new Date()
        );
        await this.userSkillRepository.create(userSkill);
      }
    }

    if (dto.availabilitySlots && dto.availabilitySlots.length > 0) {
      for (const slot of dto.availabilitySlots) {
        const availability = new UserAvailability(
          0, savedUser.id, slot.dayOfWeek, slot.startTime, slot.endTime, new Date(), new Date()
        );
        await this.userAvailabilityRepository.create(availability);
      }
    }

    await this.eventPublisher.publish('user.registered', {
      userId: savedUser.id,
      email: savedUser.email,
      names: savedUser.names,
      timestamp: new Date().toISOString()
    });
    return {
      message: 'User registered successfully. You can now login.',
      user: savedUser
    };
  }
}


================================================
FILE: src/application/use-cases/remove-role.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IRoleRepository } from '../../domain/interfaces/role.repository.interface';
import { IEventPublisher } from '../../domain/interfaces/event-publisher.interface';

export class RemoveRoleUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly roleRepository: IRoleRepository,
    private readonly eventPublisher: IEventPublisher
  ) {}

  async execute(dto: any): Promise<{ message: string }> {
    if (!dto.userId || !dto.roleId) {
      throw { http_status: 400, message: 'User ID and Role ID are required' };
    }
    
    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw {
        http_status: 404,
        message: 'User not found'
      };
    }

    const role = await this.roleRepository.findById(dto.roleId);

    if (!role) {
      throw {
        http_status: 404,
        message: 'Role not found'
      };
    }

    const userRoles = await this.roleRepository.getUserRoles(dto.userId);
    const hasRole = userRoles.some(r => r.id === dto.roleId);
    if (!hasRole) {
      throw {
        http_status: 400,
        message: 'User does not have this role'
      };
    }

    if (userRoles.length === 1) {
      throw {
        http_status: 400,
        message: 'Cannot remove the only role from user'
      };
    }

    await this.roleRepository.removeRoleFromUser(dto.userId, dto.roleId);

    await this.eventPublisher.publish('user.role.removed', {
      userId: dto.userId,
      roleId: dto.roleId,
      roleName: role.name,
      timestamp: new Date().toISOString()
    });
    return {
      message: `Role '${role.name}' removed successfully from user`
    };
  }
}


================================================
FILE: src/application/use-cases/remove-user-skill.use-case.ts
================================================
import { IUserSkillRepository } from '../../domain/interfaces/user-skill.repository.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';

export class RemoveUserSkillUseCase {
  constructor(
    private readonly userSkillRepository: IUserSkillRepository,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(dto: any): Promise<void> {
    if (!dto.userId || !dto.skillId) {
      throw new Error('User ID and Skill ID are required');
    }
    
    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    const userSkill = await this.userSkillRepository.findByUserIdAndSkillId(
      dto.userId,
      dto.skillId
    );
    if (!userSkill) {
      throw new Error('User does not have this skill');
    }

    await this.userSkillRepository.delete(userSkill.id);
  }
}


================================================
FILE: src/application/use-cases/request-password-reset.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IPasswordResetTokenRepository } from '../../domain/interfaces/password-reset-token.repository.interface';
import { ITokenGenerator } from '../../domain/interfaces/token-generator.interface';
import { IEventPublisher } from '../../domain/interfaces/event-publisher.interface';
import { PasswordResetToken } from '../../domain/entities/password-reset-token.entity';

export class RequestPasswordResetUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly passwordResetTokenRepository: IPasswordResetTokenRepository,
    private readonly tokenGenerator: ITokenGenerator,
    private readonly eventPublisher: IEventPublisher
  ) {}

  async execute(dto: any): Promise<{ message: string }> {
    if (!dto.email) {
      throw { http_status: 400, message: 'Email is required' };
    }
    
    const user = await this.userRepository.findByEmail(dto.email.toLowerCase());
    if (!user) {
      return {
        message: 'If the email exists, a password reset link will be sent.'
      };
    }

    await this.passwordResetTokenRepository.invalidateAllByUserId(user.id);

    const resetToken = this.tokenGenerator.generateRandomToken();
    const passwordResetToken = new PasswordResetToken(
      0,
      user.id,
      resetToken,
      new Date(Date.now() + 60 * 60 * 1000), 
      false,
      new Date(),
      null
    );
    await this.passwordResetTokenRepository.save(passwordResetToken);

    await this.eventPublisher.publish('user.password.reset.requested', {
      userId: user.id,
      email: user.email,
      resetToken,
      timestamp: new Date().toISOString()
    });
    return {
      message: 'If the email exists, a password reset link will be sent.'
    };
  }
}


================================================
FILE: src/application/use-cases/resend-email-verification.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IEmailVerificationRepository } from '../../domain/interfaces/email-verification.repository.interface';
import { ITokenGenerator } from '../../domain/interfaces/token-generator.interface';
import { IEventPublisher } from '../../domain/interfaces/event-publisher.interface';
import { EmailVerification } from '../../domain/entities/email-verification.entity';

export class ResendEmailVerificationUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly emailVerificationRepository: IEmailVerificationRepository,
    private readonly tokenGenerator: ITokenGenerator,
    private readonly eventPublisher: IEventPublisher
  ) {}

  async execute(dto: any): Promise<{ message: string }> {
    if (!dto.email) {
       throw { http_status: 400, message: 'Email is required' };
    }

    const user = await this.userRepository.findByEmail(dto.email.toLowerCase());
    if (!user) {
      return {
        message: 'If the email exists, a verification link will be sent.'
      };
    }

    if (user.verifiedEmail) {
      throw {
        http_status: 400,
        message: 'Email is already verified'
      };
    }

    const lastVerification = await this.emailVerificationRepository.findLatestByUserId(user.id);

    if (lastVerification) {
      const timeSinceLastSent = Date.now() - lastVerification.createdAt.getTime();
      const oneMinute = 60 * 1000;

      if (timeSinceLastSent < oneMinute) {
        throw {
          http_status: 429,
          message: 'Please wait before requesting a new verification email'
        };
      }
    }

    const verificationToken = this.tokenGenerator.generateRandomToken();
    const emailVerification = new EmailVerification(
      0,
      user.id,
      verificationToken,
      new Date(Date.now() + 24 * 60 * 60 * 1000), 
      false,
      new Date(),
      null
    );
    await this.emailVerificationRepository.save(emailVerification);

    await this.eventPublisher.publish('user.email.verification.resent', {
      userId: user.id,
      email: user.email,
      verificationToken,
      timestamp: new Date().toISOString()
    });
    return {
      message: 'If the email exists, a verification link will be sent.'
    };
  }
}


================================================
FILE: src/application/use-cases/resend-phone-verification.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IPhoneVerificationRepository } from '../../domain/interfaces/phone-verification.repository.interface';
import { ITokenGenerator } from '../../domain/interfaces/token-generator.interface';
import { IEventPublisher } from '../../domain/interfaces/event-publisher.interface';
import { PhoneVerification } from '../../domain/entities/phone-verification.entity';

export class ResendPhoneVerificationUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly phoneVerificationRepository: IPhoneVerificationRepository,
    private readonly tokenGenerator: ITokenGenerator,
    private readonly eventPublisher: IEventPublisher
  ) {}

  async execute(dto: any): Promise<{ message: string; code?: string }> {
    if (!dto.userId) {
      throw { http_status: 400, message: 'User ID is required' };
    }
    
    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw {
        http_status: 404,
        message: 'User not found'
      };
    }

    if (user.verifiedPhone) {
      throw {
        http_status: 400,
        message: 'Phone number is already verified'
      };
    }

    if (!user.phoneNumber) {
      throw {
        http_status: 400,
        message: 'User does not have a phone number'
      };
    }

    const lastVerification = await this.phoneVerificationRepository.findLatestByUserId(user.id);

    if (lastVerification) {
      const timeSinceLastSent = Date.now() - lastVerification.createdAt.getTime();
      const twoMinutes = 2 * 60 * 1000;

      if (timeSinceLastSent < twoMinutes) {
        throw {
          http_status: 429,
          message: 'Please wait before requesting a new verification code'
        };
      }
    }

    const verificationCode = this.tokenGenerator.generateNumericCode(6);
    const phoneVerification = new PhoneVerification(
      0,
      user.id,
      verificationCode,
      new Date(Date.now() + 10 * 60 * 1000), 
      false,
      0,
      new Date(),
      null
    );
    await this.phoneVerificationRepository.save(phoneVerification);

    await this.eventPublisher.publish('user.phone.verification.resent', {
      userId: user.id,
      phoneNumber: user.phoneNumber,
      verificationCode,
      timestamp: new Date().toISOString()
    });
    const isDevelopment = process.env.NODE_ENV === 'development';

    return {
      message: 'Verification code sent to your phone',
      ...(isDevelopment && { code: verificationCode })
    };
  }
}


================================================
FILE: src/application/use-cases/reset-password.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IPasswordResetTokenRepository } from '../../domain/interfaces/password-reset-token.repository.interface';
import { IPasswordHasher } from '../../domain/interfaces/password-hasher.interface';
import { IEventPublisher } from '../../domain/interfaces/event-publisher.interface';
import { PasswordResetTokenValidator } from '../../domain/validators/password-reset-token.validator';
import { PasswordStrengthValidator } from '../../domain/validators/password-strength.validator';

export class ResetPasswordUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly passwordResetTokenRepository: IPasswordResetTokenRepository,
    private readonly passwordHasher: IPasswordHasher,
    private readonly eventPublisher: IEventPublisher
  ) {}

  async execute(dto: any): Promise<{ message: string }> {
    if (!dto.token || !dto.newPassword) {
      throw { http_status: 400, message: 'Token and new password are required' };
    }
    
    const resetToken = await this.passwordResetTokenRepository.findByToken(dto.token);
    if (!resetToken) {
      throw {
        http_status: 404,
        message: 'Invalid or expired password reset token'
      };
    }

    const validator = new PasswordResetTokenValidator(resetToken);
    await validator.validateWithCustomRules();

    const passwordValidator = new PasswordStrengthValidator(dto.newPassword);
    await passwordValidator.validate();

    const user = await this.userRepository.findById(resetToken.userId);
    if (!user) {
      throw {
        http_status: 404,
        message: 'User not found'
      };
    }

    const hashedPassword = await this.passwordHasher.hash(dto.newPassword);

    user.passwordHash = hashedPassword;
    user.updatedAt = new Date();
    await this.userRepository.update(user);
    
    resetToken.isUsed = true;
    resetToken.usedAt = new Date();
    await this.passwordResetTokenRepository.update(resetToken.id, resetToken);
    
    await this.eventPublisher.publish('user.password.reset.completed', {
      userId: user.id,
      email: user.email,
      timestamp: new Date().toISOString()
    });
    return {
      message: 'Password reset successfully'
    };
  }
}


================================================
FILE: src/application/use-cases/set-user-availability.use-case.ts
================================================
import { IUserAvailabilityRepository } from '../../domain/interfaces/user-availability.repository.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { DayOfWeek, UserAvailability } from '../../domain/entities/user-availability.entity';

export class SetUserAvailabilityUseCase {
  constructor(
    private readonly userAvailabilityRepository: IUserAvailabilityRepository,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(dto: any): Promise<{
    message: string;
    userId: number;
    updatedSlots: UserAvailability[];
  }> {
    if (!dto.userId || !Array.isArray(dto.availabilitySlots)) {
      throw new Error('User ID and valid availabilitySlots array are required');
    }

    const user = await this.userRepository.findById(dto.userId);
    if (!user) throw new Error('User not found');

    const currentAvailabilities = await this.userAvailabilityRepository.findByUserId(dto.userId);

    const incomingMap = new Map(
      dto.availabilitySlots.map((slot: any) => [slot.dayOfWeek, slot])
    );

    const updatedSlots: UserAvailability[] = [];

    currentAvailabilities.forEach(existing => {
        if (incomingMap.has(existing.dayOfWeek)) {
            incomingMap.delete(existing.dayOfWeek); 
        }
        updatedSlots.push(existing); 
    });

    for (const [dayOfWeek, slot] of incomingMap.entries()) {
      
      const typedSlot = slot as { startTime: string; endTime: string };
      
      const newAvailability = new UserAvailability(
        0,
        dto.userId,
        dayOfWeek as DayOfWeek, 
        typedSlot.startTime,
        typedSlot.endTime,
        new Date(),
        new Date()
      );

      const created = await this.userAvailabilityRepository.create(newAvailability);
      updatedSlots.push(created);
    }

    return {
      message: 'Disponibilidad actualizada correctamente',
      userId: dto.userId,
      updatedSlots
    };
  }
}


================================================
FILE: src/application/use-cases/update-profile.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { User } from '../../domain/entities/user.entity';

export class UpdateProfileUseCase {
  constructor(private readonly userRepository: IUserRepository) {}

  async execute(userId: number, dto: any): Promise<User> {
    if (!userId) {
      throw new Error('Authentication User ID is required');
    }
    
    const user = await this.userRepository.findById(userId);
    if (!user) {
      throw new Error('User not found');
    }

    if (dto.names !== undefined) user.names = dto.names;
    if (dto.firstLastName !== undefined) user.firstLastName = dto.firstLastName;
    if (dto.secondLastName !== undefined) user.secondLastName = dto.secondLastName;
    if (dto.phoneNumber !== undefined) user.phoneNumber = dto.phoneNumber;
    if (dto.imageProfile !== undefined) user.imageProfile = dto.imageProfile;
    if (dto.stateId !== undefined) user.stateId = dto.stateId;
    if (dto.municipalityId !== undefined) user.municipalityId = dto.municipalityId;

    user.updatedAt = new Date();

    return await this.userRepository.update(user);
  }
}


================================================
FILE: src/application/use-cases/update-user-availability.use-case.ts
================================================
import { IUserAvailabilityRepository } from '../../domain/interfaces/user-availability.repository.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { UserAvailability, DayOfWeek } from '../../domain/entities/user-availability.entity';

export class UpdateUserAvailabilityUseCase {
  constructor(
    private readonly userAvailabilityRepository: IUserAvailabilityRepository,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(dto: {
    userId: number;
    dayOfWeek: DayOfWeek;
    startTime: string;
    endTime: string;
  }): Promise<UserAvailability> {
    if (!dto.userId || !dto.dayOfWeek || !dto.startTime || !dto.endTime) {
      throw new Error('User ID, dayOfWeek, startTime, and endTime are required');
    }

    const user = await this.userRepository.findById(dto.userId);
    if (!user) throw new Error('User not found');

    if (dto.startTime >= dto.endTime) {
      throw new Error('Invalid time range: start time must be before end time');
    }

    const existing = await this.userAvailabilityRepository.findByUserIdAndDay(
      dto.userId,
      dto.dayOfWeek
    );

    if (existing.length === 0) {
      throw new Error(`No existing availability found for ${dto.dayOfWeek}`);
    }

    const updatedAvailability = new UserAvailability(
      existing[0].id,
      dto.userId,
      dto.dayOfWeek,
      dto.startTime,
      dto.endTime,
      existing[0].createdAt,
      new Date()
    );

    return await this.userAvailabilityRepository.update(updatedAvailability);
  }
}



================================================
FILE: src/application/use-cases/update-user-reputation.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IUserReputationHistoryRepository } from '../../domain/interfaces/user-reputation-history.repository.interface';
import { UserReputationHistory } from '../../domain/entities/user-reputation-history.entity';

export class UpdateUserReputationUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly reputationHistoryRepository: IUserReputationHistoryRepository
  ) {}

  async execute(dto: any): Promise<UserReputationHistory> {
    if (!dto.userId || dto.changeAmount === undefined || !dto.reason) {
      throw new Error('User ID, changeAmount, and reason are required');
    }
    
    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }

    const previousScore = user.reputationScore;
    const changeAmount = parseInt(dto.changeAmount);
    
    if (isNaN(changeAmount) || changeAmount < -100 || changeAmount > 100) {
        throw new Error('changeAmount must be a number between -100 and 100');
    }

    let newScore = previousScore + changeAmount;
    if (newScore < 0) newScore = 0;
    if (newScore > 100) newScore = 100;

    user.reputationScore = newScore;
    user.updatedAt = new Date();
    await this.userRepository.update(user);

    const historyEntry = new UserReputationHistory(
      0,
      dto.userId,
      changeAmount,
      previousScore,
      newScore,
      dto.reason,
      dto.details || null,
      dto.relatedEventId || null,
      new Date(),
      dto.createdBy || null
    );
    return await this.reputationHistoryRepository.create(historyEntry);
  }
}


================================================
FILE: src/application/use-cases/update-user-schedule.use-case.ts
================================================
import { IUserScheduleRepository } from '../../domain/interfaces/user-schedule.repository.interface';
import { UserSchedule } from '../../domain/entities/user-schedule.entity';

export class UpdateUserScheduleUseCase {
  constructor(
    private readonly userScheduleRepository: IUserScheduleRepository
  ) {}

  async execute(dto: any): Promise<UserSchedule> {
    if (!dto.scheduleId) {
      throw new Error('Schedule ID is required');
    }
    
    const schedule = await this.userScheduleRepository.findById(dto.scheduleId);
    if (!schedule) {
      throw new Error('Schedule not found');
    }

    const updatedStartDateTime = dto.startDateTime ? new Date(dto.startDateTime) : schedule.startDateTime;
    const updatedEndDateTime = dto.endDateTime ? new Date(dto.endDateTime) : schedule.endDateTime;
    
    if (updatedStartDateTime >= updatedEndDateTime) {
      throw new Error('Invalid time range: start time must be before end time');
    }

    const excludeId = parseInt(dto.scheduleId);
    
    const conflictingSchedules = await this.userScheduleRepository.findConflictsExcluding(
      schedule.userId,
      updatedStartDateTime,
      updatedEndDateTime,
      excludeId
    );
    if (conflictingSchedules.length > 0) {
      throw new Error('Schedule conflicts with existing schedules');
    }

    if (dto.startDateTime !== undefined) schedule.startDateTime = updatedStartDateTime;
    if (dto.endDateTime !== undefined) schedule.endDateTime = updatedEndDateTime;
    if (dto.notes !== undefined) schedule.notes = dto.notes;
    if (dto.eventId !== undefined) schedule.eventId = dto.eventId;

    schedule.updatedAt = new Date();
    return await this.userScheduleRepository.update(schedule);
  }
}


================================================
FILE: src/application/use-cases/update-user.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { User } from '../../domain/entities/user.entity';

export class UpdateUserUseCase {
  constructor(private readonly userRepository: IUserRepository) {}

  async execute(dto: any): Promise<User> {
    if (!dto.userId) {
      throw new Error('User ID is required');
    }
    
    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw new Error('User not found');
    }
    if (dto.email && dto.email !== user.email) {
      const existingUser = await this.userRepository.findByEmail(dto.email);
      if (existingUser) {
        throw new Error('Email already in use');
      }
    }

    if (dto.names !== undefined) user.names = dto.names;
    if (dto.firstLastName !== undefined) user.firstLastName = dto.firstLastName;
    if (dto.secondLastName !== undefined) user.secondLastName = dto.secondLastName;
    if (dto.email !== undefined) user.email = dto.email;
    if (dto.phoneNumber !== undefined) user.phoneNumber = dto.phoneNumber;
    if (dto.imageProfile !== undefined) user.imageProfile = dto.imageProfile;
    if (dto.status !== undefined) user.status = dto.status;
    if (dto.reputationScore !== undefined) user.reputationScore = dto.reputationScore;
    if (dto.stateId !== undefined) user.stateId = dto.stateId;
    if (dto.municipalityId !== undefined) user.municipalityId = dto.municipalityId;

    user.updatedAt = new Date();

    return await this.userRepository.update(user);
  }
}


================================================
FILE: src/application/use-cases/validate-token.use-case.ts
================================================
import { ITokenGenerator, TokenPayload } from '../../domain/interfaces/token-generator.interface';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface'

export interface ValidateTokenResponse {
  isValid: boolean;
  user?: {
    id: number;
    email: string;
    roles?: string[];
  };
}

export class ValidateTokenUseCase {
  constructor(
    private readonly tokenGenerator: ITokenGenerator,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(dto: any): Promise<ValidateTokenResponse> {
    if (!dto.token) {
      return { isValid: false };
    }
    
    try {
      const payload: TokenPayload = this.tokenGenerator.verifyAccessToken(dto.token);
      const user = await this.userRepository.findById(payload.userId);

      if (!user) {
        return { isValid: false };
      }

      if (user.status !== 'active') {
        return { isValid: false };
      }

      return {
        isValid: true,
        user: {
          id: user.id,
          email: user.email,
          roles: payload.roles
        }
      };
    } catch (error) {
      return { isValid: false };
    }
  }
}


================================================
FILE: src/application/use-cases/verify-email.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IEmailVerificationRepository } from '../../domain/interfaces/email-verification.repository.interface';
import { IEventPublisher } from '../../domain/interfaces/event-publisher.interface';
import { EmailVerificationValidator } from '../../domain/validators/email-verification.validator';

export class VerifyEmailUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly emailVerificationRepository: IEmailVerificationRepository,
    private readonly eventPublisher: IEventPublisher
  ) {}

  async execute(dto: any): Promise<{ message: string }> {
    if (!dto.token) {
      throw { http_status: 400, message: 'Token is required' };
    }
    
    const verification = await this.emailVerificationRepository.findByToken(dto.token);
    if (!verification) {
      throw {
        http_status: 404,
        message: 'Invalid verification token'
      };
    }

    const validator = new EmailVerificationValidator(verification);
    await validator.validateWithCustomRules();

    const user = await this.userRepository.findById(verification.userId);
    if (!user) {
      throw {
        http_status: 404,
        message: 'User not found'
      };
    }

    if (user.verifiedEmail) {
      throw {
        http_status: 400,
        message: 'Email already verified'
      };
    }

    user.verifiedEmail = true;
    user.emailVerifiedAt = new Date(); 
    user.updatedAt = new Date();

    await this.userRepository.update(user); 

    verification.isUsed = true;
    verification.usedAt = new Date();
    await this.emailVerificationRepository.update(verification.id, verification);

    await this.eventPublisher.publish('user.email.verified', {
      userId: user.id,
      email: user.email,
      timestamp: new Date().toISOString()
    });
    return {
      message: 'Email verified successfully'
    };
  }
}


================================================
FILE: src/application/use-cases/verify-phone.use-case.ts
================================================
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { IPhoneVerificationRepository } from '../../domain/interfaces/phone-verification.repository.interface';
import { IEventPublisher } from '../../domain/interfaces/event-publisher.interface';
import { PhoneVerificationValidator } from '../../domain/validators/phone-verification.validator';

export class VerifyPhoneUseCase {
  constructor(
    private readonly userRepository: IUserRepository,
    private readonly phoneVerificationRepository: IPhoneVerificationRepository,
    private readonly eventPublisher: IEventPublisher
  ) {}

  async execute(dto: any): Promise<{ message: string }> {
    if (!dto.userId || !dto.code) {
      throw { http_status: 400, message: 'User ID and code are required' };
    }
    
    const verification = await this.phoneVerificationRepository.findLatestByUserId(dto.userId);
    if (!verification) {
      throw {
        http_status: 404,
        message: 'No verification code found. Please request a new one.'
      };
    }

    const validator = new PhoneVerificationValidator(verification);
    await validator.validateWithCustomRules();

    verification.attempts += 1;
    await this.phoneVerificationRepository.update(verification.id, verification);

    if (verification.code !== dto.code) {
      const remainingAttempts = validator.getRemainingAttempts();
      throw {
        http_status: 400,
        message: `Invalid verification code. ${remainingAttempts} attempts remaining.`
      };
    }

    const user = await this.userRepository.findById(dto.userId);
    if (!user) {
      throw {
        http_status: 404,
        message: 'User not found'
      };
    }

    user.verifiedPhone = true;
    user.phoneVerifiedAt = new Date(); 
    user.updatedAt = new Date();

    await this.userRepository.update(user);

    verification.isUsed = true;
    verification.usedAt = new Date();
    await this.phoneVerificationRepository.update(verification.id, verification);

    await this.eventPublisher.publish('user.phone.verified', {
      userId: user.id,
      phoneNumber: user.phoneNumber,
      timestamp: new Date().toISOString()
    });
    return {
      message: 'Phone number verified successfully'
    };
  }
}


================================================
FILE: src/config/data-source.ts
================================================
import { DataSource } from 'typeorm';
import { databaseConfig } from './database.config';

export const AppDataSource = new DataSource({
  ...databaseConfig,
  type: 'postgres',
  entities: [
    __dirname + '/../database/schemas/**/*.ts',
    __dirname + '/../database/schemas/**/*.js'
  ],
  migrations: [
    __dirname + '/../database/migrations/**/*.ts',
    __dirname + '/../database/migrations/**/*.js'
  ]
});

export const initializeDatabase = async (): Promise<void> => {
  try {
    if (!AppDataSource.isInitialized) {
      await AppDataSource.initialize();
      console.log('‚úÖ Database connection established successfully');
    }
  } catch (error) {
    console.error('‚ùå Error connecting to database:', error);
    throw error;
  }
};

export const closeDatabase = async (): Promise<void> => {
  try {
    if (AppDataSource.isInitialized) {
      await AppDataSource.destroy();
      console.log('‚úÖ Database connection closed successfully');
    }
  } catch (error) {
    console.error('‚ùå Error closing database connection:', error);
    throw error;
  }
};


================================================
FILE: src/config/database.config.ts
================================================
import { config } from 'dotenv';

config();

export const databaseConfig = {
    type: 'postgres' as const,
    host: process.env.DB_HOST || 'localhost',
    port: parseInt(process.env.DB_PORT || '3306'),
    username: process.env.DB_USERNAME || 'root',
    password: process.env.DB_PASSWORD || 'password',
    database: process.env.DB_DATABASE || 'auth_db',
    synchronize: process.env.DB_SYNCHRONIZE === 'true',
    logging: process.env.DB_LOGGING === 'true',
    ssl: {
        rejectUnauthorized: false
    },
    charset: 'utf8mb4',
    timezone: 'Z',
    entities: ['src/database/schemas/**/*.ts'],
    migrations: ['src/database/migrations/**/*.ts'],
    subscribers: [],
};


================================================
FILE: src/config/rabbitmq.config.ts
================================================
import { config } from 'dotenv';

config();

export const rabbitmqConfig = {
  url: process.env.RABBITMQ_URL || '',
  exchange: process.env.RABBITMQ_EXCHANGE || '',
  exchangeType: 'topic' as const,
  queues: {
    auth: process.env.RABBITMQ_QUEUE_AUTH || '',
    emailVerification: 'email_verification_queue',
    phoneVerification: 'phone_verification_queue',
    passwordReset: 'password_reset_queue'
  },
  routingKeys: {
    userRegistered: 'user.registered',
    userEmailVerified: 'user.email.verified',
    userPhoneVerified: 'user.phone.verified',
    passwordResetRequested: 'user.password.reset.requested',
    passwordResetCompleted: 'user.password.reset.completed',
    roleAssigned: 'user.role.assigned',
    roleRemoved: 'user.role.removed',
    kitchenAdminRegistered: 'kitchen.admin.registered'
  },
  options: {
    durable: true,
    persistent: true,
    prefetch: 10
  }
};


================================================
FILE: src/config/seed/seed.ts
================================================
import { AppDataSource } from '../data-source';
import { RoleSchema } from '../../database/schemas/role.schema';
import { SkillSchema } from '../../database/schemas/skill.schema';
import { UserSchema, UserStatus } from '../../database/schemas/user.schema';
import { UserRoleSchema } from '../../database/schemas/user-role.schema';
import { BcryptPasswordHasherService } from '../../services/bcrypt-password-hasher.service';


const seedRoles = async () => {
  const roleRepository = AppDataSource.getRepository(RoleSchema);
  const rolesToSeed = [
    { name: 'Voluntario', description: 'Rol b√°sico para voluntarios.', level: 1 },
    { name: 'Admin_cocina', description: 'Administrador de cocina.', level: 2 },
    { name: 'Super_admin', description: 'Administrador total del sistema.', level: 3 },
  ];
  for (const roleData of rolesToSeed) {
    const roleExists = await roleRepository.findOne({
      where: { name: roleData.name },
    });
    if (!roleExists) {
      console.log(`Creando rol: ${roleData.name}`);
      const newRole = roleRepository.create(roleData);
      await roleRepository.save(newRole);
    }
  }
};


const seedSuperAdmin = async () => {
  const userRepository = AppDataSource.getRepository(UserSchema);
  const roleRepository = AppDataSource.getRepository(RoleSchema);
  const userRoleRepository = AppDataSource.getRepository(UserRoleSchema);
  const passwordHasher = new BcryptPasswordHasherService();

  const SUPER_ADMIN_EMAIL = 'superadmin@bi.com';
  const DEFAULT_PASSWORD = 'Super@dm1n2025!';
  
  const superAdminRole = await roleRepository.findOne({ where: { name: 'Super_admin' } });
  if (!superAdminRole) {
    console.error('‚ùå Error: El rol Super_admin no existe. Ejecute seedRoles primero.');
    return;
  }

  let superAdminUser = await userRepository.findOne({ where: { email: SUPER_ADMIN_EMAIL } });

  if (!superAdminUser) {
    console.log(`üå± Creando Usuario Super Admin: ${SUPER_ADMIN_EMAIL}`);
    const hashedPassword = await passwordHasher.hash(DEFAULT_PASSWORD);
    
    const newUser = userRepository.create({
      email: SUPER_ADMIN_EMAIL,
      passwordHash: hashedPassword,
      names: 'Admin',
      firstLastName: 'Super',
      secondLastName: 'System',
      reputationScore: 100,
      status: UserStatus.ACTIVE,
      verifiedEmail: true,
      verifiedPhone: true,
      emailVerifiedAt: new Date(),
      phoneVerifiedAt: new Date(),
    });
    
    superAdminUser = await userRepository.save(newUser);
    
    const userRole = userRoleRepository.create({
      userId: superAdminUser.id,
      roleId: superAdminRole.id,
      assignedBy: superAdminUser.id,
      isPrimary: true,
    });
    await userRoleRepository.save(userRole);
    
    console.log('‚úÖ Usuario Super Admin creado y rol asignado. Contrase√±a por defecto: Super@dm1n2025!');
  }
};


const seedSkills = async () => {
  const skillRepository = AppDataSource.getRepository(SkillSchema);
  const skillsToSeed = [
    'Cocinero',
    'Mesero',
    'Personal de limpieza',
    'Coordinador de eventos',
    'Ayudante de cocina',
    'Personal de apoyo (Multi-habilidades)',
  ];
  for (const skillName of skillsToSeed) {
    const skillExists = await skillRepository.findOne({
      where: { name: skillName },
    });
    if (!skillExists) {
      console.log(`Creando habilidad: ${skillName}`);
      const newSkill = skillRepository.create({
        name: skillName,
        description: '',
        isActive: true, 
      });
      await skillRepository.save(newSkill);
    }
  }
};

export const runSeeds = async () => {
  try {
    await seedRoles();
    await seedSuperAdmin(); 
    await seedSkills();
  } catch (error) {
    console.error('‚ùå Error durante el sembrado de la base de datos:', error);
  }
};


================================================
FILE: src/consumers/index.ts
================================================
import { KitchenApprovedConsumerService } from "../services/kitchen-approved.consumer.service";
import { registerKitchenAdminUseCase } from "../infrastructure/api/dependencies/dependencies";

export async function startConsumers() {
  console.log("üì• Starting consumers...");

  const consumer = new KitchenApprovedConsumerService(
    registerKitchenAdminUseCase
  );

  await consumer.start();

  console.log("‚úÖ Consumers initialized successfully");
}



================================================
FILE: src/database/schemas/email-verification.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn
} from 'typeorm';
import { UserSchema } from './user.schema';

@Entity('Email_Verifications')
export class EmailVerificationSchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'int', name: 'user_id' })
  userId!: number;

  @Column({ type: 'varchar', length: 255, unique: true })
  token!: string;

  @Column({ type: 'timestamp', name: 'expires_at' })
  expiresAt!: Date;

  @Column({ type: 'boolean', default: false, name: 'is_used' })
  isUsed!: boolean;

  @CreateDateColumn({ name: 'created_at' })
  createdAt!: Date;

  @Column({ type: 'timestamp', nullable: true, name: 'used_at' })
  usedAt!: Date | null;

  @ManyToOne(() => UserSchema)
  @JoinColumn({ name: 'user_id' })
  user!: UserSchema;
}



================================================
FILE: src/database/schemas/index.ts
================================================
export { UserSchema } from './user.schema';
export { EmailVerificationSchema } from './email-verification.schema';
export { PhoneVerificationSchema } from './phone-verification.schema';
export { PasswordResetTokenSchema } from './password-reset-token.schema';
export { RoleSchema } from './role.schema';
export { UserRoleSchema } from './user-role.schema';
export { PermissionSchema } from './permission.schema';


================================================
FILE: src/database/schemas/password-reset-token.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn
} from 'typeorm';
import { UserSchema } from './user.schema';

@Entity('Password_Reset_Tokens')
export class PasswordResetTokenSchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'int', name: 'user_id' })
  userId!: number;

  @Column({ type: 'varchar', length: 255, unique: true })
  token!: string;

  @Column({ type: 'timestamp', name: 'expires_at' })
  expiresAt!: Date;

  @Column({ type: 'boolean', default: false, name: 'is_used' })
  isUsed!: boolean;

  @CreateDateColumn({ name: 'created_at' })
  createdAt!: Date;

  @Column({ type: 'timestamp', nullable: true, name: 'used_at' })
  usedAt!: Date | null;

  @ManyToOne(() => UserSchema)
  @JoinColumn({ name: 'user_id' })
  user!: UserSchema;
}


================================================
FILE: src/database/schemas/permission.schema.ts
================================================
import { Entity, PrimaryGeneratedColumn, Column } from 'typeorm';

@Entity('Permissions')
export class PermissionSchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'varchar', length: 255 })
  module!: string;

  @Column({ type: 'varchar', length: 255 })
  action!: string;

  @Column({ type: 'varchar', length: 255 })
  resource!: string;

  @Column({ type: 'text', nullable: true })
  description!: string | null;
}



================================================
FILE: src/database/schemas/phone-verification.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn
} from 'typeorm';
import { UserSchema } from './user.schema';

@Entity('Phone_Verifications')
export class PhoneVerificationSchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'int', name: 'user_id' })
  userId!: number;

  @Column({ type: 'varchar', length: 10 })
  code!: string;

  @Column({ type: 'timestamp', name: 'expires_at' })
  expiresAt!: Date;

  @Column({ type: 'boolean', default: false, name: 'is_used' })
  isUsed!: boolean;

  @Column({ type: 'int', default: 0 })
  attempts!: number;

  @CreateDateColumn({ name: 'created_at' })
  createdAt!: Date;

  @Column({ type: 'timestamp', nullable: true, name: 'used_at' })
  usedAt!: Date | null;

  @ManyToOne(() => UserSchema)
  @JoinColumn({ name: 'user_id' })
  user!: UserSchema;
}



================================================
FILE: src/database/schemas/role.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  ManyToMany,
  JoinTable
} from 'typeorm';
import { UserRoleSchema } from './user-role.schema';
import { PermissionSchema } from './permission.schema';

@Entity('Roles')
export class RoleSchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'varchar', length: 255, unique: true })
  name!: string;

  @Column({ type: 'text', nullable: true })
  description!: string | null;

  @Column({ type: 'int' })
  level!: number;

  @CreateDateColumn({ name: 'created_at' })
  createdAt!: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt!: Date;

  @OneToMany(() => UserRoleSchema, userRole => userRole.role)
  userRoles!: UserRoleSchema[];

  @ManyToMany(() => PermissionSchema)
  @JoinTable({
    name: 'Role_Permissions',
    joinColumn: { name: 'role_id', referencedColumnName: 'id' },
    inverseJoinColumn: { name: 'permission_id', referencedColumnName: 'id' }
  })
  permissions!: PermissionSchema[];
}



================================================
FILE: src/database/schemas/skill.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany
} from 'typeorm';
import { UserSchema } from './user.schema';

@Entity('Skills')
export class SkillSchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'varchar', length: 100, unique: true })
  name!: string;

  @Column({ type: 'varchar', length: 500, nullable: true })
  description!: string | null;

  @Column({ type: 'boolean', default: true, name: 'is_active' })
  isActive!: boolean;

  @CreateDateColumn({ name: 'created_at' })
  createdAt!: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt!: Date;

  @Column({ type: 'int', nullable: true, name: 'created_by' })
  createdBy!: number | null;

  @OneToMany(() => UserSchema, userSkill => userSkill.userSkills)
  userSkills!: UserSchema[];
}


================================================
FILE: src/database/schemas/user-availability.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  Index
} from 'typeorm';
import { UserSchema } from './user.schema';

export enum DayOfWeek {
  MONDAY = 'monday',
  TUESDAY = 'tuesday',
  WEDNESDAY = 'wednesday',
  THURSDAY = 'thursday',
  FRIDAY = 'friday',
  SATURDAY = 'saturday',
  SUNDAY = 'sunday'
}

@Entity('User_Availability')
@Index('IDX_USER_AVAILABILITY_USER_DAY', ['userId', 'dayOfWeek'])
export class UserAvailabilitySchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'int', name: 'user_id' })
  userId!: number;

  @Column({ type: 'enum', enum: DayOfWeek, name: 'day_of_week' })
  dayOfWeek!: DayOfWeek;

  @Column({ type: 'varchar', length: 5, name: 'start_time', comment: 'Format HH:mm' })
  startTime!: string;

  @Column({ type: 'varchar', length: 5, name: 'end_time', comment: 'Format HH:mm' })
  endTime!: string;

  @CreateDateColumn({ name: 'created_at' })
  createdAt!: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt!: Date;

  @ManyToOne(() => UserSchema, user => user.availability, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user!: UserSchema;
}


================================================
FILE: src/database/schemas/user-reputation-history.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn,
  Index
} from 'typeorm';
import { UserSchema } from './user.schema';

@Entity('User_Reputation_History')
@Index('IDX_USER_REPUTATION_HISTORY_USER', ['userId'])
@Index('IDX_USER_REPUTATION_HISTORY_DATE', ['createdAt'])
export class UserReputationHistorySchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'int', name: 'user_id' })
  userId!: number;

  @Column({ type: 'int', name: 'change_amount', comment: 'Can be positive or negative' })
  changeAmount!: number;

  @Column({ type: 'int', name: 'previous_score' })
  previousScore!: number;

  @Column({ type: 'int', name: 'new_score' })
  newScore!: number;

  @Column({ type: 'varchar', length: 100 })
  reason!: string;

  @Column({ type: 'varchar', length: 500, nullable: true })
  details!: string | null;

  @Column({ type: 'int', nullable: true, name: 'related_event_id', comment: 'Reference to external event service' })
  relatedEventId!: number | null;

  @CreateDateColumn({ name: 'created_at' })
  createdAt!: Date;

  @Column({ type: 'int', nullable: true, name: 'created_by' })
  createdBy!: number | null;

  @ManyToOne(() => UserSchema, user => user.reputationHistory, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user!: UserSchema;
}


================================================
FILE: src/database/schemas/user-role.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  ManyToOne,
  JoinColumn
} from 'typeorm';
import { UserSchema } from './user.schema';
import { RoleSchema } from './role.schema';

@Entity('User_Roles')
export class UserRoleSchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'int', name: 'user_id' })
  userId!: number;

  @Column({ type: 'int', name: 'role_id' })
  roleId!: number;

  @Column({ type: 'boolean', default: false, name: 'is_primary' })
  isPrimary!: boolean;

  @CreateDateColumn({ name: 'assigned_at' })
  assignedAt!: Date;

  @Column({ type: 'int', nullable: true, name: 'assigned_by' })
  assignedBy!: number | null;

  @ManyToOne(() => UserSchema, user => user.userRoles)
  @JoinColumn({ name: 'user_id' })
  user!: UserSchema;

  @ManyToOne(() => RoleSchema, role => role.userRoles)
  @JoinColumn({ name: 'role_id' })
  role!: RoleSchema;
}



================================================
FILE: src/database/schemas/user-schedule.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  Index
} from 'typeorm';
import { UserSchema } from './user.schema';

@Entity('User_Schedules')
@Index('IDX_USER_SCHEDULE_USER_DATETIME', ['userId', 'startDateTime', 'endDateTime'])
@Index('IDX_USER_SCHEDULE_EVENT', ['eventId'])
export class UserScheduleSchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'int', name: 'user_id' })
  userId!: number;

  @Column({ type: 'timestamp', name: 'start_date_time' })
  startDateTime!: Date;

  @Column({ type: 'timestamp', name: 'end_date_time' })
  endDateTime!: Date;

  @Column({ type: 'varchar', length: 500, nullable: true })
  notes!: string | null;

  @Column({ type: 'int', nullable: true, name: 'event_id', comment: 'Reference to external event service' })
  eventId!: number | null;

  @CreateDateColumn({ name: 'created_at' })
  createdAt!: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt!: Date;

  @Column({ type: 'int', nullable: true, name: 'created_by' })
  createdBy!: number | null;

  @ManyToOne(() => UserSchema, user => user.schedules, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user!: UserSchema;
}


================================================
FILE: src/database/schemas/user-skill.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
  Index
} from 'typeorm';
import { UserSchema } from './user.schema';
import { SkillSchema } from './skill.schema';

@Entity('User_Skills')
@Index('IDX_USER_SKILL_UNIQUE', ['userId', 'skillId'], { unique: true })
export class UserSkillSchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'int', name: 'user_id' })
  userId!: number;

  @Column({ type: 'int', name: 'skill_id' })
  skillId!: number;

  @Column({ type: 'int', nullable: true, name: 'proficiency_level', comment: 'Level from 1 to 5' })
  proficiencyLevel!: number | null;

  @Column({ type: 'int', nullable: true, name: 'years_of_experience' })
  yearsOfExperience!: number | null;

  @CreateDateColumn({ name: 'created_at' })
  createdAt!: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt!: Date;

  @ManyToOne(() => UserSchema, user => user.userSkills, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'user_id' })
  user!: UserSchema;

  @ManyToOne(() => SkillSchema, skill => skill.userSkills, { onDelete: 'CASCADE' })
  @JoinColumn({ name: 'skill_id' })
  skill!: SkillSchema;
}


================================================
FILE: src/database/schemas/user.schema.ts
================================================
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToMany,
  Index
} from 'typeorm';
import { UserRoleSchema } from './user-role.schema';
import { UserSkillSchema } from './user-skill.schema';
import { UserAvailabilitySchema } from './user-availability.schema';
import { UserScheduleSchema } from './user-schedule.schema';
import { UserReputationHistorySchema } from './user-reputation-history.schema';

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended',
  PENDING = 'pending'
}

@Entity('Users')
@Index('IDX_USER_EMAIL', ['email'], { unique: true })
@Index('IDX_USER_STATUS', ['status'])
@Index('IDX_USER_LOCATION', ['stateId', 'municipalityId'])
export class UserSchema {
  @PrimaryGeneratedColumn()
  id!: number;

  @Column({ type: 'varchar', length: 255, unique: true })
  email!: string;

  @Column({ type: 'varchar', length: 255, name: 'password_hash' })
  passwordHash!: string;

  @Column({ type: 'varchar', length: 255 })
  names!: string;

  @Column({ type: 'varchar', length: 255, name: 'first_last_name' })
  firstLastName!: string;

  @Column({ type: 'varchar', length: 255, name: 'second_last_name' })
  secondLastName!: string;

  @Column({ type: 'varchar', length: 255, nullable: true, name: 'image_profile' })
  imageProfile!: string | null;

  @Column({ type: 'varchar', length: 50, nullable: true, name: 'phone_number' })
  phoneNumber!: string | null;

  @Column({ type: 'int', nullable: true, name: 'state_id' })
  stateId!: number | null;

  @Column({ type: 'int', nullable: true, name: 'municipality_id' })
  municipalityId!: number | null;

  @Column({ type: 'boolean', default: false, name: 'verified_email' })
  verifiedEmail!: boolean;

  @Column({ type: 'boolean', default: false, name: 'verified_phone' })
  verifiedPhone!: boolean;

  @Column({ type: 'timestamp', nullable: true, name: 'email_verified_at' })
  emailVerifiedAt!: Date | null;

  @Column({ type: 'timestamp', nullable: true, name: 'phone_verified_at' })
  phoneVerifiedAt!: Date | null;

  @Column({ type: 'enum', enum: UserStatus, default: UserStatus.PENDING })
  status!: UserStatus;

  @Column({ type: 'decimal', precision: 5, scale: 2, default: 0, name: 'reputation_score' })
  reputationScore!: number;

  @Column({ type: 'varchar', length: 255, nullable: true, unique: true, name: 'google_user_id' })
  googleUserId!: string | null;

  @CreateDateColumn({ name: 'created_at' })
  createdAt!: Date;

  @UpdateDateColumn({ name: 'updated_at' })
  updatedAt!: Date;

  @Column({ type: 'int', nullable: true, name: 'created_by' })
  createdBy!: number | null;

  @OneToMany(() => UserRoleSchema, userRole => userRole.user)
  userRoles!: UserRoleSchema[];

  @OneToMany(() => UserSkillSchema, userSkill => userSkill.user)
  userSkills!: UserSkillSchema[];

  @OneToMany(() => UserAvailabilitySchema, availability => availability.user)
  availability!: UserAvailabilitySchema[];

  @OneToMany(() => UserScheduleSchema, schedule => schedule.user)
  schedules!: UserScheduleSchema[];

  @OneToMany(() => UserReputationHistorySchema, history => history.user)
  reputationHistory!: UserReputationHistorySchema[];
}


================================================
FILE: src/domain/entities/email-verification.entity.ts
================================================
import { IsNotEmpty, IsNumber, IsString, IsBoolean, IsDate, IsOptional, Length } from 'class-validator';

export class EmailVerification {
  @IsOptional()
  @IsNumber()
  public id: number;

  @IsNotEmpty()
  @IsNumber()
  public userId: number;

  @IsNotEmpty()
  @IsString()
  @Length(1, 255)
  public token: string;

  @IsNotEmpty()
  @IsDate()
  public expiresAt: Date;

  @IsBoolean()
  public isUsed: boolean;

  @IsDate()
  public createdAt: Date;

  @IsOptional()
  @IsDate()
  public usedAt: Date | null;

  constructor(
    id: number,
    userId: number,
    token: string,
    expiresAt: Date,
    isUsed: boolean,
    createdAt: Date,
    usedAt: Date | null
  ) {
    this.id = id;
    this.userId = userId;
    this.token = token;
    this.expiresAt = expiresAt;
    this.isUsed = isUsed;
    this.createdAt = createdAt;
    this.usedAt = usedAt;
  }
}


================================================
FILE: src/domain/entities/password-reset-token.entity.ts
================================================
import { IsNotEmpty, IsNumber, IsString, IsBoolean, IsDate, IsOptional, Length } from 'class-validator';

export class PasswordResetToken {
  @IsOptional()
  @IsNumber()
  public id: number;

  @IsNotEmpty()
  @IsNumber()
  public userId: number;

  @IsNotEmpty()
  @IsString()
  @Length(1, 255)
  public token: string;

  @IsNotEmpty()
  @IsDate()
  public expiresAt: Date;

  @IsBoolean()
  public isUsed: boolean;

  @IsDate()
  public createdAt: Date;

  @IsOptional()
  @IsDate()
  public usedAt: Date | null;

  constructor(
    id: number,
    userId: number,
    token: string,
    expiresAt: Date,
    isUsed: boolean,
    createdAt: Date,
    usedAt: Date | null
  ) {
    this.id = id;
    this.userId = userId;
    this.token = token;
    this.expiresAt = expiresAt;
    this.isUsed = isUsed;
    this.createdAt = createdAt;
    this.usedAt = usedAt;
  }
}


================================================
FILE: src/domain/entities/permission.entity.ts
================================================
import { IsNotEmpty, IsNumber, IsString, IsOptional, Length } from 'class-validator';

export class Permission {
  @IsOptional()
  @IsNumber()
  public id: number;

  @IsNotEmpty()
  @IsString()
  @Length(1, 255)
  public module: string;

  @IsNotEmpty()
  @IsString()
  @Length(1, 255)
  public action: string;

  @IsNotEmpty()
  @IsString()
  @Length(1, 255)
  public resource: string;

  @IsOptional()
  @IsString()
  public description: string | null;

  constructor(
    id: number,
    module: string,
    action: string,
    resource: string,
    description: string | null
  ) {
    this.id = id;
    this.module = module;
    this.action = action;
    this.resource = resource;
    this.description = description;
  }
}


================================================
FILE: src/domain/entities/phone-verification.entity.ts
================================================
import { IsNotEmpty, IsNumber, IsString, IsBoolean, IsDate, IsOptional, Length, Min } from 'class-validator';

export class PhoneVerification {
  @IsOptional()
  @IsNumber()
  public id: number;

  @IsNotEmpty()
  @IsNumber()
  public userId: number;

  @IsNotEmpty()
  @IsString()
  @Length(6, 10)
  public code: string;

  @IsNotEmpty()
  @IsDate()
  public expiresAt: Date;

  @IsBoolean()
  public isUsed: boolean;

  @IsNumber()
  @Min(0)
  public attempts: number;

  @IsDate()
  public createdAt: Date;

  @IsOptional()
  @IsDate()
  public usedAt: Date | null;

  constructor(
    id: number,
    userId: number,
    code: string,
    expiresAt: Date,
    isUsed: boolean,
    attempts: number,
    createdAt: Date,
    usedAt: Date | null
  ) {
    this.id = id;
    this.userId = userId;
    this.code = code;
    this.expiresAt = expiresAt;
    this.isUsed = isUsed;
    this.attempts = attempts;
    this.createdAt = createdAt;
    this.usedAt = usedAt;
  }
}


================================================
FILE: src/domain/entities/role.entity.ts
================================================
import { IsNotEmpty, IsNumber, IsString, IsDate, IsOptional, Length, Min } from 'class-validator';

export class Role {
  @IsOptional()
  @IsNumber()
  public id: number;

  @IsNotEmpty()
  @IsString()
  @Length(2, 255)
  public name: string;

  @IsOptional()
  @IsString()
  public description: string | null;

  @IsNotEmpty({ message: 'Level is required' })
  @IsNumber()
  @Min(1)
  public level: number;

  @IsDate()
  public createdAt: Date;

  @IsDate()
  public updatedAt: Date;

  constructor(
    id: number,
    name: string,
    description: string | null,
    level: number,
    createdAt: Date,
    updatedAt: Date
  ) {
    this.id = id;
    this.name = name;
    this.description = description;
    this.level = level;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
}


================================================
FILE: src/domain/entities/skill.entity.ts
================================================
import {
  IsNotEmpty,
  IsOptional,
  IsNumber,
  IsBoolean,
  IsDate,
  Length
} from 'class-validator';

export class Skill {
  @IsOptional()
  @IsNumber()
  id: number;

  @IsNotEmpty()
  @Length(2, 100)
  name: string;

  @IsOptional()
  @Length(0, 500)
  description?: string | null;

  @IsBoolean()
  isActive: boolean;

  @IsDate()
  createdAt: Date;

  @IsDate()
  updatedAt: Date;

  @IsOptional()
  @IsNumber()
  createdBy?: number | null;

  constructor(
    id: number,
    name: string,
    description: string | null,
    isActive: boolean,
    createdAt: Date,
    updatedAt: Date,
    createdBy: number | null
  ) {
    this.id = id;
    this.name = name;
    this.description = description;
    this.isActive = isActive;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.createdBy = createdBy;
  }
}


================================================
FILE: src/domain/entities/user-availability.entity.ts
================================================
import {
  IsNotEmpty,
  IsOptional,
  IsNumber,
  IsEnum,
  IsDate,
  IsString,
  Matches
} from 'class-validator';

export enum DayOfWeek {
  MONDAY = 'monday',
  TUESDAY = 'tuesday',
  WEDNESDAY = 'wednesday',
  THURSDAY = 'thursday',
  FRIDAY = 'friday',
  SATURDAY = 'saturday',
  SUNDAY = 'sunday'
}

export class UserAvailability {
  @IsOptional()
  @IsNumber()
  id: number;

  @IsNotEmpty()
  @IsNumber()
  userId: number;

  @IsNotEmpty()
  @IsEnum(DayOfWeek)
  dayOfWeek: DayOfWeek;

  @IsNotEmpty()
  @IsString()
  @Matches(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, {
    message: 'startTime must be in format HH:mm'
  })
  startTime: string;

  @IsNotEmpty()
  @IsString()
  @Matches(/^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/, {
    message: 'endTime must be in format HH:mm'
  })
  endTime: string;

  @IsDate()
  createdAt: Date;

  @IsDate()
  updatedAt: Date;

  constructor(
    id: number,
    userId: number,
    dayOfWeek: DayOfWeek,
    startTime: string,
    endTime: string,
    createdAt: Date,
    updatedAt: Date
  ) {
    this.id = id;
    this.userId = userId;
    this.dayOfWeek = dayOfWeek;
    this.startTime = startTime;
    this.endTime = endTime;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
}


================================================
FILE: src/domain/entities/user-reputation-history.entity.ts
================================================
import {
  IsNotEmpty,
  IsOptional,
  IsNumber,
  IsDate,
  IsString,
  Length,
  Min,
  Max
} from 'class-validator';

export class UserReputationHistory {
  @IsOptional()
  @IsNumber()
  id: number;

  @IsNotEmpty()
  @IsNumber()
  userId: number;

  @IsNotEmpty()
  @IsNumber()
  @Min(-100)
  @Max(100)
  changeAmount: number;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  @Max(100)
  previousScore: number;

  @IsNotEmpty()
  @IsNumber()
  @Min(0)
  @Max(100)
  newScore: number;

  @IsNotEmpty()
  @IsString()
  @Length(3, 100)
  reason: string;

  @IsOptional()
  @IsString()
  @Length(0, 500)
  details?: string | null;

  @IsOptional()
  @IsNumber()
  relatedEventId?: number | null;

  @IsDate()
  createdAt: Date;

  @IsOptional()
  @IsNumber()
  createdBy?: number | null;

  constructor(
    id: number,
    userId: number,
    changeAmount: number,
    previousScore: number,
    newScore: number,
    reason: string,
    details: string | null,
    relatedEventId: number | null,
    createdAt: Date,
    createdBy: number | null
  ) {
    this.id = id;
    this.userId = userId;
    this.changeAmount = changeAmount;
    this.previousScore = previousScore;
    this.newScore = newScore;
    this.reason = reason;
    this.details = details;
    this.relatedEventId = relatedEventId;
    this.createdAt = createdAt;
    this.createdBy = createdBy;
  }
}


================================================
FILE: src/domain/entities/user-schedule.entity.ts
================================================
import {
  IsNotEmpty,
  IsOptional,
  IsNumber,
  IsDate,
  IsString,
  Length
} from 'class-validator';

export class UserSchedule {
  @IsOptional()
  @IsNumber()
  id: number;

  @IsNotEmpty()
  @IsNumber()
  userId: number;

  @IsNotEmpty()
  @IsDate()
  startDateTime: Date;

  @IsNotEmpty()
  @IsDate()
  endDateTime: Date;

  @IsOptional()
  @IsString()
  @Length(0, 500)
  notes?: string | null;

  @IsOptional()
  @IsNumber()
  eventId?: number | null;

  @IsDate()
  createdAt: Date;

  @IsDate()
  updatedAt: Date;

  @IsOptional()
  @IsNumber()
  createdBy?: number | null;

  constructor(
    id: number,
    userId: number,
    startDateTime: Date,
    endDateTime: Date,
    notes: string | null,
    eventId: number | null,
    createdAt: Date,
    updatedAt: Date,
    createdBy: number | null
  ) {
    this.id = id;
    this.userId = userId;
    this.startDateTime = startDateTime;
    this.endDateTime = endDateTime;
    this.notes = notes;
    this.eventId = eventId;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.createdBy = createdBy;
  }
}


================================================
FILE: src/domain/entities/user-skill.entity.ts
================================================
import {
  IsNotEmpty,
  IsOptional,
  IsNumber,
  IsDate,
  Min,
  Max
} from 'class-validator';

export class UserSkill {
  @IsOptional()
  @IsNumber()
  id: number;

  @IsNotEmpty()
  @IsNumber()
  userId: number;

  @IsNotEmpty()
  @IsNumber()
  skillId: number;

  @IsOptional()
  @IsNumber()
  @Min(1)
  @Max(5)
  proficiencyLevel?: number | null;

  @IsOptional()
  @IsNumber()
  @Min(0)
  yearsOfExperience?: number | null;

  @IsDate()
  createdAt: Date;

  @IsDate()
  updatedAt: Date;

  constructor(
    id: number,
    userId: number,
    skillId: number,
    proficiencyLevel: number | null,
    yearsOfExperience: number | null,
    createdAt: Date,
    updatedAt: Date
  ) {
    this.id = id;
    this.userId = userId;
    this.skillId = skillId;
    this.proficiencyLevel = proficiencyLevel;
    this.yearsOfExperience = yearsOfExperience;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
  }
}


================================================
FILE: src/domain/entities/user.entity.ts
================================================
import {
  IsEmail,
  IsNotEmpty,
  Length,
  IsEnum,
  IsOptional,
  IsNumber,
  IsBoolean,
  IsDate,
  Min,
  Max
} from 'class-validator';
import { Role } from './role.entity';
import { UserSkill } from './user-skill.entity';
import { UserAvailability } from './user-availability.entity';
import { UserSchedule } from './user-schedule.entity';
import { UserReputationHistory } from './user-reputation-history.entity';
import { EmailVerification } from './email-verification.entity';
import { PhoneVerification } from './phone-verification.entity';
import { PasswordResetToken } from './password-reset-token.entity';

export enum UserStatus {
  ACTIVE = 'active',
  INACTIVE = 'inactive',
  SUSPENDED = 'suspended',
  PENDING = 'pending'
}

export class User {
  @IsOptional()
  @IsNumber()
  id: number;

  @IsNotEmpty()
  @IsEmail()
  email: string;

  @IsNotEmpty()
  passwordHash: string;

  @IsNotEmpty()
  @Length(2, 255)
  names: string;

  @IsNotEmpty()
  @Length(2, 255)
  firstLastName: string;

  @IsNotEmpty()
  @Length(2, 255)
  secondLastName: string;

  @IsOptional()
  imageProfile?: string | null;

  @IsOptional()
  @Length(10, 50)
  phoneNumber?: string | null;

  @IsOptional()
  @IsNumber()
  stateId?: number | null;

  @IsOptional()
  @IsNumber()
  municipalityId?: number | null;

  @IsBoolean()
  verifiedEmail: boolean;

  @IsBoolean()
  verifiedPhone: boolean;

  @IsOptional()
  @IsDate()
  emailVerifiedAt?: Date | null;

  @IsOptional()
  @IsDate()
  phoneVerifiedAt?: Date | null;

  @IsEnum(UserStatus)
  status: UserStatus;

  @IsNumber()
  @Min(0)
  @Max(100)
  reputationScore: number;

  @IsOptional()
  googleUserId?: string | null;

  @IsDate()
  createdAt: Date;

  @IsDate()
  updatedAt: Date;

  @IsOptional()
  @IsNumber()
  createdBy?: number | null;

  roles?: Role[];

  userSkills?: UserSkill[];

  availability?: UserAvailability[];
  schedules?: UserSchedule[];

  reputationHistory?: UserReputationHistory[];

  emailVerifications?: EmailVerification[];
  phoneVerifications?: PhoneVerification[];

  passwordResetTokens?: PasswordResetToken[];

  constructor(
    id: number,
    names: string,
    firstLastName: string,
    secondLastName: string,
    email: string,
    passwordHash: string,
    imageProfile: string | null = null,
    phoneNumber: string | null = null,
    reputationScore: number = 0,
    googleUserId: string | null = null,
    status: UserStatus = UserStatus.PENDING,
    verifiedEmail: boolean = false,
    verifiedPhone: boolean = false,
    emailVerifiedAt: Date | null = null,
    phoneVerifiedAt: Date | null = null,
    stateId: number | null = null,
    municipalityId: number | null = null,
    createdAt: Date = new Date(),
    updatedAt: Date = new Date(),
    createdBy: number | null = null
  ) {
    this.id = id;
    this.names = names;
    this.firstLastName = firstLastName;
    this.secondLastName = secondLastName;
    this.email = email;
    this.passwordHash = passwordHash;
    this.imageProfile = imageProfile;
    this.phoneNumber = phoneNumber;
    this.reputationScore = reputationScore;
    this.googleUserId = googleUserId;
    this.status = status;
    this.verifiedEmail = verifiedEmail;
    this.verifiedPhone = verifiedPhone;
    this.emailVerifiedAt = emailVerifiedAt;
    this.phoneVerifiedAt = phoneVerifiedAt;
    this.stateId = stateId;
    this.municipalityId = municipalityId;
    this.createdAt = createdAt;
    this.updatedAt = updatedAt;
    this.createdBy = createdBy;
  }
}


================================================
FILE: src/domain/interfaces/email-verification.repository.interface.ts
================================================
import { EmailVerification } from '../entities/email-verification.entity';

export interface IEmailVerificationRepository {
  save(emailVerification: EmailVerification): Promise<EmailVerification>;
  findById(id: number): Promise<EmailVerification | null>;
  findByToken(token: string): Promise<EmailVerification | null>;
  findByUserId(userId: number): Promise<EmailVerification[]>;
  findLatestByUserId(userId: number): Promise<EmailVerification | null>;
  update(id: number, emailVerification: Partial<EmailVerification>): Promise<EmailVerification>;
  delete(id: number): Promise<void>;
  deleteExpired(): Promise<void>;
}


================================================
FILE: src/domain/interfaces/event-publisher.interface.ts
================================================
export interface IEventPublisher {
  publish(eventName: string, data: any): Promise<void>;
  publishBatch(events: Array<{ eventName: string; data: any }>): Promise<void>;
}



================================================
FILE: src/domain/interfaces/password-hasher.interface.ts
================================================
export interface IPasswordHasher {
  hash(password: string): Promise<string>;
  compare(password: string, hashedPassword: string): Promise<boolean>;
}



================================================
FILE: src/domain/interfaces/password-reset-token.repository.interface.ts
================================================
import { PasswordResetToken } from '../entities/password-reset-token.entity';

export interface IPasswordResetTokenRepository {
  save(token: PasswordResetToken): Promise<PasswordResetToken>;
  findById(id: number): Promise<PasswordResetToken | null>;
  findByToken(token: string): Promise<PasswordResetToken | null>;
  findByUserId(userId: number): Promise<PasswordResetToken[]>;
  findLatestByUserId(userId: number): Promise<PasswordResetToken | null>;
  update(id: number, token: Partial<PasswordResetToken>): Promise<PasswordResetToken>;
  delete(id: number): Promise<void>;
  deleteExpired(): Promise<void>;
  invalidateAllByUserId(userId: number): Promise<void>;
}


================================================
FILE: src/domain/interfaces/permission.repository.interface.ts
================================================
import { Permission } from '../entities/permission.entity';

export interface IPermissionRepository {
  save(permission: Permission): Promise<Permission>;
  findById(id: number): Promise<Permission | null>;
  findByModuleActionResource(module: string, action: string, resource: string): Promise<Permission | null>;
  findAll(): Promise<Permission[]>;
  findByModule(module: string): Promise<Permission[]>;
  update(id: number, permission: Partial<Permission>): Promise<Permission>;
  delete(id: number): Promise<void>;
  assignPermissionToRole(roleId: number, permissionId: number): Promise<void>;
  removePermissionFromRole(roleId: number, permissionId: number): Promise<void>;
  getRolePermissions(roleId: number): Promise<Permission[]>;
  getUserPermissions(userId: number): Promise<Permission[]>;
  userHasPermission(userId: number, module: string, action: string, resource: string): Promise<boolean>;
}


================================================
FILE: src/domain/interfaces/phone-verification.repository.interface.ts
================================================
import { PhoneVerification } from '../entities/phone-verification.entity';

export interface IPhoneVerificationRepository {
  save(phoneVerification: PhoneVerification): Promise<PhoneVerification>;
  findById(id: number): Promise<PhoneVerification | null>;
  findByCode(code: string): Promise<PhoneVerification | null>;
  findByUserId(userId: number): Promise<PhoneVerification[]>;
  findLatestByUserId(userId: number): Promise<PhoneVerification | null>;
  update(id: number, phoneVerification: Partial<PhoneVerification>): Promise<PhoneVerification>;
  delete(id: number): Promise<void>;
  deleteExpired(): Promise<void>;
}


================================================
FILE: src/domain/interfaces/role.repository.interface.ts
================================================
import { Role } from '../entities/role.entity';

export interface IRoleRepository {
  save(role: Role): Promise<Role>;
  findById(id: number): Promise<Role | null>;
  findByName(name: string): Promise<Role | null>;
  findAll(): Promise<Role[]>;
  update(id: number, role: Partial<Role>): Promise<Role>;
  delete(id: number): Promise<void>;
  existsByName(name: string): Promise<boolean>;
  assignRoleToUser(userId: number, roleId: number, assignedBy?: number): Promise<void>;
  removeRoleFromUser(userId: number, roleId: number): Promise<void>;
  getUserRoles(userId: number): Promise<Role[]>;
  setPrimaryRole(userId: number, roleId: number): Promise<void>;
}


================================================
FILE: src/domain/interfaces/skill.repository.interface.ts
================================================
import { Skill } from '../entities/skill.entity';

export interface ISkillRepository {
  findById(id: number): Promise<Skill | null>;
  findByName(name: string): Promise<Skill | null>;
  findAll(): Promise<Skill[]>;
  findPaginated(params: {
    page: number;
    limit: number;
    search?: string;
    isActive?: boolean;
  }): Promise<{ data: Skill[]; total: number }>;
  create(skill: Skill): Promise<Skill>;
  update(skill: Skill): Promise<Skill>;
  delete(id: number): Promise<void>;
}


================================================
FILE: src/domain/interfaces/token-generator.interface.ts
================================================
export interface TokenPayload {
  userId: number;
  email: string;
  roles: string[];
  stateId: number | null;
  municipalityId: number | null;
  iat?: number;
  exp?: number;
}

export interface RefreshTokenPayload {
  userId: number;
}

export interface ITokenGenerator {
  generateAccessToken(
    userId: number,
    email: string,
    roles: string[],
    stateId?: number | null,
    municipalityId?: number | null
  ): string;

  generateRefreshToken(userId: number): string;

  verifyAccessToken(token: string): TokenPayload;

  verifyRefreshToken(token: string): RefreshTokenPayload;

  generateRandomToken(): string;

  generateNumericCode(length?: number): string;
}



================================================
FILE: src/domain/interfaces/user-availability.repository.interface.ts
================================================
import { UserAvailability, DayOfWeek } from '../entities/user-availability.entity';

export interface IUserAvailabilityRepository {
  findById(id: number): Promise<UserAvailability | null>;
  findByUserId(userId: number): Promise<UserAvailability[]>;
  findByUserIdAndDay(userId: number, dayOfWeek: DayOfWeek): Promise<UserAvailability[]>;
  create(availability: UserAvailability): Promise<UserAvailability>;
  update(availability: UserAvailability): Promise<UserAvailability>;
  delete(id: number): Promise<void>;
  deleteByUserId(userId: number): Promise<void>;
  deleteByUserIdAndDay(userId: number, dayOfWeek: DayOfWeek): Promise<void>;
}


================================================
FILE: src/domain/interfaces/user-reputation-history.repository.interface.ts
================================================
import { UserReputationHistory } from '../entities/user-reputation-history.entity';

export interface IUserReputationHistoryRepository {
  findById(id: number): Promise<UserReputationHistory | null>;
  findByUserId(userId: number): Promise<UserReputationHistory[]>;
  findByUserIdPaginated(params: {
    userId: number;
    page: number;
    limit: number;
    startDate?: Date;
    endDate?: Date;
  }): Promise<{ data: UserReputationHistory[]; total: number }>;
  findByEventId(eventId: number): Promise<UserReputationHistory[]>;
  create(history: UserReputationHistory): Promise<UserReputationHistory>;
  delete(id: number): Promise<void>;
  deleteByUserId(userId: number): Promise<void>;
}


================================================
FILE: src/domain/interfaces/user-schedule.repository.interface.ts
================================================
import { UserSchedule } from '../entities/user-schedule.entity';

export interface IUserScheduleRepository {
  findById(id: number): Promise<UserSchedule | null>;
  findByUserId(userId: number): Promise<UserSchedule[]>;
  findByUserIdPaginated(params: {
    userId: number;
    page: number;
    limit: number;
    startDate?: Date;
    endDate?: Date;
    eventId?: number;
  }): Promise<{ data: UserSchedule[]; total: number }>;
  findByEventId(eventId: number): Promise<UserSchedule[]>;
  findConflicts(userId: number, startDateTime: Date, endDateTime: Date): Promise<UserSchedule[]>;
  findConflictsExcluding(
    userId: number,
    startDateTime: Date,
    endDateTime: Date,
    excludeScheduleId: number
  ): Promise<UserSchedule[]>;
  create(schedule: UserSchedule): Promise<UserSchedule>;
  update(schedule: UserSchedule): Promise<UserSchedule>;
  delete(id: number): Promise<void>;
  deleteByUserId(userId: number): Promise<void>;
  deleteByEventId(eventId: number): Promise<void>;
}


================================================
FILE: src/domain/interfaces/user-skill.repository.interface.ts
================================================
import { UserSkill } from '../entities/user-skill.entity';

export interface IUserSkillRepository {
  findById(id: number): Promise<UserSkill | null>;
  findByUserId(userId: number): Promise<UserSkill[]>;
  findBySkillId(skillId: number): Promise<UserSkill[]>;
  findByUserIdAndSkillId(userId: number, skillId: number): Promise<UserSkill | null>;
  create(userSkill: UserSkill): Promise<UserSkill>;
  update(userSkill: UserSkill): Promise<UserSkill>;
  delete(id: number): Promise<void>;
  deleteByUserId(userId: number): Promise<void>;
  deleteByUserIdAndSkillId(userId: number, skillId: number): Promise<void>;
}


================================================
FILE: src/domain/interfaces/user.repository.interface.ts
================================================
import { User, UserStatus } from '../entities/user.entity';

export interface IUserRepository {
  findById(id: number): Promise<User | null>;
  findByEmail(email: string): Promise<User | null>;
  findByGoogleUserId(googleUserId: string): Promise<User | null>;
  findAll(): Promise<User[]>;
  findPaginated(params: {
    page: number;
    limit: number;
    search?: string;
    status?: UserStatus;
    stateId?: number;
    municipalityId?: number;
  }): Promise<{ data: User[]; total: number }>;
  save(user: User): Promise<User>;
  update(user: User): Promise<User>;
  delete(id: number): Promise<void>;
}


================================================
FILE: src/domain/validators/email-verification.validator.ts
================================================
import { EmailVerification } from '../entities/email-verification.entity';
import { BaseValidator } from './validator';

export class EmailVerificationValidator extends BaseValidator<EmailVerification> {
  constructor(emailVerification: EmailVerification) {
    super(emailVerification);
  }


  public async validateWithCustomRules(): Promise<void> {
    await this.validate();

    if (this.isExpired()) {
      this.listErrors.push({
        property: 'expiresAt',
        constraints: {
          isExpired: 'Verification token has expired'
        },
        children: [],
        target: this.entity,
        value: this.entity.expiresAt
      });
    }

    if (this.entity.isUsed) {
      this.listErrors.push({
        property: 'isUsed',
        constraints: {
          alreadyUsed: 'Verification token has already been used'
        },
        children: [],
        target: this.entity,
        value: this.entity.isUsed
      });
    }

    if (this.hasErrors()) {
      throw {
        http_status: 422,
        validations: this.getFormattedErrors()
      };
    }
  }


  public isExpired(): boolean {
    return new Date() > this.entity.expiresAt;
  }


  public isValidToken(): boolean {
    return !this.entity.isUsed && !this.isExpired();
  }

  public getMinutesRemaining(): number {
    const now = new Date();
    const diff = this.entity.expiresAt.getTime() - now.getTime();
    return Math.max(0, Math.floor(diff / (1000 * 60)));
  }
}


================================================
FILE: src/domain/validators/password-reset-token.validator.ts
================================================
import { PasswordResetToken } from '../entities/password-reset-token.entity';
import { BaseValidator } from './validator';

export class PasswordResetTokenValidator extends BaseValidator<PasswordResetToken> {
  constructor(token: PasswordResetToken) {
    super(token);
  }

  public async validateWithCustomRules(): Promise<void> {
    await this.validate();

    if (this.isExpired()) {
      this.listErrors.push({
        property: 'expiresAt',
        constraints: {
          isExpired: 'Password reset token has expired'
        },
        children: [],
        target: this.entity,
        value: this.entity.expiresAt
      });
    }

    if (this.entity.isUsed) {
      this.listErrors.push({
        property: 'isUsed',
        constraints: {
          alreadyUsed: 'Password reset token has already been used'
        },
        children: [],
        target: this.entity,
        value: this.entity.isUsed
      });
    }

    if (this.hasErrors()) {
      throw {
        http_status: 422,
        validations: this.getFormattedErrors()
      };
    }
  }

  public isExpired(): boolean {
    return new Date() > this.entity.expiresAt;
  }


  public isValidToken(): boolean {
    return !this.entity.isUsed && !this.isExpired();
  }


  public getMinutesRemaining(): number {
    const now = new Date();
    const diff = this.entity.expiresAt.getTime() - now.getTime();
    return Math.max(0, Math.floor(diff / (1000 * 60)));
  }
}


================================================
FILE: src/domain/validators/password-strength.validator.ts
================================================
export class PasswordStrengthValidator {
  constructor(private password: string) {}

  async validate(): Promise<void> {
    const errors: string[] = [];

    if (this.password.length < 8) {
      errors.push('Password must be at least 8 characters long');
    }

    if (!/[A-Z]/.test(this.password)) {
      errors.push('Password must contain at least one uppercase letter');
    }

    if (!/[a-z]/.test(this.password)) {
      errors.push('Password must contain at least one lowercase letter');
    }

    if (!/\d/.test(this.password)) {
      errors.push('Password must contain at least one number');
    }

    if (!/[!@#$%^&*(),.?":{}|<>]/.test(this.password)) {
      errors.push('Password must contain at least one special character');
    }

    if (errors.length > 0) {
      throw {
        http_status: 422,
        message: 'Password validation failed',
        validations: [{
          property: 'password',
          errorMessages: errors
        }]
      };
    }
  }
}


================================================
FILE: src/domain/validators/phone-verification.validator.ts
================================================
import { PhoneVerification } from '../entities/phone-verification.entity';
import { BaseValidator } from './validator';

export class PhoneVerificationValidator extends BaseValidator<PhoneVerification> {
  private readonly MAX_ATTEMPTS = 3;

  constructor(phoneVerification: PhoneVerification) {
    super(phoneVerification);
  }

  public async validateWithCustomRules(): Promise<void> {
    await this.validate();

    if (this.isExpired()) {
      this.listErrors.push({
        property: 'expiresAt',
        constraints: {
          isExpired: 'Verification code has expired'
        },
        children: [],
        target: this.entity,
        value: this.entity.expiresAt
      });
    }

    if (this.hasExceededMaxAttempts()) {
      this.listErrors.push({
        property: 'attempts',
        constraints: {
          maxAttemptsExceeded: `Maximum attempts (${this.MAX_ATTEMPTS}) exceeded`
        },
        children: [],
        target: this.entity,
        value: this.entity.attempts
      });
    }

    if (this.entity.isUsed) {
      this.listErrors.push({
        property: 'isUsed',
        constraints: {
          alreadyUsed: 'Verification code has already been used'
        },
        children: [],
        target: this.entity,
        value: this.entity.isUsed
      });
    }

    if (this.hasErrors()) {
      throw {
        http_status: 422,
        validations: this.getFormattedErrors()
      };
    }
  }

  public isExpired(): boolean {
    return new Date() > this.entity.expiresAt;
  }


  public hasExceededMaxAttempts(): boolean {
    return this.entity.attempts >= this.MAX_ATTEMPTS;
  }


  public isValidCode(): boolean {
    return !this.entity.isUsed && !this.isExpired() && !this.hasExceededMaxAttempts();
  }


  public getRemainingAttempts(): number {
    return Math.max(0, this.MAX_ATTEMPTS - this.entity.attempts);
  }
}


================================================
FILE: src/domain/validators/skill.validator.ts
================================================
import { Skill } from '../entities/skill.entity';
import { validate, ValidationError } from 'class-validator';

export class SkillValidator {
  constructor(private skill: Skill) {}

  async validateOrThrow(): Promise<void> {
    const errors: ValidationError[] = await validate(this.skill);

    if (errors.length > 0) {
      const validationErrors = errors.map(error => ({
        property: error.property,
        errorMessages: Object.values(error.constraints || {})
      }));

      throw {
        http_status: 422,
        message: 'Skill validation failed',
        validations: validationErrors
      };
    }
  }

  async validateWithCustomRules(): Promise<void> {
    await this.validateOrThrow();

    if (!this.skill.name || this.skill.name.trim().length === 0) {
      throw {
        http_status: 422,
        message: 'Skill name cannot be empty',
        validations: [{
          property: 'name',
          errorMessages: ['Name cannot be empty or whitespace']
        }]
      };
    }

    if (this.skill.name.trim().length < 2) {
      throw {
        http_status: 422,
        message: 'Skill name too short',
        validations: [{
          property: 'name',
          errorMessages: ['Name must be at least 2 characters long']
        }]
      };
    }

    if (this.skill.name.length > 100) {
      throw {
        http_status: 422,
        message: 'Skill name too long',
        validations: [{
          property: 'name',
          errorMessages: ['Name must not exceed 100 characters']
        }]
      };
    }

    if (this.skill.description && this.skill.description.length > 500) {
      throw {
        http_status: 422,
        message: 'Skill description too long',
        validations: [{
          property: 'description',
          errorMessages: ['Description must not exceed 500 characters']
        }]
      };
    }
  }
}


================================================
FILE: src/domain/validators/user-availability.validator.ts
================================================
import { UserAvailability } from '../entities/user-availability.entity';
import { validate, ValidationError } from 'class-validator';

export class UserAvailabilityValidator {
  constructor(private availability: UserAvailability) {}

  async validateOrThrow(): Promise<void> {
    const errors: ValidationError[] = await validate(this.availability);

    if (errors.length > 0) {
      const validationErrors = errors.map(error => ({
        property: error.property,
        errorMessages: Object.values(error.constraints || {})
      }));

      throw {
        http_status: 422,
        message: 'Availability validation failed',
        validations: validationErrors
      };
    }
  }

  async validateWithCustomRules(): Promise<void> {
    await this.validateOrThrow();

    if (this.availability.userId <= 0) {
      throw {
        http_status: 422,
        message: 'Invalid user ID',
        validations: [{
          property: 'userId',
          errorMessages: ['User ID must be a positive number']
        }]
      };
    }

    const timeRegex = /^([0-1]?[0-9]|2[0-3]):[0-5][0-9]$/;

    if (!timeRegex.test(this.availability.startTime)) {
      throw {
        http_status: 422,
        message: 'Invalid start time format',
        validations: [{
          property: 'startTime',
          errorMessages: ['Start time must be in format HH:mm (e.g., 09:00)']
        }]
      };
    }

    if (!timeRegex.test(this.availability.endTime)) {
      throw {
        http_status: 422,
        message: 'Invalid end time format',
        validations: [{
          property: 'endTime',
          errorMessages: ['End time must be in format HH:mm (e.g., 17:00)']
        }]
      };
    }

    const startMinutes = this.timeToMinutes(this.availability.startTime);
    const endMinutes = this.timeToMinutes(this.availability.endTime);

    if (startMinutes >= endMinutes) {
      throw {
        http_status: 422,
        message: 'Invalid time range',
        validations: [{
          property: 'startTime',
          errorMessages: ['Start time must be before end time']
        }]
      };
    }

    const durationMinutes = endMinutes - startMinutes;
    if (durationMinutes < 30) {
      throw {
        http_status: 422,
        message: 'Availability duration too short',
        validations: [{
          property: 'startTime',
          errorMessages: ['Availability must be at least 30 minutes']
        }]
      };
    }
  }

  private timeToMinutes(time: string): number {
    const [hours, minutes] = time.split(':').map(Number);
    return hours * 60 + minutes;
  }
}


================================================
FILE: src/domain/validators/user-reputation-history.validator.ts
================================================
import { UserReputationHistory } from '../entities/user-reputation-history.entity';
import { validate, ValidationError } from 'class-validator';

export class UserReputationHistoryValidator {
  constructor(private history: UserReputationHistory) {}

  async validateOrThrow(): Promise<void> {
    const errors: ValidationError[] = await validate(this.history);

    if (errors.length > 0) {
      const validationErrors = errors.map(error => ({
        property: error.property,
        errorMessages: Object.values(error.constraints || {})
      }));

      throw {
        http_status: 422,
        message: 'Reputation history validation failed',
        validations: validationErrors
      };
    }
  }

  async validateWithCustomRules(): Promise<void> {
    await this.validateOrThrow();

    if (this.history.userId <= 0) {
      throw {
        http_status: 422,
        message: 'Invalid user ID',
        validations: [{
          property: 'userId',
          errorMessages: ['User ID must be a positive number']
        }]
      };
    }

    if (this.history.changeAmount < -100 || this.history.changeAmount > 100) {
      throw {
        http_status: 422,
        message: 'Invalid change amount',
        validations: [{
          property: 'changeAmount',
          errorMessages: ['Change amount must be between -100 and 100']
        }]
      };
    }

    if (this.history.changeAmount === 0) {
      throw {
        http_status: 422,
        message: 'Invalid change amount',
        validations: [{
          property: 'changeAmount',
          errorMessages: ['Change amount cannot be zero']
        }]
      };
    }

    if (this.history.previousScore < 0 || this.history.previousScore > 100) {
      throw {
        http_status: 422,
        message: 'Invalid previous score',
        validations: [{
          property: 'previousScore',
          errorMessages: ['Previous score must be between 0 and 100']
        }]
      };
    }

    if (this.history.newScore < 0 || this.history.newScore > 100) {
      throw {
        http_status: 422,
        message: 'Invalid new score',
        validations: [{
          property: 'newScore',
          errorMessages: ['New score must be between 0 and 100']
        }]
      };
    }

    const expectedNewScore = Math.max(0, Math.min(100, this.history.previousScore + this.history.changeAmount));
    if (this.history.newScore !== expectedNewScore) {
      throw {
        http_status: 422,
        message: 'Reputation calculation error',
        validations: [{
          property: 'newScore',
          errorMessages: ['New score does not match expected calculation']
        }]
      };
    }

    if (!this.history.reason || this.history.reason.trim().length < 3) {
      throw {
        http_status: 422,
        message: 'Invalid reason',
        validations: [{
          property: 'reason',
          errorMessages: ['Reason must be at least 3 characters long']
        }]
      };
    }

    if (this.history.reason.length > 100) {
      throw {
        http_status: 422,
        message: 'Reason too long',
        validations: [{
          property: 'reason',
          errorMessages: ['Reason must not exceed 100 characters']
        }]
      };
    }

    if (this.history.details && this.history.details.length > 500) {
      throw {
        http_status: 422,
        message: 'Details too long',
        validations: [{
          property: 'details',
          errorMessages: ['Details must not exceed 500 characters']
        }]
      };
    }
  }
}


================================================
FILE: src/domain/validators/user-schedule.validator.ts
================================================
import { UserSchedule } from '../entities/user-schedule.entity';
import { validate, ValidationError } from 'class-validator';

export class UserScheduleValidator {
  constructor(private schedule: UserSchedule) {}

  async validateOrThrow(): Promise<void> {
    const errors: ValidationError[] = await validate(this.schedule);

    if (errors.length > 0) {
      const validationErrors = errors.map(error => ({
        property: error.property,
        errorMessages: Object.values(error.constraints || {})
      }));

      throw {
        http_status: 422,
        message: 'Schedule validation failed',
        validations: validationErrors
      };
    }
  }

  async validateWithCustomRules(): Promise<void> {
    await this.validateOrThrow();

    if (this.schedule.userId <= 0) {
      throw {
        http_status: 422,
        message: 'Invalid user ID',
        validations: [{
          property: 'userId',
          errorMessages: ['User ID must be a positive number']
        }]
      };
    }

    if (this.schedule.startDateTime >= this.schedule.endDateTime) {
      throw {
        http_status: 422,
        message: 'Invalid date range',
        validations: [{
          property: 'startDateTime',
          errorMessages: ['Start date/time must be before end date/time']
        }]
      };
    }

    const now = new Date();
    if (this.schedule.startDateTime < now) {
      throw {
        http_status: 422,
        message: 'Invalid start date',
        validations: [{
          property: 'startDateTime',
          errorMessages: ['Start date/time cannot be in the past']
        }]
      };
    }

    const durationMs = this.schedule.endDateTime.getTime() - this.schedule.startDateTime.getTime();
    const durationMinutes = durationMs / (1000 * 60);

    if (durationMinutes < 30) {
      throw {
        http_status: 422,
        message: 'Schedule duration too short',
        validations: [{
          property: 'startDateTime',
          errorMessages: ['Schedule must be at least 30 minutes long']
        }]
      };
    }

    const maxDurationHours = 24;
    if (durationMinutes > maxDurationHours * 60) {
      throw {
        http_status: 422,
        message: 'Schedule duration too long',
        validations: [{
          property: 'endDateTime',
          errorMessages: [`Schedule cannot exceed ${maxDurationHours} hours`]
        }]
      };
    }

    if (this.schedule.notes && this.schedule.notes.length > 500) {
      throw {
        http_status: 422,
        message: 'Notes too long',
        validations: [{
          property: 'notes',
          errorMessages: ['Notes must not exceed 500 characters']
        }]
      };
    }
  }
}


================================================
FILE: src/domain/validators/user-skill.validator.ts
================================================
import { UserSkill } from '../entities/user-skill.entity';
import { validate, ValidationError } from 'class-validator';

export class UserSkillValidator {
  constructor(private userSkill: UserSkill) {}

  async validateOrThrow(): Promise<void> {
    const errors: ValidationError[] = await validate(this.userSkill);

    if (errors.length > 0) {
      const validationErrors = errors.map(error => ({
        property: error.property,
        errorMessages: Object.values(error.constraints || {})
      }));

      throw {
        http_status: 422,
        message: 'User skill validation failed',
        validations: validationErrors
      };
    }
  }

  async validateWithCustomRules(): Promise<void> {
    await this.validateOrThrow();

    if (this.userSkill.userId <= 0) {
      throw {
        http_status: 422,
        message: 'Invalid user ID',
        validations: [{
          property: 'userId',
          errorMessages: ['User ID must be a positive number']
        }]
      };
    }

    if (this.userSkill.skillId <= 0) {
      throw {
        http_status: 422,
        message: 'Invalid skill ID',
        validations: [{
          property: 'skillId',
          errorMessages: ['Skill ID must be a positive number']
        }]
      };
    }

    if (this.userSkill.proficiencyLevel !== null && this.userSkill.proficiencyLevel !== undefined) {
      if (this.userSkill.proficiencyLevel < 1 || this.userSkill.proficiencyLevel > 5) {
        throw {
          http_status: 422,
          message: 'Invalid proficiency level',
          validations: [{
            property: 'proficiencyLevel',
            errorMessages: ['Proficiency level must be between 1 and 5']
          }]
        };
      }
    }

    if (this.userSkill.yearsOfExperience !== null && this.userSkill.yearsOfExperience !== undefined) {
      if (this.userSkill.yearsOfExperience < 0) {
        throw {
          http_status: 422,
          message: 'Invalid years of experience',
          validations: [{
            property: 'yearsOfExperience',
            errorMessages: ['Years of experience cannot be negative']
          }]
        };
      }

      if (this.userSkill.yearsOfExperience > 100) {
        throw {
          http_status: 422,
          message: 'Invalid years of experience',
          validations: [{
            property: 'yearsOfExperience',
            errorMessages: ['Years of experience seems unrealistic (max 100)']
          }]
        };
      }
    }
  }
}


================================================
FILE: src/domain/validators/user.validator.ts
================================================
import { User } from '../entities/user.entity';
import { BaseValidator } from './validator';

export class UserValidator extends BaseValidator<User> {
  constructor(user: User) {
    super(user);
  }

  public async validateWithCustomRules(): Promise<void> {
    await this.validate();

    if (this.isDisposableEmail(this.entity.email)) {
      this.listErrors.push({
        property: 'email',
        constraints: {
          isDisposable: 'Disposable email addresses are not allowed'
        },
        children: [],
        target: this.entity,
        value: this.entity.email
      });
    }

    if (/^\d+$/.test(this.entity.names)) {
      this.listErrors.push({
        property: 'names',
        constraints: {
          onlyNumbers: 'Names cannot contain only numbers'
        },
        children: [],
        target: this.entity,
        value: this.entity.names
      });
    }

    if (this.hasErrors()) {
      throw {
        http_status: 422,
        validations: this.getFormattedErrors()
      };
    }
  }


  public canPerformActions(): boolean {
    return this.entity.status === 'active';
  }


  public needsVerification(): boolean {
    return !this.entity.verifiedEmail || !this.entity.verifiedPhone;
  }


  private isDisposableEmail(email: string): boolean {
    const disposableDomains = [
      'tempmail.com',
      'guerrillamail.com',
      'mailinator.com',
      '10minutemail.com',
      'throwaway.email'
    ];

    const domain = email.split('@')[1]?.toLowerCase();
    return disposableDomains.includes(domain);
  }
}


================================================
FILE: src/domain/validators/validator.ts
================================================
import { validate, ValidationError } from 'class-validator';

export interface ValidationErrorResponse {
  property: string;
  errorMessages: string[];
}

export abstract class BaseValidator<T extends object> {
  public entity: T;
  public listErrors: ValidationError[];

  constructor(entity: T) {
    this.entity = entity;
    this.listErrors = [];
  }

  public async validateOrThrow(): Promise<void> {
    await this.validate();
    
    if (this.hasErrors()) {
      throw {
        http_status: 422,
        validations: this.getFormattedErrors()
      };
    }
  }

  public async isValid(): Promise<boolean> {
    await this.validate();
    return !this.hasErrors();
  }

  protected async validate(): Promise<void> {
    this.listErrors = await validate(this.entity);
  }


  protected hasErrors(): boolean {
    return this.listErrors.length > 0;
  }

  protected getFormattedErrors(): ValidationErrorResponse[] {
    return this.listErrors.map((error) => ({
      property: error.property,
      errorMessages: Object.values(error.constraints || {})
    }));
  }

  public getErrors(): ValidationError[] {
    return this.listErrors;
  }

  public getFirstError(): string | null {
    if (this.listErrors.length === 0) {
      return null;
    }

    const firstError = this.listErrors[0];
    const constraints = Object.values(firstError.constraints || {});
    return constraints[0] || null;
  }
}


================================================
FILE: src/infrastructure/adapters/email-verification.adapter.ts
================================================
import { Repository } from 'typeorm';
import { AppDataSource } from '../../config/data-source';
import { EmailVerificationSchema } from '../../database/schemas/email-verification.schema';
import { IEmailVerificationRepository } from '../../domain/interfaces/email-verification.repository.interface';
import { EmailVerification } from '../../domain/entities/email-verification.entity';

export class EmailVerificationRepository implements IEmailVerificationRepository {
  private repository: Repository<EmailVerificationSchema>;

  constructor() {
    this.repository = AppDataSource.getRepository(EmailVerificationSchema);
  }

  async save(emailVerification: EmailVerification): Promise<EmailVerification> {
    const schema = this.repository.create({
      userId: emailVerification.userId,
      token: emailVerification.token,
      expiresAt: emailVerification.expiresAt,
      isUsed: emailVerification.isUsed,
      usedAt: emailVerification.usedAt
    });

    const saved = await this.repository.save(schema);
    return this.toDomain(saved);
  }

  async findById(id: number): Promise<EmailVerification | null> {
    const schema = await this.repository.findOne({ where: { id } });
    return schema ? this.toDomain(schema) : null;
  }

  async findByToken(token: string): Promise<EmailVerification | null> {
    const schema = await this.repository.findOne({ where: { token } });
    return schema ? this.toDomain(schema) : null;
  }

  async findByUserId(userId: number): Promise<EmailVerification[]> {
    const schemas = await this.repository.find({ where: { userId } });
    return schemas.map(schema => this.toDomain(schema));
  }

  async findLatestByUserId(userId: number): Promise<EmailVerification | null> {
    const schema = await this.repository.findOne({
      where: { userId },
      order: { createdAt: 'DESC' }
    });
    return schema ? this.toDomain(schema) : null;
  }

  async update(id: number, emailVerification: Partial<EmailVerification>): Promise<EmailVerification> {
    await this.repository.update(id, {
      ...(emailVerification.isUsed !== undefined && { isUsed: emailVerification.isUsed }),
      ...(emailVerification.usedAt !== undefined && { usedAt: emailVerification.usedAt })
    });

    const updated = await this.repository.findOne({ where: { id } });
    if (!updated) {
      throw new Error('Email verification not found after update');
    }
    return this.toDomain(updated);
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  async deleteExpired(): Promise<void> {
    await this.repository
      .createQueryBuilder()
      .delete()
      .where('expires_at < :now', { now: new Date() })
      .execute();
  }

  private toDomain(schema: EmailVerificationSchema): EmailVerification {
    return new EmailVerification(
      schema.id,
      schema.userId,
      schema.token,
      schema.expiresAt,
      schema.isUsed,
      schema.createdAt,
      schema.usedAt
    );
  }
}


================================================
FILE: src/infrastructure/adapters/password-reset-token.adapter.ts
================================================
import { Repository } from 'typeorm';
import { AppDataSource } from '../../config/data-source';
import { PasswordResetTokenSchema } from '../../database/schemas/password-reset-token.schema';
import { IPasswordResetTokenRepository } from '../../domain/interfaces/password-reset-token.repository.interface';
import { PasswordResetToken } from '../../domain/entities/password-reset-token.entity';

export class PasswordResetTokenRepository implements IPasswordResetTokenRepository {
  private repository: Repository<PasswordResetTokenSchema>;

  constructor() {
    this.repository = AppDataSource.getRepository(PasswordResetTokenSchema);
  }

  async save(token: PasswordResetToken): Promise<PasswordResetToken> {
    const schema = this.repository.create({
      userId: token.userId,
      token: token.token,
      expiresAt: token.expiresAt,
      isUsed: token.isUsed,
      usedAt: token.usedAt
    });

    const saved = await this.repository.save(schema);
    return this.toDomain(saved);
  }

  async findById(id: number): Promise<PasswordResetToken | null> {
    const schema = await this.repository.findOne({ where: { id } });
    return schema ? this.toDomain(schema) : null;
  }

  async findByToken(token: string): Promise<PasswordResetToken | null> {
    const schema = await this.repository.findOne({ where: { token } });
    return schema ? this.toDomain(schema) : null;
  }

  async findByUserId(userId: number): Promise<PasswordResetToken[]> {
    const schemas = await this.repository.find({ where: { userId } });
    return schemas.map(schema => this.toDomain(schema));
  }

  async findLatestByUserId(userId: number): Promise<PasswordResetToken | null> {
    const schema = await this.repository.findOne({
      where: { userId },
      order: { createdAt: 'DESC' }
    });
    return schema ? this.toDomain(schema) : null;
  }

  async update(id: number, token: Partial<PasswordResetToken>): Promise<PasswordResetToken> {
    await this.repository.update(id, {
      ...(token.isUsed !== undefined && { isUsed: token.isUsed }),
      ...(token.usedAt !== undefined && { usedAt: token.usedAt })
    });

    const updated = await this.repository.findOne({ where: { id } });
    if (!updated) {
      throw new Error('Password reset token not found after update');
    }
    return this.toDomain(updated);
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  async deleteExpired(): Promise<void> {
    await this.repository
      .createQueryBuilder()
      .delete()
      .where('expires_at < :now', { now: new Date() })
      .execute();
  }

  async invalidateAllByUserId(userId: number): Promise<void> {
    await this.repository.update(
      { userId, isUsed: false },
      { isUsed: true, usedAt: new Date() }
    );
  }

  private toDomain(schema: PasswordResetTokenSchema): PasswordResetToken {
    return new PasswordResetToken(
      schema.id,
      schema.userId,
      schema.token,
      schema.expiresAt,
      schema.isUsed,
      schema.createdAt,
      schema.usedAt
    );
  }
}


================================================
FILE: src/infrastructure/adapters/permission.adapter.ts
================================================
import { Repository } from 'typeorm';
import { AppDataSource } from '../../config/data-source';
import { PermissionSchema } from '../../database/schemas/permission.schema';
import { RoleSchema } from '../../database/schemas/role.schema';
import { UserRoleSchema } from '../../database/schemas/user-role.schema';
import { IPermissionRepository } from '../../domain/interfaces/permission.repository.interface';
import { Permission } from '../../domain/entities/permission.entity';

export class PermissionRepository implements IPermissionRepository {
  private repository: Repository<PermissionSchema>;
  private roleRepository: Repository<RoleSchema>;
  private userRoleRepository: Repository<UserRoleSchema>;

  constructor() {
    this.repository = AppDataSource.getRepository(PermissionSchema);
    this.roleRepository = AppDataSource.getRepository(RoleSchema);
    this.userRoleRepository = AppDataSource.getRepository(UserRoleSchema);
  }

  async save(permission: Permission): Promise<Permission> {
    const schema = this.repository.create({
      module: permission.module,
      action: permission.action,
      resource: permission.resource,
      description: permission.description
    });

    const saved = await this.repository.save(schema);
    return this.toDomain(saved);
  }

  async findById(id: number): Promise<Permission | null> {
    const schema = await this.repository.findOne({ where: { id } });
    return schema ? this.toDomain(schema) : null;
  }

  async findByModuleActionResource(
    module: string,
    action: string,
    resource: string
  ): Promise<Permission | null> {
    const schema = await this.repository.findOne({
      where: { module, action, resource }
    });
    return schema ? this.toDomain(schema) : null;
  }

  async findAll(): Promise<Permission[]> {
    const schemas = await this.repository.find();
    return schemas.map(schema => this.toDomain(schema));
  }

  async findByModule(module: string): Promise<Permission[]> {
    const schemas = await this.repository.find({ where: { module } });
    return schemas.map(schema => this.toDomain(schema));
  }

  async update(id: number, permission: Partial<Permission>): Promise<Permission> {
    await this.repository.update(id, {
      ...(permission.module && { module: permission.module }),
      ...(permission.action && { action: permission.action }),
      ...(permission.resource && { resource: permission.resource }),
      ...(permission.description !== undefined && { description: permission.description })
    });

    const updated = await this.repository.findOne({ where: { id } });
    if (!updated) {
      throw new Error('Permission not found after update');
    }
    return this.toDomain(updated);
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  async assignPermissionToRole(roleId: number, permissionId: number): Promise<void> {
    const role = await this.roleRepository.findOne({
      where: { id: roleId },
      relations: ['permissions']
    });

    if (!role) {
      throw new Error('Role not found');
    }

    const permission = await this.repository.findOne({ where: { id: permissionId } });

    if (!permission) {
      throw new Error('Permission not found');
    }

    if (!role.permissions) {
      role.permissions = [];
    }

    role.permissions.push(permission);
    await this.roleRepository.save(role);
  }

  async removePermissionFromRole(roleId: number, permissionId: number): Promise<void> {
    const role = await this.roleRepository.findOne({
      where: { id: roleId },
      relations: ['permissions']
    });

    if (!role) {
      throw new Error('Role not found');
    }

    role.permissions = role.permissions.filter(p => p.id !== permissionId);
    await this.roleRepository.save(role);
  }

  async getRolePermissions(roleId: number): Promise<Permission[]> {
    const role = await this.roleRepository.findOne({
      where: { id: roleId },
      relations: ['permissions']
    });

    if (!role || !role.permissions) {
      return [];
    }

    return role.permissions.map(schema => this.toDomain(schema));
  }

  async getUserPermissions(userId: number): Promise<Permission[]> {
    // Obtener roles del usuario
    const userRoles = await this.userRoleRepository.find({
      where: { userId },
      relations: ['role', 'role.permissions']
    });

    // Consolidar permisos √∫nicos de todos los roles
    const permissionsMap = new Map<number, PermissionSchema>();

    userRoles.forEach(userRole => {
      if (userRole.role && userRole.role.permissions) {
        userRole.role.permissions.forEach(permission => {
          permissionsMap.set(permission.id, permission);
        });
      }
    });

    return Array.from(permissionsMap.values()).map(schema => this.toDomain(schema));
  }

  async userHasPermission(
    userId: number,
    module: string,
    action: string,
    resource: string
  ): Promise<boolean> {
    const userPermissions = await this.getUserPermissions(userId);

    return userPermissions.some(
      p => p.module === module && p.action === action && p.resource === resource
    );
  }

  private toDomain(schema: PermissionSchema): Permission {
    return new Permission(
      schema.id,
      schema.module,
      schema.action,
      schema.resource,
      schema.description
    );
  }
}


================================================
FILE: src/infrastructure/adapters/phone-verification.adapter.ts
================================================
import { Repository } from 'typeorm';
import { AppDataSource } from '../../config/data-source';
import { PhoneVerificationSchema } from '../../database/schemas/phone-verification.schema';
import { IPhoneVerificationRepository } from '../../domain/interfaces/phone-verification.repository.interface';
import { PhoneVerification } from '../../domain/entities/phone-verification.entity';

export class PhoneVerificationRepository implements IPhoneVerificationRepository {
  private repository: Repository<PhoneVerificationSchema>;

  constructor() {
    this.repository = AppDataSource.getRepository(PhoneVerificationSchema);
  }

  async save(phoneVerification: PhoneVerification): Promise<PhoneVerification> {
    const schema = this.repository.create({
      userId: phoneVerification.userId,
      code: phoneVerification.code,
      expiresAt: phoneVerification.expiresAt,
      isUsed: phoneVerification.isUsed,
      attempts: phoneVerification.attempts,
      usedAt: phoneVerification.usedAt
    });

    const saved = await this.repository.save(schema);
    return this.toDomain(saved);
  }

  async findById(id: number): Promise<PhoneVerification | null> {
    const schema = await this.repository.findOne({ where: { id } });
    return schema ? this.toDomain(schema) : null;
  }

  async findByCode(code: string): Promise<PhoneVerification | null> {
    const schema = await this.repository.findOne({ where: { code } });
    return schema ? this.toDomain(schema) : null;
  }

  async findByUserId(userId: number): Promise<PhoneVerification[]> {
    const schemas = await this.repository.find({ where: { userId } });
    return schemas.map(schema => this.toDomain(schema));
  }

  async findLatestByUserId(userId: number): Promise<PhoneVerification | null> {
    const schema = await this.repository.findOne({
      where: { userId },
      order: { createdAt: 'DESC' }
    });
    return schema ? this.toDomain(schema) : null;
  }

  async update(id: number, phoneVerification: Partial<PhoneVerification>): Promise<PhoneVerification> {
    await this.repository.update(id, {
      ...(phoneVerification.isUsed !== undefined && { isUsed: phoneVerification.isUsed }),
      ...(phoneVerification.attempts !== undefined && { attempts: phoneVerification.attempts }),
      ...(phoneVerification.usedAt !== undefined && { usedAt: phoneVerification.usedAt })
    });

    const updated = await this.repository.findOne({ where: { id } });
    if (!updated) {
      throw new Error('Phone verification not found after update');
    }
    return this.toDomain(updated);
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  async deleteExpired(): Promise<void> {
    await this.repository
      .createQueryBuilder()
      .delete()
      .where('expires_at < :now', { now: new Date() })
      .execute();
  }

  private toDomain(schema: PhoneVerificationSchema): PhoneVerification {
    return new PhoneVerification(
      schema.id,
      schema.userId,
      schema.code,
      schema.expiresAt,
      schema.isUsed,
      schema.attempts,
      schema.createdAt,
      schema.usedAt
    );
  }
}


================================================
FILE: src/infrastructure/adapters/role.adapter.ts
================================================
import { Repository } from 'typeorm';
import { AppDataSource } from '../../config/data-source';
import { RoleSchema } from '../../database/schemas/role.schema';
import { UserRoleSchema } from '../../database/schemas/user-role.schema';
import { IRoleRepository } from '../../domain/interfaces/role.repository.interface';
import { Role } from '../../domain/entities/role.entity';

export class RoleRepository implements IRoleRepository {
  private repository: Repository<RoleSchema>;
  private userRoleRepository: Repository<UserRoleSchema>;

  constructor() {
    this.repository = AppDataSource.getRepository(RoleSchema);
    this.userRoleRepository = AppDataSource.getRepository(UserRoleSchema);
  }

  async save(role: Role): Promise<Role> {
    const schema = this.repository.create({
      name: role.name,
      description: role.description,
      level: role.level
    });

    const saved = await this.repository.save(schema);
    return this.toDomain(saved);
  }

  async findById(id: number): Promise<Role | null> {
    const schema = await this.repository.findOne({ where: { id } });
    return schema ? this.toDomain(schema) : null;
  }

  async findByName(name: string): Promise<Role | null> {
    const schema = await this.repository.findOne({ where: { name } });
    return schema ? this.toDomain(schema) : null;
  }

  async findAll(): Promise<Role[]> {
    const schemas = await this.repository.find();
    return schemas.map(schema => this.toDomain(schema));
  }

  async update(id: number, role: Partial<Role>): Promise<Role> {
    await this.repository.update(id, {
      ...(role.name && { name: role.name }),
      ...(role.description !== undefined && { description: role.description }),
      ...(role.level && { level: role.level }),
      updatedAt: new Date()
    });

    const updated = await this.repository.findOne({ where: { id } });
    if (!updated) {
      throw new Error('Role not found after update');
    }
    return this.toDomain(updated);
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  async existsByName(name: string): Promise<boolean> {
    const count = await this.repository.count({ where: { name } });
    return count > 0;
  }

  async assignRoleToUser(userId: number, roleId: number, assignedBy?: number): Promise<void> {
    const userRole = this.userRoleRepository.create({
      userId,
      roleId,
      assignedBy: assignedBy || null,
      isPrimary: false
    });

    await this.userRoleRepository.save(userRole);
  }

  async removeRoleFromUser(userId: number, roleId: number): Promise<void> {
    await this.userRoleRepository.delete({ userId, roleId });
  }

  async getUserRoles(userId: number): Promise<Role[]> {
    const userRoles = await this.userRoleRepository.find({
      where: { userId },
      relations: ['role']
    });

    return userRoles.map(ur => this.toDomain(ur.role));
  }

  async setPrimaryRole(userId: number, roleId: number): Promise<void> {
    await this.userRoleRepository.update(
      { userId },
      { isPrimary: false }
    );

    await this.userRoleRepository.update(
      { userId, roleId },
      { isPrimary: true }
    );
  }

  private toDomain(schema: RoleSchema): Role {
    return new Role(
      schema.id,
      schema.name,
      schema.description,
      schema.level,
      schema.createdAt,
      schema.updatedAt
    );
  }
}


================================================
FILE: src/infrastructure/adapters/skill.adapter.ts
================================================
import { Repository, DataSource, Like } from 'typeorm';
import { ISkillRepository } from '../../domain/interfaces/skill.repository.interface';
import { Skill } from '../../domain/entities/skill.entity';
import { SkillSchema } from '../../database/schemas/skill.schema';

export class SkillAdapter implements ISkillRepository {
  private repository: Repository<SkillSchema>;

  constructor(dataSource: DataSource) {
    this.repository = dataSource.getRepository(SkillSchema);
  }

  async findById(id: number): Promise<Skill | null> {
    const skillSchema = await this.repository.findOne({ where: { id } });
    if (!skillSchema) return null;
    return this.toDomain(skillSchema);
  }

  async findByName(name: string): Promise<Skill | null> {
    const skillSchema = await this.repository.findOne({ where: { name } });
    if (!skillSchema) return null;
    return this.toDomain(skillSchema);
  }

  async findAll(): Promise<Skill[]> {
    const skillSchemas = await this.repository.find();
    return skillSchemas.map(schema => this.toDomain(schema));
  }

  async findPaginated(params: {
    page: number;
    limit: number;
    search?: string;
    isActive?: boolean;
  }): Promise<{ data: Skill[]; total: number }> {
    const { page, limit, search, isActive } = params;
    const skip = (page - 1) * limit;

    const where: any = {};

    if (isActive !== undefined) {
      where.isActive = isActive;
    }

    if (search) {
      where.name = Like(`%${search}%`);
    }

    const [skillSchemas, total] = await this.repository.findAndCount({
      where,
      skip,
      take: limit,
      order: { name: 'ASC' }
    });

    const data = skillSchemas.map(schema => this.toDomain(schema));

    return { data, total };
  }

  async create(skill: Skill): Promise<Skill> {
    const skillSchema = this.toSchema(skill);
    const saved = await this.repository.save(skillSchema);
    return this.toDomain(saved);
  }

  async update(skill: Skill): Promise<Skill> {
    const skillSchema = this.toSchema(skill);
    await this.repository.save(skillSchema);
    return skill;
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  private toDomain(schema: SkillSchema): Skill {
    return new Skill(
      schema.id,
      schema.name,
      schema.description,
      schema.isActive,
      schema.createdAt,
      schema.updatedAt,
      schema.createdBy
    );
  }

  private toSchema(skill: Skill): SkillSchema {
    const schema = new SkillSchema();
    schema.id = skill.id;
    schema.name = skill.name;
    schema.description = skill.description || '';
    schema.isActive = skill.isActive;
    schema.createdAt = skill.createdAt;
    schema.updatedAt = skill.updatedAt;
    schema.createdBy = skill.createdBy ?? null;
    return schema;
  }
}


================================================
FILE: src/infrastructure/adapters/user-availability.adapter.ts
================================================
import { Repository } from 'typeorm';
import { AppDataSource } from '../../config/data-source';
import { IUserAvailabilityRepository } from '../../domain/interfaces/user-availability.repository.interface';
import { UserAvailability, DayOfWeek } from '../../domain/entities/user-availability.entity';
import { UserAvailabilitySchema } from '../../database/schemas/user-availability.schema';

export class UserAvailabilityAdapter implements IUserAvailabilityRepository {
  private repository: Repository<UserAvailabilitySchema>;

  constructor() {
    this.repository = AppDataSource.getRepository(UserAvailabilitySchema);
  }

  async findById(id: number): Promise<UserAvailability | null> {
    const schema = await this.repository.findOne({ where: { id } });
    return schema ? this.toDomain(schema) : null;
  }

  async findByUserId(userId: number): Promise<UserAvailability[]> {
    const schemas = await this.repository.find({
      where: { userId },
      order: { dayOfWeek: 'ASC', startTime: 'ASC' },
    });
    return schemas.map((s) => this.toDomain(s));
  }

  async findByUserIdAndDay(userId: number, dayOfWeek: DayOfWeek): Promise<UserAvailability[]> {
    const schemas = await this.repository.find({
      where: { userId, dayOfWeek },
      order: { startTime: 'ASC' },
    });
    return schemas.map((s) => this.toDomain(s));
  }

  async create(availability: UserAvailability): Promise<UserAvailability> {
    const schema = this.toSchema(availability);
    const saved = await this.repository.save(schema);
    return this.toDomain(saved);
  }

  async update(availability: UserAvailability): Promise<UserAvailability> {
    const schema = this.toSchema(availability);
    const saved = await this.repository.save(schema);
    return this.toDomain(saved);
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  async deleteByUserId(userId: number): Promise<void> {
    await this.repository.delete({ userId });
  }

  async deleteByUserIdAndDay(userId: number, dayOfWeek: DayOfWeek): Promise<void> {
    await this.repository.delete({ userId, dayOfWeek });
  }

  private toDomain(schema: UserAvailabilitySchema): UserAvailability {
    return new UserAvailability(
      schema.id,
      schema.userId,
      schema.dayOfWeek as DayOfWeek,
      schema.startTime,
      schema.endTime,
      schema.createdAt,
      schema.updatedAt
    );
  }

  private toSchema(availability: UserAvailability): UserAvailabilitySchema {
    const schema = new UserAvailabilitySchema();
    schema.id = availability.id;
    schema.userId = availability.userId;
    schema.dayOfWeek = availability.dayOfWeek;
    schema.startTime = availability.startTime;
    schema.endTime = availability.endTime;
    schema.createdAt = availability.createdAt;
    schema.updatedAt = availability.updatedAt;
    return schema;
  }
}



================================================
FILE: src/infrastructure/adapters/user-reputation-history.adapter.ts
================================================
import { Repository, DataSource, Between, MoreThanOrEqual, LessThanOrEqual } from 'typeorm';
import { IUserReputationHistoryRepository } from '../../domain/interfaces/user-reputation-history.repository.interface';
import { UserReputationHistory } from '../../domain/entities/user-reputation-history.entity';
import { UserReputationHistorySchema } from '../../database/schemas/user-reputation-history.schema';

export class UserReputationHistoryAdapter implements IUserReputationHistoryRepository {
  private repository: Repository<UserReputationHistorySchema>;

  constructor(dataSource: DataSource) {
    this.repository = dataSource.getRepository(UserReputationHistorySchema);
  }

  async findById(id: number): Promise<UserReputationHistory | null> {
    const historySchema = await this.repository.findOne({ where: { id } });
    if (!historySchema) return null;
    return this.toDomain(historySchema);
  }

  async findByUserId(userId: number): Promise<UserReputationHistory[]> {
    const historySchemas = await this.repository.find({
      where: { userId },
      order: { createdAt: 'DESC' }
    });
    return historySchemas.map(schema => this.toDomain(schema));
  }

  async findByUserIdPaginated(params: {
    userId: number;
    page: number;
    limit: number;
    startDate?: Date;
    endDate?: Date;
  }): Promise<{ data: UserReputationHistory[]; total: number }> {
    const { userId, page, limit, startDate, endDate } = params;
    const skip = (page - 1) * limit;

    const where: any = { userId };

    if (startDate && endDate) {
      where.createdAt = Between(startDate, endDate);
    } else if (startDate) {
      where.createdAt = MoreThanOrEqual(startDate);
    } else if (endDate) {
      where.createdAt = LessThanOrEqual(endDate);
    }

    const [historySchemas, total] = await this.repository.findAndCount({
      where,
      skip,
      take: limit,
      order: { createdAt: 'DESC' }
    });

    const data = historySchemas.map(schema => this.toDomain(schema));

    return { data, total };
  }

  async findByEventId(eventId: number): Promise<UserReputationHistory[]> {
    const historySchemas = await this.repository.find({
      where: { relatedEventId: eventId },
      order: { createdAt: 'DESC' }
    });
    return historySchemas.map(schema => this.toDomain(schema));
  }

  async create(history: UserReputationHistory): Promise<UserReputationHistory> {
    const historySchema = this.toSchema(history);
    const saved = await this.repository.save(historySchema);
    return this.toDomain(saved);
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  async deleteByUserId(userId: number): Promise<void> {
    await this.repository.delete({ userId });
  }

  private toDomain(schema: UserReputationHistorySchema): UserReputationHistory {
    return new UserReputationHistory(
      schema.id,
      schema.userId,
      schema.changeAmount,
      schema.previousScore,
      schema.newScore,
      schema.reason,
      schema.details,
      schema.relatedEventId,
      schema.createdAt,
      schema.createdBy
    );
  }

private toSchema(history: UserReputationHistory): UserReputationHistorySchema {
  const schema = new UserReputationHistorySchema();
  schema.id = history.id;
  schema.userId = history.userId;
  schema.changeAmount = history.changeAmount;
  schema.previousScore = history.previousScore;
  schema.newScore = history.newScore;
  schema.reason = history.reason;
  schema.details = history.details || '';
  schema.relatedEventId = history.relatedEventId ?? null; 
  schema.createdAt = history.createdAt;
  schema.createdBy = history.createdBy ?? null;
  return schema;
}

}


================================================
FILE: src/infrastructure/adapters/user-schedule.adapter.ts
================================================
import { Repository, DataSource, LessThanOrEqual, MoreThanOrEqual, Between } from 'typeorm';
import { IUserScheduleRepository } from '../../domain/interfaces/user-schedule.repository.interface';
import { UserSchedule } from '../../domain/entities/user-schedule.entity';
import { UserScheduleSchema } from '../../database/schemas/user-schedule.schema';

export class UserScheduleAdapter implements IUserScheduleRepository {
  private repository: Repository<UserScheduleSchema>;

  constructor(dataSource: DataSource) {
    this.repository = dataSource.getRepository(UserScheduleSchema);
  }

  async findById(id: number): Promise<UserSchedule | null> {
    const scheduleSchema = await this.repository.findOne({ where: { id } });
    if (!scheduleSchema) return null;
    return this.toDomain(scheduleSchema);
  }

  async findByUserId(userId: number): Promise<UserSchedule[]> {
    const scheduleSchemas = await this.repository.find({
      where: { userId },
      order: { startDateTime: 'ASC' }
    });
    return scheduleSchemas.map(schema => this.toDomain(schema));
  }

  async findByUserIdPaginated(params: {
    userId: number;
    page: number;
    limit: number;
    startDate?: Date;
    endDate?: Date;
    eventId?: number;
  }): Promise<{ data: UserSchedule[]; total: number }> {
    const { userId, page, limit, startDate, endDate, eventId } = params;
    const skip = (page - 1) * limit;

    const where: any = { userId };

    if (eventId !== undefined) {
      where.eventId = eventId;
    }

    if (startDate && endDate) {
      where.startDateTime = Between(startDate, endDate);
    } else if (startDate) {
      where.startDateTime = MoreThanOrEqual(startDate);
    } else if (endDate) {
      where.startDateTime = LessThanOrEqual(endDate);
    }

    const [scheduleSchemas, total] = await this.repository.findAndCount({
      where,
      skip,
      take: limit,
      order: { startDateTime: 'ASC' }
    });

    const data = scheduleSchemas.map(schema => this.toDomain(schema));

    return { data, total };
  }

  async findByEventId(eventId: number): Promise<UserSchedule[]> {
    const scheduleSchemas = await this.repository.find({
      where: { eventId },
      order: { startDateTime: 'ASC' }
    });
    return scheduleSchemas.map(schema => this.toDomain(schema));
  }

  async findConflicts(userId: number, startDateTime: Date, endDateTime: Date): Promise<UserSchedule[]> {
    const scheduleSchemas = await this.repository
      .createQueryBuilder('schedule')
      .where('schedule.userId = :userId', { userId })
      .andWhere(
        '(schedule.startDateTime < :endDateTime AND schedule.endDateTime > :startDateTime)',
        { startDateTime, endDateTime }
      )
      .getMany();

    return scheduleSchemas.map(schema => this.toDomain(schema));
  }

  async findConflictsExcluding(
    userId: number,
    startDateTime: Date,
    endDateTime: Date,
    excludeScheduleId: number
  ): Promise<UserSchedule[]> {
    const scheduleSchemas = await this.repository
      .createQueryBuilder('schedule')
      .where('schedule.userId = :userId', { userId })
      .andWhere('schedule.id != :excludeScheduleId', { excludeScheduleId })
      .andWhere(
        '(schedule.startDateTime < :endDateTime AND schedule.endDateTime > :startDateTime)',
        { startDateTime, endDateTime }
      )
      .getMany();

    return scheduleSchemas.map(schema => this.toDomain(schema));
  }

  async create(schedule: UserSchedule): Promise<UserSchedule> {
    const scheduleSchema = this.toSchema(schedule);
    const saved = await this.repository.save(scheduleSchema);
    return this.toDomain(saved);
  }

  async update(schedule: UserSchedule): Promise<UserSchedule> {
    const scheduleSchema = this.toSchema(schedule);
    await this.repository.save(scheduleSchema);
    return schedule;
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  async deleteByUserId(userId: number): Promise<void> {
    await this.repository.delete({ userId });
  }

  async deleteByEventId(eventId: number): Promise<void> {
    await this.repository.delete({ eventId });
  }

  private toDomain(schema: UserScheduleSchema): UserSchedule {
    return new UserSchedule(
      schema.id,
      schema.userId,
      schema.startDateTime,
      schema.endDateTime,
      schema.notes,
      schema.eventId,
      schema.createdAt,
      schema.updatedAt,
      schema.createdBy
    );
  }

  private toSchema(schedule: UserSchedule): UserScheduleSchema {
    const schema = new UserScheduleSchema();
    schema.id = schedule.id;
    schema.userId = schedule.userId;
    schema.startDateTime = schedule.startDateTime;
    schema.endDateTime = schedule.endDateTime;
    schema.notes = schedule.notes ?? null; 
    schema.eventId = schedule.eventId ?? null; 
    schema.createdAt = schedule.createdAt;
    schema.updatedAt = schedule.updatedAt;
    schema.createdBy = schedule.createdBy ?? null;  
    return schema;
  }

}


================================================
FILE: src/infrastructure/adapters/user-skill.adapter.ts
================================================
import { Repository, DataSource } from 'typeorm';
import { IUserSkillRepository } from '../../domain/interfaces/user-skill.repository.interface';
import { UserSkill } from '../../domain/entities/user-skill.entity';
import { UserSkillSchema } from '../../database/schemas/user-skill.schema';

export class UserSkillAdapter implements IUserSkillRepository {
  private repository: Repository<UserSkillSchema>;

  constructor(dataSource: DataSource) {
    this.repository = dataSource.getRepository(UserSkillSchema);
  }

  async findById(id: number): Promise<UserSkill | null> {
    const userSkillSchema = await this.repository.findOne({
      where: { id },
      relations: ['skill']
    });
    if (!userSkillSchema) return null;
    return this.toDomain(userSkillSchema);
  }

  async findByUserId(userId: number): Promise<UserSkill[]> {
    const userSkillSchemas = await this.repository.find({
      where: { userId },
      relations: ['skill'],
      order: { createdAt: 'DESC' }
    });
    return userSkillSchemas.map(schema => this.toDomain(schema));
  }

  async findBySkillId(skillId: number): Promise<UserSkill[]> {
    const userSkillSchemas = await this.repository.find({
      where: { skillId },
      relations: ['user']
    });
    return userSkillSchemas.map(schema => this.toDomain(schema));
  }

  async findByUserIdAndSkillId(userId: number, skillId: number): Promise<UserSkill | null> {
    const userSkillSchema = await this.repository.findOne({
      where: { userId, skillId }
    });
    if (!userSkillSchema) return null;
    return this.toDomain(userSkillSchema);
  }

  async create(userSkill: UserSkill): Promise<UserSkill> {
    const userSkillSchema = this.toSchema(userSkill);
    const saved = await this.repository.save(userSkillSchema);
    return this.toDomain(saved);
  }

  async update(userSkill: UserSkill): Promise<UserSkill> {
    const userSkillSchema = this.toSchema(userSkill);
    await this.repository.save(userSkillSchema);
    return userSkill;
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  async deleteByUserId(userId: number): Promise<void> {
    await this.repository.delete({ userId });
  }

  async deleteByUserIdAndSkillId(userId: number, skillId: number): Promise<void> {
    await this.repository.delete({ userId, skillId });
  }

  private toDomain(schema: UserSkillSchema): UserSkill {
    return new UserSkill(
      schema.id,
      schema.userId,
      schema.skillId,
      schema.proficiencyLevel,
      schema.yearsOfExperience,
      schema.createdAt,
      schema.updatedAt
    );
  }

private toSchema(userSkill: UserSkill): UserSkillSchema {
  const schema = new UserSkillSchema();
  schema.id = userSkill.id;
  schema.userId = userSkill.userId;
  schema.skillId = userSkill.skillId;
  schema.proficiencyLevel = userSkill.proficiencyLevel ?? null;
  schema.yearsOfExperience = userSkill.yearsOfExperience ?? null; 
  schema.createdAt = userSkill.createdAt;
  schema.updatedAt = userSkill.updatedAt;
  return schema;
}

}


================================================
FILE: src/infrastructure/adapters/user.adapter.ts
================================================
import { Repository, DataSource } from 'typeorm';
import { IUserRepository } from '../../domain/interfaces/user.repository.interface';
import { User, UserStatus } from '../../domain/entities/user.entity';
import { UserSchema } from '../../database/schemas/user.schema';

export class UserAdapter implements IUserRepository {
  private repository: Repository<UserSchema>;

  constructor(dataSource: DataSource) {
    this.repository = dataSource.getRepository(UserSchema);
  }

  async findById(id: number): Promise<User | null> {
    const userSchema = await this.repository.findOne({ where: { id } });
    if (!userSchema) return null;
    return this.toDomain(userSchema);
  }

  async findByEmail(email: string): Promise<User | null> {
    const userSchema = await this.repository.findOne({ where: { email } });
    if (!userSchema) return null;
    return this.toDomain(userSchema);
  }

  async findByGoogleUserId(googleUserId: string): Promise<User | null> {
    const userSchema = await this.repository.findOne({ where: { googleUserId } });
    if (!userSchema) return null;
    return this.toDomain(userSchema);
  }

  async findAll(): Promise<User[]> {
    const userSchemas = await this.repository.find();
    return userSchemas.map(schema => this.toDomain(schema));
  }

  async findPaginated(params: {
    page: number;
    limit: number;
    search?: string;
    status?: UserStatus;
    stateId?: number;
    municipalityId?: number;
  }): Promise<{ data: User[]; total: number }> {
    const { page, limit, search, status, stateId, municipalityId } = params;
    const skip = (page - 1) * limit;

    const where: any = {};

    if (status) {
      where.status = status;
    }

    if (stateId !== undefined) {
      where.stateId = stateId;
    }

    if (municipalityId !== undefined) {
      where.municipalityId = municipalityId;
    }

    let queryBuilder = this.repository.createQueryBuilder('user');

    if (status) {
      queryBuilder = queryBuilder.andWhere('user.status = :status', { status });
    }

    if (stateId !== undefined) {
      queryBuilder = queryBuilder.andWhere('user.stateId = :stateId', { stateId });
    }

    if (municipalityId !== undefined) {
      queryBuilder = queryBuilder.andWhere('user.municipalityId = :municipalityId', { municipalityId });
    }

    if (search) {
      queryBuilder = queryBuilder.andWhere(
        '(user.names LIKE :search OR user.firstLastName LIKE :search OR user.secondLastName LIKE :search OR user.email LIKE :search)',
        { search: `%${search}%` }
      );
    }

    const [userSchemas, total] = await queryBuilder
      .skip(skip)
      .take(limit)
      .orderBy('user.createdAt', 'DESC')
      .getManyAndCount();

    const data = userSchemas.map(schema => this.toDomain(schema));

    return { data, total };
  }

  async save(user: User): Promise<User> {
    const userSchema = new UserSchema();
    userSchema.names = user.names;
    userSchema.firstLastName = user.firstLastName;
    userSchema.secondLastName = user.secondLastName;
    userSchema.email = user.email;
    userSchema.passwordHash = user.passwordHash;
    userSchema.imageProfile = user.imageProfile || '';
    userSchema.phoneNumber = user.phoneNumber ?? null;
    userSchema.reputationScore = user.reputationScore;
    userSchema.googleUserId = user.googleUserId ?? null;
    userSchema.status = user.status;
    userSchema.verifiedEmail = user.verifiedEmail;
    userSchema.verifiedPhone = user.verifiedPhone;
    userSchema.emailVerifiedAt = user.emailVerifiedAt ?? null;
    userSchema.phoneVerifiedAt = user.phoneVerifiedAt ?? null;
    userSchema.stateId = user.stateId ?? null;
    userSchema.municipalityId = user.municipalityId ?? null;
    userSchema.createdBy = user.createdBy ?? null;

    const savedUser = await this.repository.save(userSchema);
    return this.toDomain(savedUser);
  }

  async update(user: User): Promise<User> {
    const userSchema = new UserSchema();
    userSchema.id = user.id;
    userSchema.names = user.names;
    userSchema.firstLastName = user.firstLastName;
    userSchema.secondLastName = user.secondLastName;
    userSchema.email = user.email;
    userSchema.passwordHash = user.passwordHash;
    userSchema.imageProfile = user.imageProfile || '';
    userSchema.phoneNumber = user.phoneNumber ?? null;
    userSchema.reputationScore = user.reputationScore;
    userSchema.googleUserId = user.googleUserId ?? null;
    userSchema.status = user.status;
    userSchema.verifiedEmail = user.verifiedEmail;
    userSchema.verifiedPhone = user.verifiedPhone;
    userSchema.emailVerifiedAt = user.emailVerifiedAt ?? null;
    userSchema.phoneVerifiedAt = user.phoneVerifiedAt ?? null;
    userSchema.stateId = user.stateId ?? null;
    userSchema.municipalityId = user.municipalityId ?? null;
    userSchema.updatedAt = user.updatedAt;
    userSchema.createdBy = user.createdBy ?? null;

    await this.repository.save(userSchema);
    return user;
  }

  async delete(id: number): Promise<void> {
    await this.repository.delete(id);
  }

  private toDomain(schema: UserSchema): User {
    return new User(
      schema.id,
      schema.names,
      schema.firstLastName,
      schema.secondLastName,
      schema.email,
      schema.passwordHash,
      schema.imageProfile,
      schema.phoneNumber,
      Number(schema.reputationScore),
      schema.googleUserId,
      schema.status,
      schema.verifiedEmail,
      schema.verifiedPhone,
      schema.emailVerifiedAt,
      schema.phoneVerifiedAt,
      schema.stateId,
      schema.municipalityId,
      schema.createdAt,
      schema.updatedAt,
      schema.createdBy
    );
  }
}


================================================
FILE: src/infrastructure/api/controllers/add-user-skill.controller.ts
================================================
import { Request, Response } from 'express';
import { AddUserSkillUseCase } from '../../../application/use-cases/add-user-skill.use-case';

export class AddUserSkillController {
  constructor(private readonly addUserSkillUseCase: AddUserSkillUseCase) { }

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = req.user?.userId;
      const skillId = parseInt(req.body.skillId);
      
      if (!userId) {
        res.status(401).json({
          success: false,
          message: 'Unauthorized: User ID not found'
        });
        return;
      }

      if (isNaN(skillId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid or missing skillId'
        });
        return;
      }
      
      const dto = {
        userId: userId,
        skillId: skillId,
        proficiencyLevel: req.body.proficiencyLevel ? parseInt(req.body.proficiencyLevel) : undefined,
        yearsOfExperience: req.body.yearsOfExperience ? parseInt(req.body.yearsOfExperience) : undefined,
      };

      const userSkill = await this.addUserSkillUseCase.execute(dto);
      
      res.status(201).json({
        success: true,
        message: 'Skill added successfully',
        data: userSkill
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error adding skill',
        ...(error.validations && { validations: error.validations }) 
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/assign-role.controller.ts
================================================
import { Request, Response } from 'express';
import { AssignRoleUseCase } from '../../../application/use-cases/assign-role.use-case';

export class AssignRoleController {
  constructor(private readonly assignRoleUseCase: AssignRoleUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const userId = parseInt(req.body.userId);
      const roleId = parseInt(req.body.roleId);
      const assignedBy = req.user?.userId;

      if (isNaN(userId) || isNaN(roleId)) {
         res.status(400).json({
          success: false,
          message: 'User ID and Role ID must be valid numbers'
        });
        return;
      }
      
      const dto = {
        userId: userId,
        roleId: roleId,
        isPrimary: req.body.isPrimary || false,
        assignedBy: assignedBy
      };

      const result = await this.assignRoleUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: result.message
      });
    } catch (error: any) {
      if (error.http_status) {
        res.status(error.http_status).json({
          success: false,
          message: error.message || 'Role assignment failed'
        });
      } else {
        console.error('Assign role error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/check-user-availability.controller.ts
================================================
import { Request, Response } from 'express';
import { CheckUserAvailabilityUseCase } from '../../../application/use-cases/check-user-availability.use-case';

export class CheckUserAvailabilityController {
  constructor(private readonly checkUserAvailabilityUseCase: CheckUserAvailabilityUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = parseInt(req.params.userId);
      const startDateTime = new Date(req.body.startDateTime);
      const endDateTime = new Date(req.body.endDateTime);
      const dayOfWeek = req.body.dayOfWeek;

      if (isNaN(userId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid user ID'
        });
        return;
      }

      if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
        res.status(400).json({
          success: false,
          message: 'Invalid date format'
        });
        return;
      }

      const dto = {
        userId: userId,
        startDateTime: startDateTime,
        endDateTime: endDateTime,
        dayOfWeek: dayOfWeek
      };
      
      const result = await this.checkUserAvailabilityUseCase.execute(dto);

      res.status(200).json({
        success: true,
        data: result
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error checking availability'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/check-user-permission.controller.ts
================================================
import { Request, Response } from 'express';
import { CheckUserPermissionUseCase } from '../../../application/use-cases/check-user-permission.use-case';

export class CheckUserPermissionController {
  constructor(private readonly checkUserPermissionUseCase: CheckUserPermissionUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const userId = parseInt(req.params.userId) || req.user!.userId;
      const module = req.body.module || req.query.module as string;
      const action = req.body.action || req.query.action as string;
      const resource = req.body.resource || req.query.resource as string;
      
      if (!module || !action || !resource) {
        res.status(400).json({
          success: false,
          message: 'Module, action, and resource are required'
        });
        return;
      }

      const dto = {
        userId: userId,
        module: module,
        action: action,
        resource: resource
      };

      const result = await this.checkUserPermissionUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        data: result
      });
    } catch (error: any) {
      console.error('Check user permission error:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/complete-profile.controller.ts
================================================
import { Request, Response } from 'express';
import { CompleteProfileUseCase } from '../../../application/use-cases/complete-profile.use-case';

export class CompleteProfileController {
  constructor(private readonly completeProfileUseCase: CompleteProfileUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = parseInt(req.body.userId);
      
      if (isNaN(userId)) {
         res.status(400).json({
          success: false,
          message: 'User ID is required and must be a number'
        });
        return;
      }
      
      const skillIds = req.body.skillIds;
      if (skillIds && !Array.isArray(skillIds)) {
        res.status(400).json({
          success: false,
          message: 'skillIds must be an array'
        });
        return;
      }
      
      const dto = {
        userId: userId,
        skillIds: skillIds
      };
      
      const result = await this.completeProfileUseCase.execute(dto);

      res.status(200).json({
        success: true,
        message: result.message
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error completing profile'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/create-user-schedule.controller.ts
================================================
import { Request, Response } from 'express';
import { CreateUserScheduleUseCase } from '../../../application/use-cases/create-user-schedule.use-case';

export class CreateUserScheduleController {
  constructor(private readonly createUserScheduleUseCase: CreateUserScheduleUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = req.user?.userId;
      const startDateTime = new Date(req.body.startDateTime);
      const endDateTime = new Date(req.body.endDateTime);

      if (!userId) {
        res.status(401).json({
          success: false,
          message: 'Unauthorized'
        });
        return;
      }

      if (isNaN(startDateTime.getTime()) || isNaN(endDateTime.getTime())) {
        res.status(400).json({
          success: false,
          message: 'Invalid date format'
        });
        return;
      }

      const dto = {
        userId: userId,
        startDateTime: startDateTime,
        endDateTime: endDateTime,
        notes: req.body.notes,
        eventId: req.body.eventId ? parseInt(req.body.eventId) : undefined,
        createdBy: userId
      };

      const schedule = await this.createUserScheduleUseCase.execute(dto);

      res.status(201).json({
        success: true,
        message: 'Schedule created successfully',
        data: schedule
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error creating schedule',
        validations: error.validations
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/delete-user-availability.controller.ts
================================================
import { Request, Response } from 'express';
import { IUserAvailabilityRepository } from '../../../domain/interfaces/user-availability.repository.interface';
import { DayOfWeek } from '../../../domain/entities/user-availability.entity'; // Importado de 559

export class DeleteUserAvailabilityController {
  constructor(private readonly userAvailabilityRepository: IUserAvailabilityRepository) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const { dayOfWeek } = req.params;
      
      if (!req.user) {
        res.status(401).json({ success: false, message: 'Unauthorized' });
        return;
      }

      const userId = req.user.userId;
      const normalizedDay = dayOfWeek as DayOfWeek; 

      const validDays: DayOfWeek[] = [
        DayOfWeek.MONDAY, DayOfWeek.TUESDAY, DayOfWeek.WEDNESDAY, DayOfWeek.THURSDAY, DayOfWeek.FRIDAY, DayOfWeek.SATURDAY, DayOfWeek.SUNDAY
      ];
      
      if (!validDays.includes(normalizedDay)) {
        res.status(400).json({ success: false, message: `Invalid dayOfWeek: ${dayOfWeek}` });
        return;
      }

      await this.userAvailabilityRepository.deleteByUserIdAndDay(userId, normalizedDay);

      res.status(200).json({
        success: true,
        message: `Availability for ${normalizedDay} deleted successfully`
      });
    } catch (error) {
      console.error('‚ùå Error deleting availability:', error);
      res.status(500).json({
        success: false,
        message: 'Error deleting user availability'
      });
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/delete-user-schedule.controller.ts
================================================
import { Request, Response } from 'express';
import { DeleteUserScheduleUseCase } from '../../../application/use-cases/delete-user-schedule.use-case';

export class DeleteUserScheduleController {
  constructor(private readonly deleteUserScheduleUseCase: DeleteUserScheduleUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const scheduleId = parseInt(req.params.id);

      if (isNaN(scheduleId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid schedule ID'
        });
        return;
      }

      const dto = { scheduleId: scheduleId };
      await this.deleteUserScheduleUseCase.execute(dto);

      res.status(200).json({
        success: true,
        message: 'Schedule deleted successfully'
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error deleting schedule'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/delete-user.controller.ts
================================================
import { Request, Response } from 'express';
import { DeleteUserUseCase } from '../../../application/use-cases/delete-user.use-case';

export class DeleteUserController {
  constructor(private readonly deleteUserUseCase: DeleteUserUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = parseInt(req.params.id);

      if (isNaN(userId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid user ID'
        });
        return;
      }

      const dto = { userId: userId };
      await this.deleteUserUseCase.execute(dto);

      res.status(200).json({
        success: true,
        message: 'User deleted successfully'
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error deleting user'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/get-my-availability.controller.ts
================================================
import { Request, Response } from 'express';
import { GetUserAvailabilityUseCase } from '../../../application/use-cases/get-user-availability.use-case';

export class GetMyAvailabilityController {
  constructor(private readonly getUserAvailabilityUseCase: GetUserAvailabilityUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = req.user?.userId; 
      const dayOfWeek = req.query.dayOfWeek as string;

      if (!userId) {
        res.status(401).json({
          success: false,
          message: 'Unauthorized: User ID not found in token'
        });
        return;
      }

      const dto = { userId: userId, dayOfWeek: dayOfWeek };
      const availability = await this.getUserAvailabilityUseCase.execute(dto);

      res.status(200).json({
        success: true,
        data: availability
      });
      
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error getting availability'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/get-my-profile.controller.ts
================================================
import { Request, Response } from 'express';
import { GetMyProfileUseCase } from '../../../application/use-cases/get-my-profile.use-case';

export class GetMyProfileController {
  constructor(private readonly getMyProfileUseCase: GetMyProfileUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const userId = req.user?.userId;

      if (!userId) {
        res.status(401).json({
          success: false,
          message: 'Unauthorized: Authentication token required'
        });
        return;
      }

      const result = await this.getMyProfileUseCase.execute(userId);

      res.status(200).json({
        success: true,
        data: result
      });
    } catch (error: any) {
      if (error.http_status) {
        res.status(error.http_status).json({
          success: false,
          message: error.message || 'Error fetching profile'
        });
      } else {
        console.error('Get My Profile error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/get-skills.controller.ts
================================================
import { Request, Response } from 'express';
import { GetSkillsUseCase } from '../../../application/use-cases/get-skills.use-case';

export class GetSkillsController {
  constructor(private readonly getSkillsUseCase: GetSkillsUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 50;
      const search = req.query.search as string;
      
      let isActive: boolean | undefined = undefined;
      if (req.query.isActive !== undefined) {
          isActive = req.query.isActive === 'true';
      }
      
      const dto = {
          page: page,
          limit: limit,
          search: search,
          isActive: isActive
      };
      
      const result = await this.getSkillsUseCase.execute(dto);

      res.status(200).json({
        success: true,
        data: result.data,
        pagination: {
          page: result.page,
          limit: result.limit,
          total: result.total,
          totalPages: result.totalPages
        }
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error getting skills'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/get-user-availability.controller.ts
================================================
import { Request, Response } from 'express';
import { GetUserAvailabilityUseCase } from '../../../application/use-cases/get-user-availability.use-case';

export class GetUserAvailabilityController {
  constructor(private readonly getUserAvailabilityUseCase: GetUserAvailabilityUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = parseInt(req.params.userId);
      const dayOfWeek = req.query.dayOfWeek as string;

      if (isNaN(userId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid user ID'
        });
        return;
      }

      const dto = { userId: userId, dayOfWeek: dayOfWeek };
      const availability = await this.getUserAvailabilityUseCase.execute(dto);

      res.status(200).json({
        success: true,
        data: availability
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error getting availability'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/get-user-by-email.controller.ts
================================================
import { Request, Response } from "express";
import { GetUserByEmailUseCase } from "../../../application/use-cases/get-user-by-email.use-case";

export class GetUserByEmailController {
  constructor(private readonly useCase: GetUserByEmailUseCase) {}

  async handle(req: Request, res: Response) {
    try {
      const { email } = req.params;
      const result = await this.useCase.execute(email);
      res.status(200).json(result);
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || "Internal error"
      });
    }
  }
}



================================================
FILE: src/infrastructure/api/controllers/get-user-by-id.controller.ts
================================================
import { Request, Response } from 'express';
import { GetUserByIdUseCase } from '../../../application/use-cases/get-user-by-id.use-case';

export class GetUserByIdController {
  constructor(private readonly getUserByIdUseCase: GetUserByIdUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = parseInt(req.params.id);

      if (isNaN(userId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid user ID'
        });
        return;
      }

      const dto = { userId: userId };
      const user = await this.getUserByIdUseCase.execute(dto);

      res.status(200).json({
        success: true,
        data: user
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error getting user'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/get-user-permissions.controller.ts
================================================
import { Request, Response } from 'express';
import { GetUserPermissionsUseCase } from '../../../application/use-cases/get-user-permissions.use-case';

export class GetUserPermissionsController {
  constructor(private readonly getUserPermissionsUseCase: GetUserPermissionsUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const userIdParam = parseInt(req.params.userId);
      const userIdToken = req.user?.userId;
      
      const userId = userIdParam || userIdToken;
      
      if (isNaN(userId!)) {
        res.status(400).json({
          success: false,
          message: 'User ID is required'
        });
        return;
      }
      
      const dto = { userId: userId };

      const result = await this.getUserPermissionsUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        data: result
      });
    } catch (error: any) {
      console.error('Get user permissions error:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/get-user-reputation-history.controller.ts
================================================
import { Request, Response } from 'express';
import { GetUserReputationHistoryUseCase } from '../../../application/use-cases/get-user-reputation-history.use-case';

export class GetUserReputationHistoryController {
  constructor(private readonly getUserReputationHistoryUseCase: GetUserReputationHistoryUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = parseInt(req.params.userId);

      if (isNaN(userId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid user ID'
        });
        return;
      }

      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 20;
      
      const startDate = req.query.startDate ? new Date(req.query.startDate as string) : undefined;
      const endDate = req.query.endDate ? new Date(req.query.endDate as string) : undefined;

      const dto = {
        userId: userId,
        startDate: startDate,
        endDate: endDate,
        page: page,
        limit: limit
      };
      
      const result = await this.getUserReputationHistoryUseCase.execute(dto);

      res.status(200).json({
        success: true,
        data: result.data,
        pagination: {
          page: result.page,
          limit: result.limit,
          total: result.total,
          totalPages: result.totalPages
        }
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error getting reputation history'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/get-user-schedules.controller.ts
================================================
import { Request, Response } from 'express';
import { GetUserSchedulesUseCase } from '../../../application/use-cases/get-user-schedules.use-case';

export class GetUserSchedulesController {
  constructor(private readonly getUserSchedulesUseCase: GetUserSchedulesUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = parseInt(req.params.userId);

      if (isNaN(userId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid user ID'
        });
        return;
      }

      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 20;

      const startDate = req.query.startDate ? new Date(req.query.startDate as string) : undefined;
      const endDate = req.query.endDate ? new Date(req.query.endDate as string) : undefined;
      const eventId = req.query.eventId ? parseInt(req.query.eventId as string) : undefined;

      const dto = {
        userId: userId,
        startDate: startDate,
        endDate: endDate,
        eventId: eventId,
        page: page,
        limit: limit
      };
      
      const result = await this.getUserSchedulesUseCase.execute(dto);

      res.status(200).json({
        success: true,
        data: result.data,
        pagination: {
          page: result.page,
          limit: result.limit,
          total: result.total,
          totalPages: result.totalPages
        }
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error getting schedules'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/get-user-skills.controller.ts
================================================
import { Request, Response } from 'express';
import { GetUserSkillsUseCase } from '../../../application/use-cases/get-user-skills.use-case';

export class GetUserSkillsController {
  constructor(private readonly getUserSkillsUseCase: GetUserSkillsUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = parseInt(req.params.userId);

      if (isNaN(userId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid user ID'
        });
        return;
      }

      const dto = { userId: userId };
      const skills = await this.getUserSkillsUseCase.execute(dto);

      res.status(200).json({
        success: true,
        data: skills
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error getting user skills'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/get-users-paginated.controller.ts
================================================
import { Request, Response } from 'express';
import { GetUsersPaginatedUseCase } from '../../../application/use-cases/get-users-paginated.use-case';

export class GetUsersPaginatedController {
  constructor(private readonly getUsersPaginatedUseCase: GetUsersPaginatedUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 10;
      const search = req.query.search as string;
      const status = req.query.status as string;
      const stateId = req.query.stateId ? parseInt(req.query.stateId as string) : undefined;
      const municipalityId = req.query.municipalityId ? parseInt(req.query.municipalityId as string) : undefined;

      const dto = {
        page: page,
        limit: limit,
        search: search,
        status: status,
        stateId: stateId,
        municipalityId: municipalityId
      };
      
      const result = await this.getUsersPaginatedUseCase.execute(dto);

      res.status(200).json({
        success: true,
        data: result.data,
        pagination: {
          page: result.page,
          limit: result.limit,
          total: result.total,
          totalPages: result.totalPages
        }
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error getting users'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/index.ts
================================================
export * from './register-user.controller';
export * from './login-user.controller';
export * from './validate-token.controller';
export * from './refresh-token.controller';
export * from './verify-email.controller';
export * from './resend-email-verification.controller';
export * from './verify-phone.controller';
export * from './resend-phone-verification.controller';
export * from './request-password-reset.controller';
export * from './reset-password.controller';
export * from './assign-role.controller';
export * from './remove-role.controller';
export * from './get-user-permissions.controller';
export * from './check-user-permission.controller';
export * from './get-user-by-id.controller';
export * from './get-users-paginated.controller';
export * from './update-user.controller';
export * from './update-profile.controller';
export * from './delete-user.controller';
export * from './get-skills.controller';
export * from './get-user-skills.controller';
export * from './add-user-skill.controller';
export * from './remove-user-skill.controller';
export * from './set-user-availability.controller';
export * from './get-user-availability.controller';
export * from './check-user-availability.controller';
export * from './create-user-schedule.controller';
export * from './update-user-schedule.controller';
export * from './delete-user-schedule.controller';
export * from './get-user-schedules.controller';
export * from './update-user-reputation.controller';
export * from './get-user-reputation-history.controller';
export * from './complete-profile.controller';
export * from './register-kitchen-admin.controller';
export * from './get-my-availability.controller'
export * from './get-user-by-email.controller'


================================================
FILE: src/infrastructure/api/controllers/login-user.controller.ts
================================================
import { Request, Response } from 'express';
import { LoginUserUseCase } from '../../../application/use-cases/login-user.use-case';

export class LoginUserController {
  constructor(private readonly loginUserUseCase: LoginUserUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const { email, password } = req.body;

      if (!email || !password) {
        res.status(422).json({
          success: false,
          message: 'Validation failed',
          errors: {
            email: !email ? 'Email is required' : undefined,
            password: !password ? 'Password is required' : undefined
          }
        });
        return;
      }

      const result = await this.loginUserUseCase.execute({ email, password });

      res.status(200).json({
        success: true,
        message: 'Login successful',
        data: result
      });

    } catch (error: any) {
      console.error('Login error:', error);

      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Internal server error'
      });
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/refresh-token.controller.ts
================================================
import { Request, Response } from 'express';
import { RefreshTokenUseCase } from '../../../application/use-cases/refresh-token.use-case';

export class RefreshTokenController {
  constructor(private readonly refreshTokenUseCase: RefreshTokenUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const refreshToken = req.body.refreshToken;

      if (!refreshToken) {
        res.status(400).json({
          success: false,
          message: 'Refresh token is required'
        });
        return;
      }
      
      const dto = { refreshToken: refreshToken };
      const result = await this.refreshTokenUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: 'Token refreshed successfully',
        data: result
      });
    } catch (error: any) {
      if (error.http_status) {
        res.status(error.http_status).json({
          success: false,
          message: error.message || 'Token refresh failed'
        });
      } else {
        console.error('Refresh token error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/register-kitchen-admin.controller.ts
================================================
import { Request, Response } from 'express';
import { RegisterAdminKitchenUseCase } from '../../../application/use-cases/register-admin-kitchen.use-case';

export class RegisterKitchenAdminController {
  constructor(private readonly useCase: RegisterAdminKitchenUseCase) {}

  async handle(req: Request, res: Response) {
    try {
      const result = await this.useCase.execute(req.body);
      res.status(201).json(result);
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Internal server error'
      });
    }
  }
}



================================================
FILE: src/infrastructure/api/controllers/register-user.controller.ts
================================================
import { Request, Response } from 'express';
import { RegisterUserUseCase } from '../../../application/use-cases/register-user.use-case';

export class RegisterUserController {
  constructor(private readonly registerUserUseCase: RegisterUserUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const dto = req.body;
      
      if (!dto.email || !dto.password || !dto.names || !dto.firstLastName || !dto.secondLastName || !dto.stateId || !dto.municipalityId) {
         res.status(422).json({
          success: false,
          message: 'Validation failed: Missing required fields.'
        });
        return;
      }
      
      const result = await this.registerUserUseCase.execute(dto);
      
      res.status(201).json({
        success: true,
        message: result.message,
        data: {
          user: {
            id: result.user.id,
            email: result.user.email,
            names: result.user.names,
            fullName: `${result.user.names} ${result.user.firstLastName} ${result.user.secondLastName}`,
            status: result.user.status,
            verifiedEmail: result.user.verifiedEmail,
            verifiedPhone: result.user.verifiedPhone
          }
        }
      });
    } catch (error: any) {
      if (error.http_status) {
        res.status(error.http_status).json({
          success: false,
          message: error.message || 'Registration failed',
          ...(error.validations && { validations: error.validations })
        });
      } else {
        console.error('Register error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/remove-role.controller.ts
================================================
import { Request, Response } from 'express';
import { RemoveRoleUseCase } from '../../../application/use-cases/remove-role.use-case';

export class RemoveRoleController {
  constructor(private readonly removeRoleUseCase: RemoveRoleUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const userId = parseInt(req.body.userId);
      const roleId = parseInt(req.body.roleId);

      if (isNaN(userId) || isNaN(roleId)) {
        res.status(400).json({
          success: false,
          message: 'User ID and Role ID must be valid numbers'
        });
        return;
      }
      
      const dto = { userId: userId, roleId: roleId };
      const result = await this.removeRoleUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: result.message
      });
    } catch (error: any) {
      if (error.http_status) {
        res.status(error.http_status).json({
          success: false,
          message: error.message || 'Role removal failed'
        });
      } else {
        console.error('Remove role error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/remove-user-skill.controller.ts
================================================
import { Request, Response } from 'express';
import { RemoveUserSkillUseCase } from '../../../application/use-cases/remove-user-skill.use-case';

export class RemoveUserSkillController {
  constructor(private readonly removeUserSkillUseCase: RemoveUserSkillUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = req.user?.userId;
      const skillId = parseInt(req.params.skillId);

      if (!userId) {
        res.status(401).json({
          success: false,
          message: 'Unauthorized'
        });
        return;
      }

      if (isNaN(skillId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid skill ID'
        });
        return;
      }

      const dto = { userId: userId, skillId: skillId };
      await this.removeUserSkillUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: 'Skill removed successfully'
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error removing skill'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/request-password-reset.controller.ts
================================================
import { Request, Response } from 'express';
import { RequestPasswordResetUseCase } from '../../../application/use-cases/request-password-reset.use-case';

export class RequestPasswordResetController {
  constructor(private readonly requestPasswordResetUseCase: RequestPasswordResetUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const email = req.body.email;
      
      if (!email) {
        res.status(400).json({
          success: false,
          message: 'Email is required'
        });
        return;
      }
      
      const dto = { email: email };
      const result = await this.requestPasswordResetUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: result.message
      });
    } catch (error: any) {
      console.error('Request password reset error:', error);
      res.status(500).json({
        success: false,
        message: 'Internal server error'
      });
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/resend-email-verification.controller.ts
================================================
import { Request, Response } from 'express';
import { ResendEmailVerificationUseCase } from '../../../application/use-cases/resend-email-verification.use-case';

export class ResendEmailVerificationController {
  constructor(private readonly resendEmailVerificationUseCase: ResendEmailVerificationUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const email = req.body.email;
      
      if (!email) {
        res.status(400).json({
          success: false,
          message: 'Email is required'
        });
        return;
      }
      
      const dto = { email: email };
      const result = await this.resendEmailVerificationUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: result.message
      });
    } catch (error: any) {
      if (error.http_status) {
        res.status(error.http_status).json({
          success: false,
          message: error.message || 'Resend verification failed'
        });
      } else {
        console.error('Resend email verification error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/resend-phone-verification.controller.ts
================================================
import { Request, Response } from 'express';
import { ResendPhoneVerificationUseCase } from '../../../application/use-cases/resend-phone-verification.use-case';

export class ResendPhoneVerificationController {
  constructor(private readonly resendPhoneVerificationUseCase: ResendPhoneVerificationUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const userId = parseInt(req.body.userId);
      
      if (isNaN(userId)) {
        res.status(400).json({
          success: false,
          message: 'User ID is required'
        });
        return;
      }
      
      const dto = { userId: userId };
      const result = await this.resendPhoneVerificationUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: result.message,
        ...(result.code && { code: result.code }) 
      });
    } catch (error: any) {
      if (error.http_status) {
        res.status(error.http_status).json({
          success: false,
          message: error.message || 'Resend phone verification failed'
        });
      } else {
        console.error('Resend phone verification error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/reset-password.controller.ts
================================================
import { Request, Response } from 'express';
import { ResetPasswordUseCase } from '../../../application/use-cases/reset-password.use-case';

export class ResetPasswordController {
  constructor(private readonly resetPasswordUseCase: ResetPasswordUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const token = req.body.token;
      const newPassword = req.body.newPassword;

      if (!token || !newPassword) {
        res.status(400).json({
          success: false,
          message: 'Token and newPassword are required'
        });
        return;
      }
      
      const dto = { token: token, newPassword: newPassword };
      const result = await this.resetPasswordUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: result.message
      });
    } catch (error: any) {
      if (error.http_status) {
        res.status(error.http_status).json({
          success: false,
          message: error.message || 'Password reset failed',
          ...(error.validations && { validations: error.validations })
        });
      } else {
        console.error('Reset password error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/set-user-availability.controller.ts
================================================
import { Request, Response } from 'express';
import { SetUserAvailabilityUseCase } from '../../../application/use-cases/set-user-availability.use-case';

export class SetUserAvailabilityController {
  constructor(private readonly setUserAvailabilityUseCase: SetUserAvailabilityUseCase) {}

  async handle(req: Request, res: Response): Promise<Response> {
    try {
      const userId = req.user?.userId; 
      
      if (!userId) {
        return res.status(401).json({ message: 'Token inv√°lido o no proporcionado' }); 
      }

      const { availabilitySlots } = req.body;
      
      if (!Array.isArray(availabilitySlots)) {
        return res.status(400).json({
          message: 'El campo "availabilitySlots" debe ser un arreglo de objetos v√°lidos', 
        });
      }

      for (const slot of availabilitySlots) {
        if (!slot.dayOfWeek || !slot.startTime || !slot.endTime) {
          return res.status(400).json({
            message: 'Cada slot debe tener dayOfWeek, startTime y endTime', 
          });
        }
      }

      const result = await this.setUserAvailabilityUseCase.execute({
        userId,
        availabilitySlots,
      }); 
      
      return res.status(200).json(result); 
      
    } catch (error: any) {
      console.error('‚ùå Error en SetUserAvailabilityController:', error);
      return res.status(500).json({
        message: error.message || 'Error al actualizar disponibilidad',
      });
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/update-profile.controller.ts
================================================
import { Request, Response } from 'express';
import { UpdateProfileUseCase } from '../../../application/use-cases/update-profile.use-case';

export class UpdateProfileController {
  constructor(private readonly updateProfileUseCase: UpdateProfileUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = req.user?.userId;

      if (!userId) {
        res.status(401).json({
          success: false,
          message: 'Unauthorized'
        });
        return;
      }

      const dto = req.body; 

      const updatedUser = await this.updateProfileUseCase.execute(userId, dto);

      res.status(200).json({
        success: true,
        message: 'Profile updated successfully',
        data: updatedUser
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error updating profile',
        validations: error.validations
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/update-user-availability.controller.ts
================================================
import { Request, Response } from 'express';
import { UpdateUserAvailabilityUseCase } from '../../../application/use-cases/update-user-availability.use-case';
import { DayOfWeek } from '../../../domain/entities/user-availability.entity';

export class UpdateUserAvailabilityController {
  constructor(private readonly updateUserAvailabilityUseCase: UpdateUserAvailabilityUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = req.user?.userId;
      const { dayOfWeek } = req.params;
      const { startTime, endTime } = req.body;
      
      if (!userId) {
        res.status(401).json({ success: false, message: 'Unauthorized' });
        return;
      }

      const validDays: string[] = Object.values(DayOfWeek);
      if (!validDays.includes(dayOfWeek.toLowerCase())) {
         res.status(400).json({ success: false, message: `Invalid dayOfWeek: ${dayOfWeek}` });
         return;
      }

      const result = await this.updateUserAvailabilityUseCase.execute({
        userId,
        dayOfWeek: dayOfWeek as DayOfWeek, 
        startTime,
        endTime
      });
      
      res.status(200).json({
        success: true,
        message: 'Availability updated successfully',
        data: result
      });
    } catch (error: any) {
      res.status(400).json({
        success: false,
        message: error.message || 'Error updating availability'
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/update-user-reputation.controller.ts
================================================
import { Request, Response } from 'express';
import { UpdateUserReputationUseCase } from '../../../application/use-cases/update-user-reputation.use-case';

export class UpdateUserReputationController {
  constructor(private readonly updateUserReputationUseCase: UpdateUserReputationUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = parseInt(req.params.userId);
      const createdBy = req.user?.userId;
      const changeAmount = req.body.changeAmount;

      if (isNaN(userId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid user ID'
        });
        return;
      }
      if (changeAmount === undefined) {
         res.status(400).json({
          success: false,
          message: 'changeAmount is required'
        });
        return;
      }

      const dto = {
        userId: userId,
        changeAmount: changeAmount,
        reason: req.body.reason,
        details: req.body.details,
        relatedEventId: req.body.relatedEventId,
        createdBy: createdBy
      };
      
      const history = await this.updateUserReputationUseCase.execute(dto);

      res.status(200).json({
        success: true,
        message: 'Reputation updated successfully',
        data: history
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error updating reputation',
        validations: error.validations
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/update-user-schedule.controller.ts
================================================
import { Request, Response } from 'express';
import { UpdateUserScheduleUseCase } from '../../../application/use-cases/update-user-schedule.use-case';

export class UpdateUserScheduleController {
  constructor(private readonly updateUserScheduleUseCase: UpdateUserScheduleUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const scheduleId = parseInt(req.params.id);
      let startDateTime: Date | undefined;
      let endDateTime: Date | undefined;

      if (isNaN(scheduleId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid schedule ID'
        });
        return;
      }

      if (req.body.startDateTime) {
        startDateTime = new Date(req.body.startDateTime);
        if (isNaN(startDateTime.getTime())) {
          res.status(400).json({
            success: false,
            message: 'Invalid start date format'
          });
          return;
        }
      }

      if (req.body.endDateTime) {
        endDateTime = new Date(req.body.endDateTime);
        if (isNaN(endDateTime.getTime())) {
          res.status(400).json({
            success: false,
            message: 'Invalid end date format'
          });
          return;
        }
      }

      const dto = {
        scheduleId: scheduleId,
        startDateTime: startDateTime,
        endDateTime: endDateTime,
        notes: req.body.notes,
        eventId: req.body.eventId
      };
      
      const schedule = await this.updateUserScheduleUseCase.execute(dto);

      res.status(200).json({
        success: true,
        message: 'Schedule updated successfully',
        data: schedule
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error updating schedule',
        validations: error.validations
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/update-user.controller.ts
================================================
import { Request, Response } from 'express';
import { UpdateUserUseCase } from '../../../application/use-cases/update-user.use-case';

export class UpdateUserController {
  constructor(private readonly updateUserUseCase: UpdateUserUseCase) {}

  handle = async (req: Request, res: Response): Promise<void> => {
    try {
      const userId = parseInt(req.params.id);

      if (isNaN(userId)) {
        res.status(400).json({
          success: false,
          message: 'Invalid user ID'
        });
        return;
      }
      
      const dto = {
        userId: userId,
        names: req.body.names,
        firstLastName: req.body.firstLastName,
        secondLastName: req.body.secondLastName,
        email: req.body.email,
        phoneNumber: req.body.phoneNumber,
        imageProfile: req.body.imageProfile,
        status: req.body.status,
        reputationScore: req.body.reputationScore,
        stateId: req.body.stateId,
        municipalityId: req.body.municipalityId
      };

      const updatedUser = await this.updateUserUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: 'User updated successfully',
        data: updatedUser
      });
    } catch (error: any) {
      res.status(error.http_status || 500).json({
        success: false,
        message: error.message || 'Error updating user',
        validations: error.validations
      });
    }
  };
}


================================================
FILE: src/infrastructure/api/controllers/validate-token.controller.ts
================================================
import { Request, Response } from 'express';
import { ValidateTokenUseCase } from '../../../application/use-cases/validate-token.use-case';

export class ValidateTokenController {
  constructor(private readonly validateTokenUseCase: ValidateTokenUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const token = req.headers.authorization?.replace('Bearer ', '') || req.body.token;
      
      if (!token) {
        res.status(401).json({
          success: false,
          message: 'Token is required'
        });
        return;
      }
      
      const dto = { token: token };

      const result = await this.validateTokenUseCase.execute(dto);
      
      if (!result.isValid) {
        res.status(401).json({
          success: false,
          message: 'Invalid or expired token'
        });
        return;
      }

      res.status(200).json({
        success: true,
        data: result
      });
    } catch (error: any) {
      console.error('Validate token error:', error);
      res.status(401).json({
        success: false,
        message: 'Invalid token'
      });
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/verify-email.controller.ts
================================================
import { Request, Response } from 'express';
import { VerifyEmailUseCase } from '../../../application/use-cases/verify-email.use-case';

export class VerifyEmailController {
  constructor(private readonly verifyEmailUseCase: VerifyEmailUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const token = req.params.token || req.body.token;
      
      if (!token) {
        res.status(400).json({
          success: false,
          message: 'Token is required'
        });
        return;
      }
      
      const dto = { token: token };
      const result = await this.verifyEmailUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: result.message
      });
    } catch (error: any) {
      if (error.http_status) {
        res.status(error.http_status).json({
          success: false,
          message: error.message || 'Email verification failed'
        });
      } else {
        console.error('Verify email error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    }
  }
}


================================================
FILE: src/infrastructure/api/controllers/verify-phone.controller.ts
================================================
import { Request, Response } from 'express';
import { VerifyPhoneUseCase } from '../../../application/use-cases/verify-phone.use-case';

export class VerifyPhoneController {
  constructor(private readonly verifyPhoneUseCase: VerifyPhoneUseCase) {}

  async handle(req: Request, res: Response): Promise<void> {
    try {
      const userId = parseInt(req.body.userId);
      const code = req.body.code;
      
      if (isNaN(userId) || !code) {
        res.status(400).json({
          success: false,
          message: 'User ID and code are required'
        });
        return;
      }
      
      const dto = { userId: userId, code: code };
      const result = await this.verifyPhoneUseCase.execute(dto);
      
      res.status(200).json({
        success: true,
        message: result.message
      });
    } catch (error: any) {
      if (error.http_status) {
        res.status(error.http_status).json({
          success: false,
          message: error.message || 'Phone verification failed'
        });
      } else {
        console.error('Verify phone error:', error);
        res.status(500).json({
          success: false,
          message: 'Internal server error'
        });
      }
    }
  }
}


================================================
FILE: src/infrastructure/api/dependencies/dependencies.ts
================================================
import { AppDataSource } from '../../../config/data-source';

import { UserAdapter } from '../../adapters/user.adapter';
import { EmailVerificationRepository } from '../../adapters/email-verification.adapter';
import { PhoneVerificationRepository } from '../../adapters/phone-verification.adapter';
import { PasswordResetTokenRepository } from '../../adapters/password-reset-token.adapter';
import { RoleRepository } from '../../adapters/role.adapter';
import { PermissionRepository } from '../../adapters/permission.adapter';
import { SkillAdapter } from '../../adapters/skill.adapter';
import { UserSkillAdapter } from '../../adapters/user-skill.adapter';
import { UserAvailabilityAdapter } from '../../adapters/user-availability.adapter';
import { UserScheduleAdapter } from '../../adapters/user-schedule.adapter';
import { UserReputationHistoryAdapter } from '../../adapters/user-reputation-history.adapter';

import { BcryptPasswordHasherService } from '../../../services/bcrypt-password-hasher.service';
import { JwtTokenGeneratorService } from '../../../services/jwt-token-generator.service';
import { RabbitMQEventPublisherService } from '../../../services/rabbitmq-event-publisher.service';

import {
  RegisterUserUseCase,
  LoginUserUseCase,
  ValidateTokenUseCase,
  RefreshTokenUseCase,
  VerifyEmailUseCase,
  ResendEmailVerificationUseCase,
  VerifyPhoneUseCase,
  ResendPhoneVerificationUseCase,
  RequestPasswordResetUseCase,
  ResetPasswordUseCase,
  AssignRoleUseCase,
  RemoveRoleUseCase,
  GetUserPermissionsUseCase,
  GetUserByEmailUseCase,
  CheckUserPermissionUseCase,
  GetUserByIdUseCase,
  GetUsersPaginatedUseCase,
  UpdateUserUseCase,
  UpdateProfileUseCase,
  DeleteUserUseCase,
  GetSkillsUseCase,
  GetUserSkillsUseCase,
  AddUserSkillUseCase,
  RemoveUserSkillUseCase,
  SetUserAvailabilityUseCase,
  GetUserAvailabilityUseCase,
  CheckUserAvailabilityUseCase,
  CreateUserScheduleUseCase,
  UpdateUserScheduleUseCase,
  DeleteUserScheduleUseCase,
  GetUserSchedulesUseCase,
  UpdateUserReputationUseCase,
  GetUserReputationHistoryUseCase,
  AssignVolunteerRoleUseCase,
  CompleteProfileUseCase,
  RegisterAdminKitchenUseCase
} from '../../../application/use-cases';

import { UpdateUserAvailabilityUseCase } from '../../../application/use-cases/update-user-availability.use-case';
import { GetMyProfileUseCase } from '../../../application/use-cases/get-my-profile.use-case';

import {
  RegisterUserController,
  LoginUserController,
  ValidateTokenController,
  RefreshTokenController,
  VerifyEmailController,
  ResendEmailVerificationController,
  VerifyPhoneController,
  ResendPhoneVerificationController,
  RequestPasswordResetController,
  ResetPasswordController,
  AssignRoleController,
  RemoveRoleController,
  GetUserPermissionsController,
  CheckUserPermissionController,
  GetUserByIdController,
  GetUserByEmailController,
  GetUsersPaginatedController,
  UpdateUserController,
  UpdateProfileController,
  DeleteUserController,
  GetSkillsController,
  GetUserSkillsController,
  AddUserSkillController,
  RemoveUserSkillController,
  SetUserAvailabilityController,
  GetUserAvailabilityController,
  CheckUserAvailabilityController,
  CreateUserScheduleController,
  UpdateUserScheduleController,
  DeleteUserScheduleController,
  GetUserSchedulesController,
  UpdateUserReputationController,
  GetUserReputationHistoryController,
  CompleteProfileController,
  RegisterKitchenAdminController,
  GetMyAvailabilityController
} from '../controllers';

import { UpdateUserAvailabilityController } from '../controllers/update-user-availability.controller';
import { DeleteUserAvailabilityController } from '../controllers/delete-user-availability.controller';
import { GetMyProfileController } from '../controllers/get-my-profile.controller';

const userRepository = new UserAdapter(AppDataSource);
const emailVerificationRepository = new EmailVerificationRepository();
const phoneVerificationRepository = new PhoneVerificationRepository();
const passwordResetTokenRepository = new PasswordResetTokenRepository();
const roleRepository = new RoleRepository();
const permissionRepository = new PermissionRepository();
const skillRepository = new SkillAdapter(AppDataSource);
const userSkillRepository = new UserSkillAdapter(AppDataSource);
const userAvailabilityRepository = new UserAvailabilityAdapter();
const userScheduleRepository = new UserScheduleAdapter(AppDataSource);
const userReputationHistoryRepository = new UserReputationHistoryAdapter(AppDataSource);
const getUserByEmailUseCase = new GetUserByEmailUseCase(userRepository);

const passwordHasher = new BcryptPasswordHasherService();
const tokenGenerator = new JwtTokenGeneratorService();
const eventPublisher = new RabbitMQEventPublisherService();

const registerUserUseCase = new RegisterUserUseCase(
  userRepository,
  passwordHasher,
  eventPublisher,
  roleRepository,
  userSkillRepository,
  skillRepository,
  userAvailabilityRepository
);

const registerKitchenAdminUseCase = new RegisterAdminKitchenUseCase(
  userRepository,
  roleRepository,
  passwordHasher
);

const loginUserUseCase = new LoginUserUseCase(
  userRepository,
  roleRepository,
  passwordHasher,
  tokenGenerator
);

const validateTokenUseCase = new ValidateTokenUseCase(tokenGenerator, userRepository);

const refreshTokenUseCase = new RefreshTokenUseCase(tokenGenerator, userRepository, roleRepository);

const verifyEmailUseCase = new VerifyEmailUseCase(userRepository, emailVerificationRepository, eventPublisher);
const resendEmailVerificationUseCase = new ResendEmailVerificationUseCase(userRepository, emailVerificationRepository, tokenGenerator, eventPublisher);

const verifyPhoneUseCase = new VerifyPhoneUseCase(userRepository, phoneVerificationRepository, eventPublisher);
const resendPhoneVerificationUseCase = new ResendPhoneVerificationUseCase(userRepository, phoneVerificationRepository, tokenGenerator, eventPublisher);

const requestPasswordResetUseCase = new RequestPasswordResetUseCase(userRepository, passwordResetTokenRepository, tokenGenerator, eventPublisher);
const resetPasswordUseCase = new ResetPasswordUseCase(userRepository, passwordResetTokenRepository, passwordHasher, eventPublisher);

const assignRoleUseCase = new AssignRoleUseCase(userRepository, roleRepository, eventPublisher);
const removeRoleUseCase = new RemoveRoleUseCase(userRepository, roleRepository, eventPublisher);
const getUserPermissionsUseCase = new GetUserPermissionsUseCase(permissionRepository);
const checkUserPermissionUseCase = new CheckUserPermissionUseCase(permissionRepository);

const getSkillsUseCase = new GetSkillsUseCase(skillRepository);
const getUserSkillsUseCase = new GetUserSkillsUseCase(userSkillRepository, userRepository);
const addUserSkillUseCase = new AddUserSkillUseCase(userSkillRepository, userRepository, skillRepository);
const removeUserSkillUseCase = new RemoveUserSkillUseCase(userSkillRepository, userRepository);

const setUserAvailabilityUseCase = new SetUserAvailabilityUseCase(userAvailabilityRepository, userRepository);
const updateUserAvailabilityUseCase = new UpdateUserAvailabilityUseCase(userAvailabilityRepository, userRepository);
const getUserAvailabilityUseCase = new GetUserAvailabilityUseCase(userAvailabilityRepository, userRepository);
const checkUserAvailabilityUseCase = new CheckUserAvailabilityUseCase(userAvailabilityRepository, userScheduleRepository, userRepository);

const createUserScheduleUseCase = new CreateUserScheduleUseCase(userScheduleRepository, userRepository);
const updateUserScheduleUseCase = new UpdateUserScheduleUseCase(userScheduleRepository);
const deleteUserScheduleUseCase = new DeleteUserScheduleUseCase(userScheduleRepository);
const getUserSchedulesUseCase = new GetUserSchedulesUseCase(userScheduleRepository, userRepository);

const updateUserReputationUseCase = new UpdateUserReputationUseCase(userRepository, userReputationHistoryRepository);
const getUserReputationHistoryUseCase = new GetUserReputationHistoryUseCase(userRepository, userReputationHistoryRepository);

const updateProfileUseCase = new UpdateProfileUseCase(userRepository);
const completeProfileUseCase = new CompleteProfileUseCase(
  userRepository,
  userSkillRepository,
  skillRepository,
  new AssignVolunteerRoleUseCase(userRepository, roleRepository)
);

const getMyProfileUseCase = new GetMyProfileUseCase(userRepository, userSkillRepository, userAvailabilityRepository);

export const registerUserController = new RegisterUserController(registerUserUseCase);
export const registerKitchenAdminController = new RegisterKitchenAdminController(registerKitchenAdminUseCase);
export const loginUserController = new LoginUserController(loginUserUseCase);
export const validateTokenController = new ValidateTokenController(validateTokenUseCase);
export const refreshTokenController = new RefreshTokenController(refreshTokenUseCase);
export const verifyEmailController = new VerifyEmailController(verifyEmailUseCase);
export const resendEmailVerificationController = new ResendEmailVerificationController(resendEmailVerificationUseCase);
export const verifyPhoneController = new VerifyPhoneController(verifyPhoneUseCase);
export const resendPhoneVerificationController = new ResendPhoneVerificationController(resendPhoneVerificationUseCase);
export const requestPasswordResetController = new RequestPasswordResetController(requestPasswordResetUseCase);
export const resetPasswordController = new ResetPasswordController(resetPasswordUseCase);
export const assignRoleController = new AssignRoleController(assignRoleUseCase);
export const removeRoleController = new RemoveRoleController(removeRoleUseCase);
export const getUserPermissionsController = new GetUserPermissionsController(getUserPermissionsUseCase);
export const getUserByEmailController = new GetUserByEmailController(getUserByEmailUseCase);
export const checkUserPermissionController = new CheckUserPermissionController(checkUserPermissionUseCase);
export const getUserByIdController = new GetUserByIdController(new GetUserByIdUseCase(userRepository));
export const getUsersPaginatedController = new GetUsersPaginatedController(new GetUsersPaginatedUseCase(userRepository));
export const updateUserController = new UpdateUserController(new UpdateUserUseCase(userRepository));
export const updateProfileController = new UpdateProfileController(updateProfileUseCase);
export const deleteUserController = new DeleteUserController(new DeleteUserUseCase(userRepository));
export const getSkillsController = new GetSkillsController(getSkillsUseCase);
export const getUserSkillsController = new GetUserSkillsController(getUserSkillsUseCase);
export const addUserSkillController = new AddUserSkillController(addUserSkillUseCase);
export const removeUserSkillController = new RemoveUserSkillController(removeUserSkillUseCase);
export const setUserAvailabilityController = new SetUserAvailabilityController(setUserAvailabilityUseCase);
export const updateUserAvailabilityController = new UpdateUserAvailabilityController(updateUserAvailabilityUseCase);
export const deleteUserAvailabilityController = new DeleteUserAvailabilityController(userAvailabilityRepository);
export const getUserAvailabilityController = new GetUserAvailabilityController(getUserAvailabilityUseCase);
export const checkUserAvailabilityController = new CheckUserAvailabilityController(checkUserAvailabilityUseCase);
export const createUserScheduleController = new CreateUserScheduleController(createUserScheduleUseCase);
export const updateUserScheduleController = new UpdateUserScheduleController(updateUserScheduleUseCase);
export const deleteUserScheduleController = new DeleteUserScheduleController(deleteUserScheduleUseCase);
export const getUserSchedulesController = new GetUserSchedulesController(getUserSchedulesUseCase);
export const updateUserReputationController = new UpdateUserReputationController(updateUserReputationUseCase);
export const getUserReputationHistoryController = new GetUserReputationHistoryController(getUserReputationHistoryUseCase);
export const completeProfileController = new CompleteProfileController(completeProfileUseCase);
export const getMyProfileController = new GetMyProfileController(getMyProfileUseCase);
export const getMyAvailabilityController = new GetMyAvailabilityController(getUserAvailabilityUseCase);

export { tokenGenerator, eventPublisher, registerKitchenAdminUseCase };



================================================
FILE: src/infrastructure/api/routes/auth.routes.ts
================================================
import { Router } from 'express';
import {
  registerUserController,
  loginUserController,
  validateTokenController,
  refreshTokenController,
  registerKitchenAdminController
} from '../dependencies/dependencies';

const router = Router();

router.post('/register', registerUserController.handle.bind(registerUserController));

router.post('/register-kitchen-admin', registerKitchenAdminController.handle.bind(registerKitchenAdminController));

router.post('/login', loginUserController.handle.bind(loginUserController));

router.post('/validate-token', validateTokenController.handle.bind(validateTokenController));

router.post('/refresh-token', refreshTokenController.handle.bind(refreshTokenController));

export default router;



================================================
FILE: src/infrastructure/api/routes/availability.routes.ts
================================================
import { Router } from 'express';
import {
  setUserAvailabilityController,
  getUserAvailabilityController,
  checkUserAvailabilityController,
  updateUserAvailabilityController,
  deleteUserAvailabilityController,
  getMyAvailabilityController 
} from '../dependencies/dependencies';
import { AuthMiddleware } from '../../../middleware/auth.middleware'; 

const router = Router();
const authMiddleware = new AuthMiddleware();

router.get('/me', authMiddleware.authenticate, getMyAvailabilityController.handle.bind(getMyAvailabilityController));

router.post('/me', authMiddleware.authenticate, setUserAvailabilityController.handle.bind(setUserAvailabilityController));

router.put('/me/:dayOfWeek', authMiddleware.authenticate, updateUserAvailabilityController.handle.bind(updateUserAvailabilityController));

router.delete('/me/:dayOfWeek', authMiddleware.authenticate, deleteUserAvailabilityController.handle.bind(deleteUserAvailabilityController));

router.get('/:userId', getUserAvailabilityController.handle.bind(getUserAvailabilityController));

router.post('/:userId/check', checkUserAvailabilityController.handle.bind(checkUserAvailabilityController));

export default router;


================================================
FILE: src/infrastructure/api/routes/password.routes.ts
================================================
import { Router } from 'express';
import {
  verifyEmailController,
  resendEmailVerificationController,
  verifyPhoneController,
  resendPhoneVerificationController
} from '../dependencies/dependencies';

const router = Router();

router.get('/email/:token', verifyEmailController.handle.bind(resendEmailVerificationController));

router.post('/email/resend', resendEmailVerificationController.handle.bind(resendEmailVerificationController));

router.post('/phone', verifyPhoneController.handle.bind(verifyPhoneController));

router.post('/phone/resend', resendPhoneVerificationController.handle.bind(resendPhoneVerificationController));

export default router;


================================================
FILE: src/infrastructure/api/routes/permission.routes.ts
================================================
import { Router } from 'express';
import {
  getUserPermissionsController,
  checkUserPermissionController
} from '../dependencies/dependencies';
import { AuthMiddleware } from '../../../middleware/auth.middleware';

const router = Router();
const authMiddleware = new AuthMiddleware();

router.get('/user/:userId', authMiddleware.authenticate, getUserPermissionsController.handle.bind(getUserPermissionsController));

router.post('/check', authMiddleware.authenticate, checkUserPermissionController.handle.bind(checkUserPermissionController)
);

export default router;



================================================
FILE: src/infrastructure/api/routes/reputation.routes.ts
================================================
import { Router } from 'express';
import {
  updateUserReputationController,
  getUserReputationHistoryController
} from '../dependencies/dependencies';

const router = Router();

router.get('/:userId/history', getUserReputationHistoryController.handle.bind(getUserReputationHistoryController));

router.post('/:userId', updateUserReputationController.handle.bind(updateUserReputationController));

export default router;


================================================
FILE: src/infrastructure/api/routes/role.routes.ts
================================================
import { Router } from 'express';
import {
  assignRoleController,
  removeRoleController
} from '../dependencies/dependencies';
import { AuthMiddleware } from '../../../middleware/auth.middleware';

const router = Router();
const authMiddleware = new AuthMiddleware();

router.post('/assign',authMiddleware.authenticate, authMiddleware.authorize('admin', 'superadmin'), assignRoleController.handle.bind(assignRoleController)
);

router.post('/remove', authMiddleware.authenticate, authMiddleware.authorize('admin', 'superadmin'), removeRoleController.handle.bind(removeRoleController)
);

export default router;



================================================
FILE: src/infrastructure/api/routes/schedule.routes.ts
================================================
import { Router } from 'express';
import {
  createUserScheduleController,
  updateUserScheduleController,
  deleteUserScheduleController,
  getUserSchedulesController
} from '../dependencies/dependencies';
import { AuthMiddleware } from '../../../middleware/auth.middleware'; 

const router = Router();
const authMiddleware = new AuthMiddleware(); 

router.get('/user/:userId', authMiddleware.authenticate, getUserSchedulesController.handle.bind(getUserSchedulesController));

router.post('/', authMiddleware.authenticate, createUserScheduleController.handle.bind(createUserScheduleController));

router.put('/:id', authMiddleware.authenticate, updateUserScheduleController.handle.bind(updateUserScheduleController));

router.delete('/:id', authMiddleware.authenticate, deleteUserScheduleController.handle.bind(deleteUserScheduleController));

export default router;


================================================
FILE: src/infrastructure/api/routes/skill.routes.ts
================================================
import { Router } from 'express';
import {
  getSkillsController,
  getUserSkillsController,
  addUserSkillController,
  removeUserSkillController,
  getUserByEmailController
} from '../dependencies/dependencies';
import { AuthMiddleware } from '../../../middleware/auth.middleware'; 

const router = Router();
const authMiddleware = new AuthMiddleware(); 

router.get("/by-email/:email", getUserByEmailController.handle.bind(getUserByEmailController));

router.get('/', getSkillsController.handle.bind(getSkillsController));

router.get('/user/:userId', authMiddleware.authenticate, getUserSkillsController.handle.bind(getUserSkillsController));

router.post('/me', authMiddleware.authenticate, addUserSkillController.handle.bind(addUserSkillController));

router.delete('/me/:skillId', authMiddleware.authenticate, removeUserSkillController.handle.bind(removeUserSkillController));

export default router;


================================================
FILE: src/infrastructure/api/routes/user.routes.ts
================================================
import { Router } from 'express';
import {
  getUserByIdController,
  getUsersPaginatedController,
  updateUserController,
  updateProfileController,
  deleteUserController,
  completeProfileController,
  getMyProfileController
} from '../dependencies/dependencies';
import { AuthMiddleware } from '../../../middleware/auth.middleware'; 

const authMiddleware = new AuthMiddleware(); 

const router = Router();

router.get('/', getUsersPaginatedController.handle.bind(getUsersPaginatedController));

router.get('/profile', authMiddleware.authenticate, getMyProfileController.handle.bind(getMyProfileController)); 

router.get('/:id', authMiddleware.authenticate, getUserByIdController.handle.bind(getUserByIdController));

router.put('/profile', authMiddleware.authenticate, updateProfileController.handle.bind(updateProfileController));

router.put('/:id', updateUserController.handle.bind(updateUserController));

router.delete('/:id', deleteUserController.handle.bind(deleteUserController));

router.post('/complete-profile', authMiddleware.authenticate, completeProfileController.handle.bind(completeProfileController));

export default router;


================================================
FILE: src/infrastructure/api/routes/verification.routes.ts
================================================
import { Router } from 'express';
import {
  verifyEmailController,
  resendEmailVerificationController,
  verifyPhoneController,
  resendPhoneVerificationController
} from '../dependencies/dependencies';

const router = Router();

router.get('/email/:token', verifyEmailController.handle.bind(verifyEmailController));

router.post('/email/resend', resendEmailVerificationController.handle.bind(resendEmailVerificationController));

router.post('/phone', verifyPhoneController.handle.bind(verifyPhoneController));

router.post('/phone/resend', resendPhoneVerificationController.handle.bind(resendPhoneVerificationController));

export default router;



================================================
FILE: src/middleware/auth.middleware.ts
================================================
import { Request, Response, NextFunction } from 'express';
import { JwtTokenGeneratorService } from '../services/jwt-token-generator.service';

declare global {
  namespace Express {
    interface Request {
      user?: {
        userId: number;
        email: string;
        roles?: string[];
        stateId: number | null;
        municipalityId: number | null;
      };
    }
  }
}

export class AuthMiddleware {
  private tokenGenerator: JwtTokenGeneratorService;

  constructor() {
    this.tokenGenerator = new JwtTokenGeneratorService();
  }

  authenticate = (req: Request, res: Response, next: NextFunction): void => {
    try {
      const authHeader = req.headers.authorization;

      if (!authHeader || !authHeader.startsWith('Bearer ')) {
        res.status(401).json({
          success: false,
          message: 'Token inv√°lido o no proporcionado'
        });
        return;
      }

      const token = authHeader.substring(7);

      const payload = this.tokenGenerator.verifyAccessToken(token);

      req.user = {
        userId: payload.userId,
        email: payload.email,
        roles: payload.roles,
        stateId: payload.stateId,
        municipalityId: payload.municipalityId
      };

      next();
    } catch (error: any) {
      res.status(401).json({
        success: false,
        message: 'Token inv√°lido o expirado'
      });
    }
  };

  authorize = (...allowedRoles: string[]) => {
    return (req: Request, res: Response, next: NextFunction): void => {
      if (!req.user) {
        res.status(401).json({
          success: false,
          message: 'Autenticaci√≥n requerida'
        });
        return;
      }

      const userRoles = req.user.roles || [];
      const hasRole = allowedRoles.some(role => userRoles.includes(role));

      if (!hasRole) {
        res.status(403).json({
          success: false,
          message: 'Permisos insuficientes',
          requiredRoles: allowedRoles,
          userRoles
        });
        return;
      }

      next();
    };
  };
}


================================================
FILE: src/services/bcrypt-password-hasher.service.ts
================================================
import bcrypt from 'bcrypt';
import { IPasswordHasher } from '../domain/interfaces/password-hasher.interface';

export class BcryptPasswordHasherService implements IPasswordHasher {
  private readonly saltRounds: number;

  constructor() {
    this.saltRounds = parseInt(process.env.BCRYPT_SALT_ROUNDS || '10');
  }

  async hash(password: string): Promise<string> {
    return bcrypt.hash(password, this.saltRounds);
  }

  async compare(password: string, hashedPassword: string): Promise<boolean> {
    return bcrypt.compare(password, hashedPassword);
  }
}


================================================
FILE: src/services/jwt-token-generator.service.ts
================================================
import jwt, { SignOptions } from 'jsonwebtoken';
import { v4 as uuidv4 } from 'uuid';
import {
  ITokenGenerator,
  TokenPayload,
  RefreshTokenPayload
} from '../domain/interfaces/token-generator.interface';

export class JwtTokenGeneratorService implements ITokenGenerator {
  private readonly accessTokenSecret: string;
  private readonly accessTokenExpiresIn: string;
  private readonly refreshTokenSecret: string;
  private readonly refreshTokenExpiresIn: string;

  constructor() {
    this.accessTokenSecret = process.env.JWT_SECRET || 'your-secret-key';
    this.accessTokenExpiresIn = process.env.JWT_EXPIRES_IN || '7d';
    this.refreshTokenSecret = process.env.JWT_REFRESH_SECRET || 'your-refresh-secret';
    this.refreshTokenExpiresIn = process.env.JWT_REFRESH_EXPIRES_IN || '30d';
  }

  generateAccessToken(
    userId: number,
    email: string,
    roles: string[] = [],
    stateId: number | null = null,
    municipalityId: number | null = null
  ): string {
    
    const payload: TokenPayload = {
      userId,
      email,
      roles,
      stateId,
      municipalityId
    };

    const options: SignOptions = {
      expiresIn: this.accessTokenExpiresIn as any,
      issuer: 'auth-service',
      audience: 'kitchen-volunteers-app'
    };

    return jwt.sign(payload, this.accessTokenSecret, options);
  }

  generateRefreshToken(userId: number): string {
    const payload: RefreshTokenPayload = { userId };

    const options: SignOptions = {
      expiresIn: this.refreshTokenExpiresIn as any,
      issuer: 'auth-service',
      audience: 'kitchen-volunteers-app'
    };

    return jwt.sign(payload, this.refreshTokenSecret, options);
  }

  verifyAccessToken(token: string): TokenPayload {
    try {
      const decoded = jwt.verify(token, this.accessTokenSecret, {
        issuer: 'auth-service',
        audience: 'kitchen-volunteers-app'
      });

      return decoded as TokenPayload;
    } catch (error) {
      throw new Error('Invalid or expired access token');
    }
  }

  verifyRefreshToken(token: string): RefreshTokenPayload {
    try {
      const decoded = jwt.verify(token, this.refreshTokenSecret, {
        issuer: 'auth-service',
        audience: 'kitchen-volunteers-app'
      });

      return decoded as RefreshTokenPayload;
    } catch (error) {
      throw new Error('Invalid or expired refresh token');
    }
  }

  generateRandomToken(): string {
    return uuidv4();
  }

  generateNumericCode(length: number = 6): string {
    let code = '';
    for (let i = 0; i < length; i++) {
      code += Math.floor(Math.random() * 10).toString();
    }
    return code;
  }
}


================================================
FILE: src/services/kitchen-approved.consumer.service.ts
================================================
import amqp from "amqplib";
import { rabbitmqConfig } from "../config/rabbitmq.config";
import { RegisterAdminKitchenUseCase } from "../application/use-cases/register-admin-kitchen.use-case";

export class KitchenApprovedConsumerService {
  private connection: amqp.Connection | null = null;
  private channel: amqp.Channel | null = null;

  constructor(private readonly registerUseCase: RegisterAdminKitchenUseCase) {}

  async connect() {
    if (!rabbitmqConfig.url) {
      throw new Error("RabbitMQ URL is undefined");
    }

    this.connection = await amqp.connect(rabbitmqConfig.url);
    this.channel = await this.connection.createChannel();

    await this.channel.assertExchange(rabbitmqConfig.exchange, "topic", {
      durable: true,
    });

    const authQueue = rabbitmqConfig.queues.auth;
    if (!authQueue) {
      throw new Error("‚ùå rabbitmqConfig.queues.auth is undefined");
    }

    await this.channel.assertQueue(authQueue, { durable: true });

    await this.channel.bindQueue(
      authQueue,
      rabbitmqConfig.exchange,
      rabbitmqConfig.routingKeys.kitchenAdminRegistered
    );

    console.log("üì• [AUTH] KitchenApprovedConsumer READY");
  }

  async start() {
    if (!this.channel) await this.connect();

    const authQueue = rabbitmqConfig.queues.auth!;
    
    this.channel!.consume(
      authQueue,
      async (msg) => {
        if (!msg) return;

        const raw = msg.content.toString();
        let data: any;

        try {
          data = JSON.parse(raw);
        } catch {
          console.error("‚ùå Invalid JSON in received event:", raw);
          this.channel!.ack(msg); 
          return;
        }

        console.log("üì¶ [AUTH] Event received:", data);

        const required = ["names", "firstLastName", "email", "phoneNumber", "password"];

        for (const field of required) {
          if (!data[field]) {
            console.error(`‚ùå Missing field '${field}' in event`);
            this.channel!.ack(msg);
            return;
          }
        }

        try {
          await this.registerUseCase.execute(data);
          this.channel!.ack(msg);
        } catch (err) {
          console.error("‚ùå Error processing event:", err);
          this.channel!.nack(msg, false, false); 
        }
      },
      { noAck: false }
    );
  }
}


================================================
FILE: src/services/rabbitmq-event-publisher.service.ts
================================================
import { connect } from 'amqplib';
import { IEventPublisher } from '../domain/interfaces/event-publisher.interface';
import { rabbitmqConfig } from '../config/rabbitmq.config';

export class RabbitMQEventPublisherService implements IEventPublisher {
  private connection: any = null;
  private channel: any = null;
  private readonly exchange: string;
  private readonly exchangeType: string;

  constructor() {
    this.exchange = rabbitmqConfig.exchange;
    this.exchangeType = rabbitmqConfig.exchangeType;
  }

  async connect(): Promise<void> {
    try {
      this.connection = await connect(rabbitmqConfig.url);
      this.channel = await this.connection.createChannel();

      await this.channel.assertExchange(this.exchange, this.exchangeType, {
        durable: rabbitmqConfig.options.durable
      });

      console.log('‚úÖ [AUTH] RabbitMQ connected successfully to exchange:', this.exchange);
    } catch (error) {
      console.error('‚ùå [AUTH] Error connecting to RabbitMQ:', error);
      throw error;
    }
  }

  async publish(eventName: string, data: any): Promise<void> {
    if (!this.channel) {
      await this.connect();
    }

    const message = JSON.stringify(data);

    this.channel!.publish(
      this.exchange,
      eventName,
      Buffer.from(message),
      { persistent: rabbitmqConfig.options.persistent }
    );

    console.log(`üì§ [AUTH] Event published: ${eventName}`);
    
    console.log('üì¶ [AUTH] Payload:', message);
  }

  async publishBatch(events: Array<{ eventName: string; data: any }>): Promise<void> {
    if (!this.channel) {
      await this.connect();
    }

    for (const event of events) {
      await this.publish(event.eventName, event.data);
    }
  }

  async close(): Promise<void> {
    try {
      if (this.channel) {
        await this.channel.close();
      }
      if (this.connection) {
        await this.connection.close();
      }
      console.log('‚úÖ RabbitMQ connection closed');
    } catch (error) {
      console.error('‚ùå Error closing RabbitMQ connection:', error);
    }
  }
}


================================================
FILE: src/types/amqplib.d.ts
================================================
declare module "amqplib" {
  export interface Connection {
    createChannel(): Promise<Channel>;
    close(): Promise<void>;
  }

  export interface Channel {
    assertExchange(
      exchange: string,
      type: string,
      options?: { durable?: boolean }
    ): Promise<any>;

    assertQueue(
      queue: string,
      options?: { durable?: boolean }
    ): Promise<any>;

    bindQueue(
      queue: string,
      exchange: string,
      routingKey: string
    ): Promise<any>;

    publish(
      exchange: string,
      routingKey: string,
      content: Buffer,
      options?: { persistent?: boolean }
    ): boolean;

    consume(
      queue: string,
      onMessage: (msg: ConsumeMessage | null) => void,
      options?: { noAck?: boolean }
    ): Promise<any>;

    ack(message: ConsumeMessage): void;
    nack(message: ConsumeMessage, allUpTo?: boolean, requeue?: boolean): void;

    close(): Promise<void>;
  }

  export interface ConsumeMessage {
    content: Buffer;
    fields: any;
    properties: any;
  }
  export function connect(url: string): Promise<Connection>;
}